<!doctype html>
<html itemscope itemtype="http://schema.org/WebPage" lang="en" class="no-js">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="canonical" type="text/html" href="http://localhost:1313/leetcode/">
<link rel="alternate" type="application/rss&#43;xml" href="http://localhost:1313/leetcode/index.xml">
<meta name="robots" content="noindex, nofollow">


<link rel="shortcut icon" href="/favicons/favicon.ico" >
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/favicons/android-36x36.png" sizes="36x36">
<link rel="icon" type="image/png" href="/favicons/android-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="/favicons/android-72x72.png" sizes="72x72">
<link rel="icon" type="image/png" href="/favicons/android-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicons/android-144x144.png" sizes="144x144">
<link rel="icon" type="image/png" href="/favicons/android-192x192.png" sizes="192x192">

<title>LeetCode | 海阔集</title>
<meta name="description" content="力扣题目解析 题目涉及到的解法以标签的形式注解
但请注意, 解法不唯一, 所有解析只提供一种解法, 以期抛转引玉 举一反三, 与君共勉">
<meta property="og:url" content="http://localhost:1313/leetcode/">
  <meta property="og:site_name" content="海阔集">
  <meta property="og:title" content="LeetCode">
  <meta property="og:description" content="力扣题目解析 题目涉及到的解法以标签的形式注解
但请注意, 解法不唯一, 所有解析只提供一种解法, 以期抛转引玉 举一反三, 与君共勉">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="website">

  <meta itemprop="name" content="LeetCode">
  <meta itemprop="description" content="力扣题目解析 题目涉及到的解法以标签的形式注解
但请注意, 解法不唯一, 所有解析只提供一种解法, 以期抛转引玉 举一反三, 与君共勉">
  <meta itemprop="dateModified" content="2025-02-11T00:25:32+08:00">
  <meta itemprop="wordCount" content="8">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="LeetCode">
  <meta name="twitter:description" content="力扣题目解析 题目涉及到的解法以标签的形式注解
但请注意, 解法不唯一, 所有解析只提供一种解法, 以期抛转引玉 举一反三, 与君共勉">
<link href="/scss/main.css" rel="stylesheet">
<script
  src="https://code.jquery.com/jquery-3.7.1.min.js"
  integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g=="
  crossorigin="anonymous"></script>
<script defer
  src="https://unpkg.com/lunr@2.3.9/lunr.min.js"
  integrity="sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli"
  crossorigin="anonymous"></script>

  </head>
  <body class="td-section">
    <header>
      <nav class="td-navbar js-navbar-scroll" data-bs-theme="dark">
<div class="container-fluid flex-column flex-md-row">
  <a class="navbar-brand" href="/"><span class="navbar-brand__logo navbar-logo"><svg width="800" height="800" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M23.3 8.40007 21.82 6.40008C21.7248 6.27314 21.6008 6.17066 21.4583 6.10111 21.3157 6.03156 21.1586 5.99693 21 6.00008H11.2C11.0555 6.00007 10.9128 6.03135 10.7816 6.09177 10.6504 6.15219 10.5339 6.24031 10.44 6.35007L8.71998 8.35008C8.57227 8.53401 8.49435 8.76424 8.49998 9.00008V16.2901C8.50262 18.0317 9.19567 19.7013 10.4272 20.9328c1.2316 1.2316 2.9011 1.9246 4.6428 1.9273h1.86C18.6716 22.8574 20.3412 22.1644 21.5728 20.9328c1.2315-1.2315 1.9245-2.9011 1.9272-4.6427V9.00008C23.5 8.7837 23.4298 8.57317 23.3 8.40007z" fill="#ffcc80"/><path d="M29.78 28.38l-4-5C25.664 23.2321 25.5086 23.1198 25.3318 23.0562 25.1549 22.9925 24.9637 22.98 24.78 23.02L16 25 7.21999 23C7.03632 22.96 6.84507 22.9725 6.6682 23.0362 6.49133 23.0998 6.33598 23.2121 6.21999 23.36l-4 5C2.10392 28.5064 2.03116 28.6823 2.00995 28.8679 1.98874 29.0534 2.01993 29.2413 2.09999 29.41 2.17815 29.5839 2.3044 29.7319 2.46385 29.8364 2.62331 29.9409 2.80933 29.9977 2.99999 30H29C29.1885 29.9995 29.373 29.9457 29.5322 29.8448 29.6914 29.744 29.8189 29.6002 29.9 29.43 29.98 29.2613 30.0112 29.0734 29.99 28.8879 29.9688 28.7023 29.8961 28.5264 29.78 28.38z" fill="#01579b"/><path d="M29.29 6.00003l-13-4C16.0999 1.95002 15.9001 1.95002 15.71 2.00003l-13 4c-.21258.06419-.39774.19732-.5263.37838C2.05515 6.55947 1.99052 6.77817 2 7.00003 1.9917 7.22447 2.0592 7.44518 2.19163 7.62659c.13242.1814.32207.31295.53837.37344L15.73 11.6C15.906 11.6534 16.094 11.6534 16.27 11.6l13-3.59997C29.4863 7.93954 29.6759 7.80799 29.8084 7.62659 29.9408 7.44518 30.0083 7.22447 30 7.00003 30.0095 6.77817 29.9448 6.55947 29.8163 6.37841 29.6877 6.19735 29.5026 6.06422 29.29 6.00003z" fill="#01579b"/><path d="M11.22 6C11.0756 5.99999 10.9328 6.03127 10.8016 6.09169 10.6704 6.15211 10.5539 6.24023 10.46 6.35l-1.72 2C8.58509 8.53114 8.49998 8.76166 8.5 9v7.29C8.50264 18.0317 9.19569 19.7012 10.4272 20.9328c1.2316 1.2315 2.9011 1.9246 4.6428 1.9272H16V6H11.22z" fill="#ffe0b2"/><path d="M7.21999 23C7.03632 22.96 6.84507 22.9725 6.6682 23.0362 6.49133 23.0998 6.33598 23.2121 6.21999 23.36l-4 5C2.10392 28.5064 2.03116 28.6823 2.00995 28.8679 1.98874 29.0534 2.01993 29.2413 2.09999 29.41 2.17815 29.5839 2.3044 29.7319 2.46385 29.8364 2.62331 29.9409 2.80933 29.9977 2.99999 30H16V25L7.21999 23z" fill="#0277bd"/><path d="M15.71 2.00002l-13 4C2.49742 6.06422 2.31226 6.19734 2.1837 6.3784c-.12855.18107-.19318.39977-.1837.62162C1.9917 7.22447 2.0592 7.44518 2.19163 7.62658 2.32405 7.80799 2.5137 7.93954 2.73 8.00002L15.73 11.6C15.8194 11.6146 15.9106 11.6146 16 11.6V2.00002C15.9039 1.98469 15.8061 1.98469 15.71 2.00002z" fill="#0277bd"/><path d="M2.73 8.00003l5.77 1.56V16.29C8.50264 18.0317 9.19569 19.7013 10.4272 20.9328c1.2316 1.2315 2.9011 1.9246 4.6428 1.9272h1.86C18.6717 22.8574 20.3412 22.1643 21.5728 20.9328c1.2315-1.2315 1.9246-2.9011 1.9272-4.6428V9.56003l5.77-1.56C29.4863 7.93954 29.6759 7.80799 29.8084 7.62659 29.9408 7.44518 30.0083 7.22447 30 7.00003 30.0095 6.77817 29.9448 6.55947 29.8163 6.37841 29.6877 6.19735 29.5026 6.06422 29.29 6.00003l-13-4C16.0999 1.95002 15.9001 1.95002 15.71 2.00003l-13 4c-.21258.06419-.39774.19732-.5263.37838C2.05515 6.55947 1.99052 6.77817 2 7.00003 1.9917 7.22447 2.0592 7.44518 2.19163 7.62659c.13242.1814.32207.31295.53837.37344zM21.5 16.29C21.4974 17.5013 21.015 18.6621 20.1586 19.5186 19.3021 20.3751 18.1412 20.8574 16.93 20.86H15.07C13.8588 20.8574 12.6979 20.3751 11.8414 19.5186 10.985 18.6621 10.5026 17.5013 10.5 16.29V10.11l5.23 1.45C15.906 11.6134 16.094 11.6134 16.27 11.56l5.23-1.45v6.18zM16 4.05003l9.44 2.95-9.44 2.56-9.44-2.56 9.44-2.95z" fill="#263238"/><path d="M25.78 23.38C25.664 23.2321 25.5086 23.1198 25.3318 23.0562 25.1549 22.9925 24.9637 22.98 24.78 23.02L16 25 7.21999 23C7.03632 22.96 6.84507 22.9725 6.6682 23.0362 6.49133 23.0998 6.33598 23.2121 6.21999 23.36l-4 5C2.10392 28.5064 2.03116 28.6823 2.00995 28.8679 1.98874 29.0534 2.01993 29.2413 2.09999 29.41 2.17815 29.5839 2.3044 29.7319 2.46385 29.8364 2.62331 29.9409 2.80933 29.9977 2.99999 30H29C29.1885 29.9995 29.373 29.9457 29.5322 29.8448 29.6914 29.744 29.8189 29.6002 29.9 29.43 29.98 29.2613 30.0112 29.0734 29.99 28.8879 29.9688 28.7023 29.8961 28.5264 29.78 28.38l-4-5zM5.07999 28l2.31-2.89L15.78 27C15.9251 27.0299 16.0748 27.0299 16.22 27l8.39-1.87L26.92 28H5.07999z" fill="#263238"/></svg></span><span class="navbar-brand__name">海阔集</span></a>
  <div class="td-navbar-nav-scroll ms-md-auto" id="main_navbar">
    <ul class="navbar-nav">
      <li class="nav-item">
        <a class="nav-link active" href="/leetcode/"><span>Alog</span></a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="/docs/"><span>Doc</span></a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="/interview/"><span>Interview</span></a>
      </li>
      <li class="td-light-dark-menu nav-item dropdown">
        <svg xmlns="http://www.w3.org/2000/svg" class="d-none">
  <symbol id="check2" viewBox="0 0 16 16">
    <path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"/>
  </symbol>
  <symbol id="circle-half" viewBox="0 0 16 16">
    <path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"/>
  </symbol>
  <symbol id="moon-stars-fill" viewBox="0 0 16 16">
    <path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/>
    <path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"/>
  </symbol>
  <symbol id="sun-fill" viewBox="0 0 16 16">
    <path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>
  </symbol>
</svg>

<button class="btn btn-link nav-link dropdown-toggle d-flex align-items-center"
        id="bd-theme"
        type="button"
        aria-expanded="false"
        data-bs-toggle="dropdown"
        data-bs-display="static"
        aria-label="Toggle theme (auto)">
  <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg>
</button>
<ul class="dropdown-menu dropdown-menu-end" aria-labelledby="bd-theme-text">
  <li>
    <button type="button" class="dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
      <svg class="bi me-2 opacity-50"><use href="#sun-fill"></use></svg>
      Light
      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg>
    </button>
  </li>
  <li>
    <button type="button" class="dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
      <svg class="bi me-2 opacity-50"><use href="#moon-stars-fill"></use></svg>
      Dark
      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg>
    </button>
  </li>
  <li>
    <button type="button" class="dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
      <svg class="bi me-2 opacity-50"><use href="#circle-half"></use></svg>
      Auto
      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg>
    </button>
  </li>
</ul>

      </li>
      </ul>
  </div>
  <div class="d-none d-lg-block">
    <div class="td-search td-search--offline">
  <div class="td-search__icon"></div>
  <input
    type="search"
    class="td-search__input form-control"
    placeholder="Search this site…"
    aria-label="Search this site…"
    autocomplete="off"
    
    data-offline-search-index-json-src="/offline-search-index.json"
    data-offline-search-base-href="/"
    data-offline-search-max-results="10"
  >
</div>
  </div>
</div>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <main class="col-12 col-md-9 col-xl-8 ps-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
This is the multi-page printable view of this section.
<a href="#" onclick="print();return false;">Click here to print</a>.
</p><p>
<a href="/leetcode/">Return to the regular view of this page</a>.
</p>
</div>



<h1 class="title">LeetCode</h1>





    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-157ca9df9b6274b03f50672e09732ba7">138. 随机链表的复制</a></li>


    
  
    
    
	
<li>2: <a href="#pg-2fed2e72c880f30b89ab7a8240bb7913">141. 环形链表</a></li>


    
  
    
    
	
<li>3: <a href="#pg-bc2df3247dd6810a62cfac3385382ff1">160. 相交链表</a></li>


    
  
    
    
	
<li>4: <a href="#pg-bdfb7b595fe1a5c22f017311d22e889f">19. 删除链表的倒数第 N 个结点</a></li>


    
  
    
    
	
<li>5: <a href="#pg-ba883d4a71661acc34f473904f1b6ab2">206. 反转链表</a></li>


    
  
    
    
	
<li>6: <a href="#pg-c0fbb01739242a6b8c51f8cbe317c164">21. 合并两个有序链表</a></li>


    
  
    
    
	
<li>7: <a href="#pg-297315f5ad07c8e1aaffb94629c43f56">23. 合并 K 个升序链表</a></li>


    
  
    
    
	
<li>8: <a href="#pg-eec13996139e7707a6b9b6852c1af215">24. 两两交换链表中的节点</a></li>


    
  
    
    
	
<li>9: <a href="#pg-25a4025aaa80de9cda034e0c0ebca5ab">25. K 个一组翻转链表</a></li>


    
  
    
    
	
<li>10: <a href="#pg-ac0e412f4d9fbdb1f5869166289c7cd1">59. 螺旋矩阵 II</a></li>


    
  

    </ul>


<div class="content">
      

<div class="pageinfo pageinfo-primary">
<p>力扣题目解析
题目涉及到的解法以标签的形式注解</p>
<p>
但请注意, 解法不唯一, 所有解析只提供一种解法, 以期抛转引玉
<p>
举一反三, 与君共勉

</div>


</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-157ca9df9b6274b03f50672e09732ba7">1 - 138. 随机链表的复制</h1>
    <div class="lead">构造这个链表的 深拷贝。</div>
	<h4 id="题意">题意:<a class="td-heading-self-link" href="#%e9%a2%98%e6%84%8f" aria-label="Heading self-link"></a></h4>
<p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p>
<p>构造这个链表的 <strong><a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a></strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p>
<p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p>
<p>返回复制链表的头节点。</p>
<p>用一个由 <code>n</code> 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p>
<ul>
<li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li>
<li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为  <code>null</code> 。</li>
</ul>
<p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p>
<h4 id="难度">难度:<a class="td-heading-self-link" href="#%e9%9a%be%e5%ba%a6" aria-label="Heading self-link"></a></h4>
<p>中等</p>
<h4 id="分析">分析:<a class="td-heading-self-link" href="#%e5%88%86%e6%9e%90" aria-label="Heading self-link"></a></h4>
<p>和通常的深拷贝不同的是, 这里的节点多了随机指针</p>
<p>那么在拷贝随机指针之前, 就必须有原链表</p>
<p>因此分为三步</p>
<ul>
<li>拷贝原链表</li>
<li>拷贝随机指针</li>
<li>分离链表</li>
</ul>
<p><strong>复制节点并插入原节点后面</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#ca9ee6">while</span> (cur <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {
</span></span><span style="display:flex;"><span>    Node newNode <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Node(cur.<span style="color:#8caaee">val</span>);
</span></span><span style="display:flex;"><span>    newNode.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> cur.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>    cur.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> newNode;
</span></span><span style="display:flex;"><span>    cur <span style="color:#99d1db;font-weight:bold">=</span> newNode.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>比如原链表：A-&gt;B-&gt;C 变成 A-&gt;A&rsquo;-&gt;B-&gt;B&rsquo;-&gt;C-&gt;C'</p>
<p><strong>复制随机指针</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#ca9ee6">while</span> (cur <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (cur.<span style="color:#8caaee">random</span> <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {
</span></span><span style="display:flex;"><span>        cur.<span style="color:#8caaee">next</span>.<span style="color:#8caaee">random</span> <span style="color:#99d1db;font-weight:bold">=</span> cur.<span style="color:#8caaee">random</span>.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cur <span style="color:#99d1db;font-weight:bold">=</span> cur.<span style="color:#8caaee">next</span>.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>利用第一步创建的节点关系，设置复制节点的random指针：</p>
<ul>
<li>如果原节点A的random指向节点C</li>
<li>那么A&rsquo;的random就应该指向C&rsquo;（即C的next）</li>
</ul>
<p><strong>分离两个链表</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">while</span> (cur <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {
</span></span><span style="display:flex;"><span>    Node next <span style="color:#99d1db;font-weight:bold">=</span> cur.<span style="color:#8caaee">next</span>.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>    Node copy <span style="color:#99d1db;font-weight:bold">=</span> cur.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>    copyCur.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> copy;
</span></span><span style="display:flex;"><span>    copyCur <span style="color:#99d1db;font-weight:bold">=</span> copy;
</span></span><span style="display:flex;"><span>    cur.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> next;
</span></span><span style="display:flex;"><span>    cur <span style="color:#99d1db;font-weight:bold">=</span> next;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>将交织在一起的链表分开：</p>
<ul>
<li>原链表恢复原样：A-&gt;B-&gt;C</li>
<li>得到复制的链表：A&rsquo;-&gt;B&rsquo;-&gt;C'</li>
</ul>
<h4 id="整体">整体:<a class="td-heading-self-link" href="#%e6%95%b4%e4%bd%93" aria-label="Heading self-link"></a></h4>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">class</span> <span style="color:#e5c890">Solution</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> Node <span style="color:#8caaee">copyRandomList</span>(Node head) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (head <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 第一步：在每个原节点后创建一个新节点</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Node cur <span style="color:#99d1db;font-weight:bold">=</span> head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">while</span> (cur <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Node newNode <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Node(cur.<span style="color:#8caaee">val</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            newNode.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> cur.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            cur.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> newNode;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            cur <span style="color:#99d1db;font-weight:bold">=</span> newNode.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 第二步：处理random指针</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        cur <span style="color:#99d1db;font-weight:bold">=</span> head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">while</span> (cur <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (cur.<span style="color:#8caaee">random</span> <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                cur.<span style="color:#8caaee">next</span>.<span style="color:#8caaee">random</span> <span style="color:#99d1db;font-weight:bold">=</span> cur.<span style="color:#8caaee">random</span>.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            cur <span style="color:#99d1db;font-weight:bold">=</span> cur.<span style="color:#8caaee">next</span>.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 第三步：分离两个链表</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Node dummy <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Node(0);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Node copyCur <span style="color:#99d1db;font-weight:bold">=</span> dummy;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        cur <span style="color:#99d1db;font-weight:bold">=</span> head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">while</span> (cur <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">// 保存下一个原始节点</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Node next <span style="color:#99d1db;font-weight:bold">=</span> cur.<span style="color:#8caaee">next</span>.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">// 复制的节点</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Node copy <span style="color:#99d1db;font-weight:bold">=</span> cur.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            copyCur.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> copy;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            copyCur <span style="color:#99d1db;font-weight:bold">=</span> copy;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">// 恢复原始链表</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            cur.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            cur <span style="color:#99d1db;font-weight:bold">=</span> next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> dummy.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2fed2e72c880f30b89ab7a8240bb7913">2 - 141. 环形链表</h1>
    <div class="lead">给你一个链表的头节点 head ，判断链表中是否有环。</div>
	<h4 id="题意">题意:<a class="td-heading-self-link" href="#%e9%a2%98%e6%84%8f" aria-label="Heading self-link"></a></h4>
<p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p>
<p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<h4 id="难度">难度:<a class="td-heading-self-link" href="#%e9%9a%be%e5%ba%a6" aria-label="Heading self-link"></a></h4>
<p>简单</p>
<h4 id="示例">示例:<a class="td-heading-self-link" href="#%e7%a4%ba%e4%be%8b" aria-label="Heading self-link"></a></h4>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt=""></p>
<p>输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。</p>
<h4 id="解析">解析:<a class="td-heading-self-link" href="#%e8%a7%a3%e6%9e%90" aria-label="Heading self-link"></a></h4>
<p>使用循环遍历链表查重的方法内存和时间开销很大</p>
<p>这里介绍一种算法, 龟兔赛跑算法, 就是快慢指针</p>
<p>定义两个指针, 二者遍历速度不同, 这样就可以保证快指针在有环的情况下可以追上慢指针</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">Solution</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#e78284">public</span> <span style="color:#e78284">boolean</span> <span style="color:#8caaee">hasCycle</span>(ListNode head) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (head <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">||</span> head.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">false</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ListNode slow <span style="color:#99d1db;font-weight:bold">=</span> head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ListNode fast <span style="color:#99d1db;font-weight:bold">=</span> head.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">while</span> (slow <span style="color:#99d1db;font-weight:bold">!=</span> fast) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (fast <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">||</span> fast.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">false</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        slow <span style="color:#99d1db;font-weight:bold">=</span> slow.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        fast <span style="color:#99d1db;font-weight:bold">=</span> fast.<span style="color:#8caaee">next</span>.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">true</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bc2df3247dd6810a62cfac3385382ff1">3 - 160. 相交链表</h1>
    <div class="lead">给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</div>
	<h4 id="题意">题意:<a class="td-heading-self-link" href="#%e9%a2%98%e6%84%8f" aria-label="Heading self-link"></a></h4>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交</p>
<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt=""></a></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<h4 id="难度">难度:<a class="td-heading-self-link" href="#%e9%9a%be%e5%ba%a6" aria-label="Heading self-link"></a></h4>
<p>简单</p>
<h4 id="示例">示例:<a class="td-heading-self-link" href="#%e7%a4%ba%e4%be%8b" aria-label="Heading self-link"></a></h4>
<p><strong>示例 1：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt=""></a></p>
<p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</p>
<p>输出：Intersected at &lsquo;8&rsquo;</p>
<h4 id="分析">分析:<a class="td-heading-self-link" href="#%e5%88%86%e6%9e%90" aria-label="Heading self-link"></a></h4>
<p>判断相交在链表中是一项很基本, 也很重要的算法</p>
<p>我们可以将两个链表分别遍历并放入哈希表中去重, 但是当数组较长时会浪费许多资源</p>
<p>其实这道题的核心是找出第一个相交节点, 而非全部节点, 所以可以使用双指针同时遍历两个链表</p>
<p>大致思路如下:</p>
<ol>
<li>设置两个指针分别指向两个链表的头部</li>
<li>判断是否重复, 重复即为相交</li>
<li>首先移动其中一个指针, 判断重复</li>
<li>移动另一个指针, 判断重复</li>
<li>直至某个指针为空返回false</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">Solution</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> ListNode <span style="color:#8caaee">getIntersectionNode</span>(ListNode headA, ListNode headB) {<span style="color:#737994;font-style:italic">// 定义两个指针，初始分别指向两个链表头部</span>
</span></span><span style="display:flex;"><span>  <span style="color:#737994;font-style:italic">// 如果任一链表为空，则不可能相交</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (headA <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">||</span> headB <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">null</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ListNode ptrA <span style="color:#99d1db;font-weight:bold">=</span> headA;
</span></span><span style="display:flex;"><span>        ListNode ptrB <span style="color:#99d1db;font-weight:bold">=</span> headB;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 当两个指针不相等时继续遍历</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">while</span> (ptrA <span style="color:#99d1db;font-weight:bold">!=</span> ptrB) {
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">// 移动指针A</span>
</span></span><span style="display:flex;"><span>            ptrA <span style="color:#99d1db;font-weight:bold">=</span> ptrA <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">?</span> headB : ptrA.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">// 移动指针B</span>
</span></span><span style="display:flex;"><span>            ptrB <span style="color:#99d1db;font-weight:bold">=</span> ptrB <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">?</span> headA : ptrB.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>         <span style="color:#737994;font-style:italic">// 返回相交节点，如果不存在则返回null</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> ptrA;
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bdfb7b595fe1a5c22f017311d22e889f">4 - 19. 删除链表的倒数第 N 个结点</h1>
    <div class="lead">给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</div>
	<h4 id="题意">题意:<a class="td-heading-self-link" href="#%e9%a2%98%e6%84%8f" aria-label="Heading self-link"></a></h4>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<h4 id="示例">示例:<a class="td-heading-self-link" href="#%e7%a4%ba%e4%be%8b" aria-label="Heading self-link"></a></h4>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt=""></p>
<p>输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]</p>
<h4 id="难度">难度:<a class="td-heading-self-link" href="#%e9%9a%be%e5%ba%a6" aria-label="Heading self-link"></a></h4>
<p>中等</p>
<h4 id="分析">分析:<a class="td-heading-self-link" href="#%e5%88%86%e6%9e%90" aria-label="Heading self-link"></a></h4>
<p>题目一共要求做两件事</p>
<ol>
<li>找到链表的倒数第n个节点</li>
<li>删除该节点</li>
</ol>
<p>对于单项链表, 如何找到节点的位置?</p>
<p>可以两次遍历, 第一次遍历拿链表长度</p>
<p>第二次才获取具体的节点</p>
<p>如何删除该节点?</p>
<p>删除节点涉及到三个部分</p>
<p>前驱节点, 该节点, 后驱节点</p>
<p>所以我们在第一步拿到前驱节点, 并保存后驱节点, 修改引用就算删除完毕</p>
<p>遍历链表</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span> <span style="color:#ca9ee6">while</span> (current <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) { length<span style="color:#99d1db;font-weight:bold">++</span>; current <span style="color:#99d1db;font-weight:bold">=</span> current.<span style="color:#8caaee">next</span>; }
</span></span></code></pre></div><p><strong>注意是倒数第 n 个节点，所以要用链表的长度减去 n</strong>。倒数第 4 个节点的前一个节点就是 5-4=1，也就是第一个节点。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">class</span> <span style="color:#e5c890">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> ListNode <span style="color:#8caaee">removeNthFromEnd</span>(ListNode head, <span style="color:#e78284">int</span> n) {
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 创建一个虚拟头节点，简化边界条件处理</span>
</span></span><span style="display:flex;"><span>        ListNode dummy <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> ListNode(0);
</span></span><span style="display:flex;"><span>        dummy.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> head;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 第一次遍历，计算链表的总长度</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">int</span> length <span style="color:#99d1db;font-weight:bold">=</span> 0;
</span></span><span style="display:flex;"><span>        ListNode current <span style="color:#99d1db;font-weight:bold">=</span> head;
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">while</span> (current <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {
</span></span><span style="display:flex;"><span>            length<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>            current <span style="color:#99d1db;font-weight:bold">=</span> current.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 设置长度为到达要删除的节点的前一个节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">int</span> index <span style="color:#99d1db;font-weight:bold">=</span> length <span style="color:#99d1db;font-weight:bold">-</span> n;
</span></span><span style="display:flex;"><span>        current <span style="color:#99d1db;font-weight:bold">=</span> dummy;
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 第二次遍历，找到要删除的节点的前一个节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> 0; i <span style="color:#99d1db;font-weight:bold">&lt;</span> index; i<span style="color:#99d1db;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>            current <span style="color:#99d1db;font-weight:bold">=</span> current.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 删除节点，即跳过要删除的节点</span>
</span></span><span style="display:flex;"><span>        current.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> current.<span style="color:#8caaee">next</span>.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> dummy.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ba883d4a71661acc34f473904f1b6ab2">5 - 206. 反转链表</h1>
    <div class="lead">给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</div>
	<h4 id="题意">题意:<a class="td-heading-self-link" href="#%e9%a2%98%e6%84%8f" aria-label="Heading self-link"></a></h4>
<p>翻转给定的链表</p>
<h4 id="示例">示例:<a class="td-heading-self-link" href="#%e7%a4%ba%e4%be%8b" aria-label="Heading self-link"></a></h4>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt=""></p>
<p>输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]</p>
<h4 id="难度">难度:<a class="td-heading-self-link" href="#%e9%9a%be%e5%ba%a6" aria-label="Heading self-link"></a></h4>
<p>简单</p>
<h4 id="分析">分析:<a class="td-heading-self-link" href="#%e5%88%86%e6%9e%90" aria-label="Heading self-link"></a></h4>
<p>链表翻转有两种方法</p>
<ol>
<li>迭代</li>
<li>递归</li>
</ol>
<p>这里我们用迭代法</p>
<p>从图中可以看出, 对链表的翻转可以理解为箭头方向变化</p>
<p>这样我们可以讲链表转为两两一组的节点对, 从头开始迭代</p>
<p>对于节点对, 我们分为首节点和次节点, 在单向链表, 次节点指向其他节点, 一旦断开次节点的引用, 其他节点会丢失</p>
<p>所以需要提前存储其他节点</p>
<p>改变引用关系大致流程如下:</p>
<ol>
<li>获得首节点</li>
<li>临时存储其他节点</li>
<li>次节点指向首节点</li>
<li>迭代, 次节点为下一代的首节点, 临时存储节点为次节点</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">class</span> <span style="color:#e5c890">Solution</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> ListNode <span style="color:#8caaee">reverseList</span>(ListNode head) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//迭代法</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ListNode current <span style="color:#99d1db;font-weight:bold">=</span> head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ListNode previous <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ef9f76">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">while</span>(current <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>){
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            ListNode temp <span style="color:#99d1db;font-weight:bold">=</span> current.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            current.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> previous;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            previous <span style="color:#99d1db;font-weight:bold">=</span> current;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            current <span style="color:#99d1db;font-weight:bold">=</span> temp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> previous;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c0fbb01739242a6b8c51f8cbe317c164">6 - 21. 合并两个有序链表</h1>
    <div class="lead">将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</div>
	<h4 id="题意">题意:<a class="td-heading-self-link" href="#%e9%a2%98%e6%84%8f" aria-label="Heading self-link"></a></h4>
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<h4 id="难度">难度:<a class="td-heading-self-link" href="#%e9%9a%be%e5%ba%a6" aria-label="Heading self-link"></a></h4>
<p>简单</p>
<h4 id="示例">示例:<a class="td-heading-self-link" href="#%e7%a4%ba%e4%be%8b" aria-label="Heading self-link"></a></h4>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt=""></p>
<p>输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]</p>
<h4 id="分析">分析:<a class="td-heading-self-link" href="#%e5%88%86%e6%9e%90" aria-label="Heading self-link"></a></h4>
<p>提供的链表有序, 所以可以同时遍历. 连接较小的节点即可</p>
<ul>
<li>创建哑结点, 作为链表头, 当前节点为哑结点</li>
<li>同时比较两个链表, 当前节点连接较小节点, 当前节点后驱, 当前节点为新节点</li>
<li>直至某个链表遍历完成, 拼接其剩余节点</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">class</span> <span style="color:#e5c890">Solution</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> ListNode <span style="color:#8caaee">mergeTwoLists</span>(ListNode l1, ListNode l2) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 创建哑节点作为合并后链表的头部</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ListNode dummy <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> ListNode(0);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ListNode current <span style="color:#99d1db;font-weight:bold">=</span> dummy;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 同时遍历两个链表，比较节点值</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">while</span> (l1 <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">&amp;&amp;</span> l2 <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (l1.<span style="color:#8caaee">val</span> <span style="color:#99d1db;font-weight:bold">&lt;=</span> l2.<span style="color:#8caaee">val</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                current.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> l1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                l1 <span style="color:#99d1db;font-weight:bold">=</span> l1.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            } <span style="color:#ca9ee6">else</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                current.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> l2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                l2 <span style="color:#99d1db;font-weight:bold">=</span> l2.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            current <span style="color:#99d1db;font-weight:bold">=</span> current.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 将剩余节点接到合并后的链表末尾</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        current.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> (l1 <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) <span style="color:#99d1db;font-weight:bold">?</span> l1 : l2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> dummy.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-297315f5ad07c8e1aaffb94629c43f56">7 - 23. 合并 K 个升序链表</h1>
    <div class="lead">给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表</div>
	<h4 id="题意">题意:<a class="td-heading-self-link" href="#%e9%a2%98%e6%84%8f" aria-label="Heading self-link"></a></h4>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<h4 id="示例">示例:<a class="td-heading-self-link" href="#%e7%a4%ba%e4%be%8b" aria-label="Heading self-link"></a></h4>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250208103925259.png" alt="image.png"></p>
<p>合并链表. 最容易想到的就是依次合并</p>
<p>首先合并 1,2
之后合并3 这样依次合并</p>
<p>如何合并?</p>
<p>因为所提供的链表都是有顺序的
所以采用双指针方式</p>
<ul>
<li>比较两个节点的值</li>
<li>将较小的节点连接到结果链表</li>
<li>移动较小节点所在链表的指针</li>
<li>移动结果链表的指针</li>
<li>遍历完成后, 剩余节点直接拼接</li>
</ul>
<p>但很遗憾，这样做的话，每一次合并后的新链表就会非常臃肿，并且在与第 K 个链表合并时，之前链表的节点会多次被访问。</p>
<p>我们可以使用分治的思想解决</p>
<p>为了解决臃肿和重复遍历的问题, 把链表的整体合并转为两两合并链表的子问题</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250208105020475.png" alt="image.png"></p>
<p>首先判空</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#ca9ee6">if</span> (lists <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">||</span> lists.<span style="color:#8caaee">length</span> <span style="color:#99d1db;font-weight:bold">==</span> 0) {
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">null</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>设置间隔, 每次只对间隔的头结点做合并操作</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">int</span> interval <span style="color:#99d1db;font-weight:bold">=</span> 1;  <span style="color:#737994;font-style:italic">// 初始间隔为1</span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">while</span> (interval <span style="color:#99d1db;font-weight:bold">&lt;</span> n) {  <span style="color:#737994;font-style:italic">// 当间隔小于链表总数时继续循环</span>
</span></span></code></pre></div><p>这里使用interval来控制合并的步长，比如：</p>
<ul>
<li>第一轮：interval = 1，两两合并</li>
<li>第二轮：interval = 2，每次合并相隔2个位置的链表</li>
<li>第三轮：interval = 4，每次合并相隔4个位置的链表</li>
</ul>
<p>合并</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> 0; i <span style="color:#99d1db;font-weight:bold">&lt;</span> n <span style="color:#99d1db;font-weight:bold">-</span> interval; i <span style="color:#99d1db;font-weight:bold">+=</span> interval <span style="color:#99d1db;font-weight:bold">*</span> 2) {
</span></span><span style="display:flex;"><span>    lists<span style="color:#99d1db;font-weight:bold">[</span>i<span style="color:#99d1db;font-weight:bold">]</span> <span style="color:#99d1db;font-weight:bold">=</span> merge2Lists(lists<span style="color:#99d1db;font-weight:bold">[</span>i<span style="color:#99d1db;font-weight:bold">]</span>, lists<span style="color:#99d1db;font-weight:bold">[</span>i <span style="color:#99d1db;font-weight:bold">+</span> interval<span style="color:#99d1db;font-weight:bold">]</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>合并逻辑</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#ca9ee6">while</span> (l1 <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">&amp;&amp;</span> l2 <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (l1.<span style="color:#8caaee">val</span> <span style="color:#99d1db;font-weight:bold">&lt;=</span> l2.<span style="color:#8caaee">val</span>) {
</span></span><span style="display:flex;"><span>        current.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> l1;
</span></span><span style="display:flex;"><span>        l1 <span style="color:#99d1db;font-weight:bold">=</span> l1.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#ca9ee6">else</span> {
</span></span><span style="display:flex;"><span>        current.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> l2;
</span></span><span style="display:flex;"><span>        l2 <span style="color:#99d1db;font-weight:bold">=</span> l2.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    current <span style="color:#99d1db;font-weight:bold">=</span> current.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//处理剩余节点</span>
</span></span><span style="display:flex;"><span>current.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> (l1 <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) <span style="color:#99d1db;font-weight:bold">?</span> l1 : l2;
</span></span></code></pre></div><p>整体如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">class</span> <span style="color:#e5c890">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> ListNode <span style="color:#8caaee">mergeKLists</span>(ListNode<span style="color:#99d1db;font-weight:bold">[]</span> lists) {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (lists <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">||</span> lists.<span style="color:#8caaee">length</span> <span style="color:#99d1db;font-weight:bold">==</span> 0) {
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">null</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">int</span> n <span style="color:#99d1db;font-weight:bold">=</span> lists.<span style="color:#8caaee">length</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">int</span> interval <span style="color:#99d1db;font-weight:bold">=</span> 1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">while</span> (interval <span style="color:#99d1db;font-weight:bold">&lt;</span> n) {
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> 0; i <span style="color:#99d1db;font-weight:bold">&lt;</span> n <span style="color:#99d1db;font-weight:bold">-</span> interval; i <span style="color:#99d1db;font-weight:bold">+=</span> interval <span style="color:#99d1db;font-weight:bold">*</span> 2) {
</span></span><span style="display:flex;"><span>                lists<span style="color:#99d1db;font-weight:bold">[</span>i<span style="color:#99d1db;font-weight:bold">]</span> <span style="color:#99d1db;font-weight:bold">=</span> merge2Lists(lists<span style="color:#99d1db;font-weight:bold">[</span>i<span style="color:#99d1db;font-weight:bold">]</span>, lists<span style="color:#99d1db;font-weight:bold">[</span>i <span style="color:#99d1db;font-weight:bold">+</span> interval<span style="color:#99d1db;font-weight:bold">]</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            interval <span style="color:#99d1db;font-weight:bold">*=</span> 2;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> lists<span style="color:#99d1db;font-weight:bold">[</span>0<span style="color:#99d1db;font-weight:bold">]</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> ListNode <span style="color:#8caaee">merge2Lists</span>(ListNode l1, ListNode l2) {
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 创建哑节点作为合并后链表的头部</span>
</span></span><span style="display:flex;"><span>        ListNode dummy <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> ListNode(0);
</span></span><span style="display:flex;"><span>        ListNode current <span style="color:#99d1db;font-weight:bold">=</span> dummy;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 同时遍历两个链表，比较节点值</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">while</span> (l1 <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">&amp;&amp;</span> l2 <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (l1.<span style="color:#8caaee">val</span> <span style="color:#99d1db;font-weight:bold">&lt;=</span> l2.<span style="color:#8caaee">val</span>) {
</span></span><span style="display:flex;"><span>                current.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> l1;
</span></span><span style="display:flex;"><span>                l1 <span style="color:#99d1db;font-weight:bold">=</span> l1.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#ca9ee6">else</span> {
</span></span><span style="display:flex;"><span>                current.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> l2;
</span></span><span style="display:flex;"><span>                l2 <span style="color:#99d1db;font-weight:bold">=</span> l2.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            current <span style="color:#99d1db;font-weight:bold">=</span> current.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 将剩余节点接到合并后的链表末尾</span>
</span></span><span style="display:flex;"><span>        current.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> (l1 <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) <span style="color:#99d1db;font-weight:bold">?</span> l1 : l2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> dummy.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-eec13996139e7707a6b9b6852c1af215">8 - 24. 两两交换链表中的节点</h1>
    <div class="lead">给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）</div>
	<h4 id="题意">题意:<a class="td-heading-self-link" href="#%e9%a2%98%e6%84%8f" aria-label="Heading self-link"></a></h4>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。
你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<h4 id="难度">难度:<a class="td-heading-self-link" href="#%e9%9a%be%e5%ba%a6" aria-label="Heading self-link"></a></h4>
<p>中等</p>
<h4 id="示例">示例:<a class="td-heading-self-link" href="#%e7%a4%ba%e4%be%8b" aria-label="Heading self-link"></a></h4>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt=""></p>
<p>输入：head = [1,2,3,4]
输出：[2,1,4,3]</p>
<h4 id="分析">分析:<a class="td-heading-self-link" href="#%e5%88%86%e6%9e%90" aria-label="Heading self-link"></a></h4>
<p>看到这道题，我们要先搞清楚什么是两两交换，比如 1-&gt;2-&gt;3-&gt;4，交换后就是 2-&gt;1-&gt;4-&gt;3。</p>
<p>第一个和第二个交换，第三个和第四个交换，以此类推。</p>
<p>那么就可以把整个链转为子链, 通过递归处理</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * Definition for singly-linked list.
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * public class ListNode {
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *     ListNode next;
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *     ListNode() {}
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *     ListNode(int val) { this.val = val; }
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * }
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">class</span> <span style="color:#e5c890">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> ListNode <span style="color:#8caaee">swapPairs</span>(ListNode head) {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> swapAndConnect(head);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> ListNode <span style="color:#8caaee">swapAndConnect</span>(ListNode node) {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (node <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">||</span> node.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">// 如果当前节点或下一个节点为空，直接返回当前节点</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">return</span> node;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 递归：获取后面的交换结果</span>
</span></span><span style="display:flex;"><span>        ListNode partner <span style="color:#99d1db;font-weight:bold">=</span> node.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>        ListNode next <span style="color:#99d1db;font-weight:bold">=</span> swapAndConnect(partner.<span style="color:#8caaee">next</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 交换当前节点和下一个节点</span>
</span></span><span style="display:flex;"><span>        node.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> next;
</span></span><span style="display:flex;"><span>        partner.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> node;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 返回交换后的新头节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> partner;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-25a4025aaa80de9cda034e0c0ebca5ab">9 - 25. K 个一组翻转链表</h1>
    <div class="lead">给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</div>
	<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * Definition for singly-linked list.
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * public class ListNode {
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *     ListNode next;
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *     ListNode() {}
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *     ListNode(int val) { this.val = val; }
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * }
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">class</span> <span style="color:#e5c890">Solution</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     <span style="color:#e78284">public</span> ListNode <span style="color:#8caaee">reverseKGroup</span>(ListNode head, <span style="color:#e78284">int</span> k) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 基本判断</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (head <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">||</span> k <span style="color:#99d1db;font-weight:bold">==</span> 1) <span style="color:#ca9ee6">return</span> head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 计算当前组的长度是否够k个节点</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ListNode curr <span style="color:#99d1db;font-weight:bold">=</span> head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">int</span> count <span style="color:#99d1db;font-weight:bold">=</span> 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">while</span> (curr <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">&amp;&amp;</span> count <span style="color:#99d1db;font-weight:bold">&lt;</span> k) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            curr <span style="color:#99d1db;font-weight:bold">=</span> curr.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            count<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 如果不够k个节点，保持原有顺序</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (count <span style="color:#99d1db;font-weight:bold">&lt;</span> k) <span style="color:#ca9ee6">return</span> head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 递归处理后续节点组</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        curr <span style="color:#99d1db;font-weight:bold">=</span> reverseKGroup(curr, k);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 翻转当前组的k个节点</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ListNode prev <span style="color:#99d1db;font-weight:bold">=</span> curr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ListNode now <span style="color:#99d1db;font-weight:bold">=</span> head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">while</span> (count <span style="color:#99d1db;font-weight:bold">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            ListNode next <span style="color:#99d1db;font-weight:bold">=</span> now.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            now.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> prev;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            prev <span style="color:#99d1db;font-weight:bold">=</span> now;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            now <span style="color:#99d1db;font-weight:bold">=</span> next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            count<span style="color:#99d1db;font-weight:bold">--</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> prev;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ac0e412f4d9fbdb1f5869166289c7cd1">10 - 59. 螺旋矩阵 II</h1>
    <div class="lead">给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</div>
	<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<h4 id="示例">示例:<a class="td-heading-self-link" href="#%e7%a4%ba%e4%be%8b" aria-label="Heading self-link"></a></h4>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt=""></p>
<p>输入：n = 3
输出：[1,2,3],[8,9,4],[7,6,5]</p>
<h4 id="难度">难度:<a class="td-heading-self-link" href="#%e9%9a%be%e5%ba%a6" aria-label="Heading self-link"></a></h4>
<p>中等</p>
<h4 id="分析">分析:<a class="td-heading-self-link" href="#%e5%88%86%e6%9e%90" aria-label="Heading self-link"></a></h4>
<ul>
<li>定义边界法：
<ul>
<li>使用四个变量记录当前要填充区域的边界：left、right、top、bottom</li>
<li>初始时 left=0、right=n-1、top=0、bottom=n-1</li>
<li>每填充完一条边，相应的边界就向内收缩一格</li>
</ul>
</li>
<li>填充规则：
<ul>
<li>从左到右填充上边界：固定行(top)，列从 left 到 right</li>
<li>从上到下填充右边界：固定列(right)，行从 top 到 bottom</li>
<li>从右到左填充下边界：固定行(bottom)，列从 right 到 left</li>
<li>从下到上填充左边界：固定列(left)，行从 bottom 到 top</li>
</ul>
</li>
<li>循环终止条件：
<ul>
<li>当填入的数字达到 n² 时停止</li>
<li>或者当四个边界相互交错时停止</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">class</span> <span style="color:#e5c890">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">int</span><span style="color:#99d1db;font-weight:bold">[][]</span> <span style="color:#8caaee">generateMatrix</span>(<span style="color:#e78284">int</span> n) {
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 正确初始化二维数组</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">int</span><span style="color:#99d1db;font-weight:bold">[][]</span> matrix <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> <span style="color:#e78284">int</span><span style="color:#99d1db;font-weight:bold">[</span>n<span style="color:#99d1db;font-weight:bold">][</span>n<span style="color:#99d1db;font-weight:bold">]</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 定义四个边界</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">int</span> left <span style="color:#99d1db;font-weight:bold">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">int</span> right <span style="color:#99d1db;font-weight:bold">=</span> n <span style="color:#99d1db;font-weight:bold">-</span> 1;
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">int</span> top <span style="color:#99d1db;font-weight:bold">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">int</span> bottom <span style="color:#99d1db;font-weight:bold">=</span> n <span style="color:#99d1db;font-weight:bold">-</span> 1;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 数字从1开始填充</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">int</span> num <span style="color:#99d1db;font-weight:bold">=</span> 1;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">while</span> (num <span style="color:#99d1db;font-weight:bold">&lt;=</span> n <span style="color:#99d1db;font-weight:bold">*</span> n) {
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">// 从左到右填充上边界</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> left; i <span style="color:#99d1db;font-weight:bold">&lt;=</span> right; i<span style="color:#99d1db;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>                matrix<span style="color:#99d1db;font-weight:bold">[</span>top<span style="color:#99d1db;font-weight:bold">][</span>i<span style="color:#99d1db;font-weight:bold">]</span> <span style="color:#99d1db;font-weight:bold">=</span> num<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            top<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">// 从上到下填充右边界</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> top; i <span style="color:#99d1db;font-weight:bold">&lt;=</span> bottom; i<span style="color:#99d1db;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>                matrix<span style="color:#99d1db;font-weight:bold">[</span>i<span style="color:#99d1db;font-weight:bold">][</span>right<span style="color:#99d1db;font-weight:bold">]</span> <span style="color:#99d1db;font-weight:bold">=</span> num<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            right<span style="color:#99d1db;font-weight:bold">--</span>;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">// 从右到左填充下边界</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> right; i <span style="color:#99d1db;font-weight:bold">&gt;=</span> left; i<span style="color:#99d1db;font-weight:bold">--</span>) {
</span></span><span style="display:flex;"><span>                matrix<span style="color:#99d1db;font-weight:bold">[</span>bottom<span style="color:#99d1db;font-weight:bold">][</span>i<span style="color:#99d1db;font-weight:bold">]</span> <span style="color:#99d1db;font-weight:bold">=</span> num<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            bottom<span style="color:#99d1db;font-weight:bold">--</span>;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">// 从下到上填充左边界</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> bottom; i <span style="color:#99d1db;font-weight:bold">&gt;=</span> top; i<span style="color:#99d1db;font-weight:bold">--</span>) {
</span></span><span style="display:flex;"><span>                matrix<span style="color:#99d1db;font-weight:bold">[</span>i<span style="color:#99d1db;font-weight:bold">][</span>left<span style="color:#99d1db;font-weight:bold">]</span> <span style="color:#99d1db;font-weight:bold">=</span> num<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            left<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> matrix;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>



    
	
  



          </main>
        </div>
      </div>
      <footer class="td-footer row d-print-none">
  <div class="container-fluid">
    <div class="row mx-md-2">
      <div class="td-footer__left col-6 col-sm-4 order-sm-1">
        <ul class="td-footer__links-list">
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="User mailing list" aria-label="User mailing list">
    <a target="_blank" rel="noopener" href="https://example.org/mail" aria-label="User mailing list">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="Twitter" aria-label="Twitter">
    <a target="_blank" rel="noopener" href="https://example.org/twitter" aria-label="Twitter">
      <i class="fab fa-twitter"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="Stack Overflow" aria-label="Stack Overflow">
    <a target="_blank" rel="noopener" href="https://example.org/stack" aria-label="Stack Overflow">
      <i class="fab fa-stack-overflow"></i>
    </a>
  </li>
  
</ul>

      </div><div class="td-footer__right col-6 col-sm-4 order-sm-3">
        <ul class="td-footer__links-list">
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="GitHub" aria-label="GitHub">
    <a target="_blank" rel="noopener" href="https://github.com/google/docsy" aria-label="GitHub">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="Slack" aria-label="Slack">
    <a target="_blank" rel="noopener" href="https://example.org/slack" aria-label="Slack">
      <i class="fab fa-slack"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="Developer mailing list" aria-label="Developer mailing list">
    <a target="_blank" rel="noopener" href="https://example.org/mail" aria-label="Developer mailing list">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
</ul>

      </div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2">
        <span class="td-footer__copyright">&copy;
    2025&ndash;2025
    <span class="td-footer__authors">海阔知识库 | <a href="https://creativecommons.org/licenses/by/4.0">CC BY 4.0</a> |</span></span><span class="td-footer__all_rights_reserved">All Rights Reserved</span><span class="ms-2"><a href="https://policies.google.com/privacy" target="_blank" rel="noopener">Privacy Policy</a></span>
      </div>
    </div>
  </div>
</footer>

    </div>
    <script src="/js/main.js"></script>
<script defer src="/js/click-to-copy.js" crossorigin="anonymous"></script>
<script src='/js/tabpane-persist.js'></script>

  </body>
</html>
