<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>操作系统 on 海阔集</title>
    <link>http://localhost:1313/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
    <description>Recent content in 操作系统 on 海阔集</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="http://localhost:1313/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CPU Cache 高速缓存</title>
      <link>http://localhost:1313/docs/general/os/cpu%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/general/os/cpu%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/</guid>
      <description>&lt;p&gt;&lt;strong&gt;CPU 缓存是为了解决 CPU 处理速度和内存处理速度不对等的问题。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205094918596.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;CPU Cache 的工作方式：&lt;/strong&gt; 先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 &lt;strong&gt;内存缓存不一致性的问题&lt;/strong&gt; ！比如我执行一个 i++ 操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 i++ 运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。&lt;/p&gt;&#xA;&lt;p&gt;操作系统屏蔽了底层硬件的操作细节，将各种硬件资源虚拟化。于是，操作系统也就同样需要解决内存缓存不一致性问题。&lt;/p&gt;&#xA;&lt;p&gt;操作系统通过 &lt;strong&gt;内存模型（Memory Model）&lt;/strong&gt; 定义一系列规范来解决这个问题。无论是 Windows 系统，还是 Linux 系统，它们都有特定的内存模型。&lt;/p&gt;</description>
    </item>
    <item>
      <title>存储器的层次结构</title>
      <link>http://localhost:1313/docs/general/os/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/general/os/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</guid>
      <description>&lt;p&gt;在计算机执行时，几乎每一条指令都涉及对存储器的访问，存储器的速度必须非常快，能与处理机的速度相匹配，否则会明显地影响到处理机的运行。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205094702438.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;存储层次至少应具有三级：&lt;/p&gt;&#xA;&lt;p&gt;最高层为CPU寄存器，中间为主存，最底层是辅存。&lt;/p&gt;&#xA;&lt;p&gt;其中寄存器和主存也被称为 &lt;em&gt;可执行存储器&lt;/em&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;可执行存储器&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;是通过访问方式区分的&lt;/p&gt;&#xA;&lt;p&gt;可执行存储器 使用一条load或store指令对可执行存储器进行访问。&lt;/p&gt;&#xA;&lt;p&gt;对辅存的访问则需要通过I/O设备实现。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;主存储器&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;主存储器 主存储器简称内存或主存，&lt;/p&gt;&#xA;&lt;p&gt;是计算机系统中的主要部件，&lt;/p&gt;&#xA;&lt;p&gt;用于保存进程运行时的程序和数据，也称可执行存储器&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;寄存器&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;寄存器具有与处理机相同的速度，&lt;/p&gt;&#xA;&lt;p&gt;故对寄存器的访问速度最快，完全能与CPU协调工作，&lt;/p&gt;&#xA;&lt;p&gt;但价格却十分昂贵，因此容量不可能做得很大。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;[&lt;em&gt;高速缓存&lt;/em&gt;](CPU Cache 高速缓存)&lt;/p&gt;&#xA;&lt;p&gt;高速缓存是介于寄存器和存储器之间的存储器，&lt;/p&gt;&#xA;&lt;p&gt;主要用于备份主存中较常用的数据，&lt;/p&gt;&#xA;&lt;p&gt;以减少处理机对主存储器的访问次数，&lt;/p&gt;&#xA;&lt;p&gt;这样可大幅度地提高程序执行速度。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;磁盘缓存&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;目前磁盘的I/O速度远低于对主存的访问速度，&lt;/p&gt;&#xA;&lt;p&gt;为了缓和两者之间在速度上的不匹配，而设置了磁盘缓存，主要用于暂时存放频繁使用的一部分磁盘数据和信息，&#xA;以减少访问磁盘的次数。&lt;/p&gt;&lt;/blockquote&gt;</description>
    </item>
    <item>
      <title>操作系统基本特性</title>
      <link>http://localhost:1313/docs/general/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/general/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/</guid>
      <description>&lt;h4 id=&#34;并发&#34;&gt;并发&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%b9%b6%e5%8f%91&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;OS能够提高系统资源利用率的原因&lt;/p&gt;&#xA;&lt;p&gt;并发是指&lt;strong&gt;多个任务在同一时间段内被处理&lt;/strong&gt;，但并不意味着它们必须是&lt;strong&gt;同时&lt;/strong&gt;发生的。实际上，处理器可能会在同一时刻只能处理一个任务，但操作系统通过切换任务的方式让多个任务在短时间间隔内“交替”执行。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;并发的关键特点&lt;/strong&gt;是：在同一时间段内，多个任务会被交替执行，这种交替执行给人感觉是同时进行的。操作系统调度器负责任务切换。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;共享&#34;&gt;&lt;strong&gt;共享&lt;/strong&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%85%b1%e4%ba%ab&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;在操作系统中，共享资源需要控制不同进程或线程的访问，常见的控制方式有 &lt;strong&gt;互斥&lt;/strong&gt; 和 &lt;strong&gt;同时&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;共享资源&lt;/strong&gt;是指多个进程或线程可以访问同一块内存或设备资源。例如，多个进程同时访问打印机、磁带机等共享设备。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;操作系统中的共享&lt;/strong&gt;通常是通过 &lt;strong&gt;锁机制&lt;/strong&gt;（如互斥锁、读写锁等）来避免资源竞争问题，确保资源访问的有序性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;1-互斥&#34;&gt;1. 互斥&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#1-%e4%ba%92%e6%96%a5&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h5&gt;&#xD;&#xA;&lt;p&gt;互斥是指在&lt;strong&gt;某一时间&lt;/strong&gt;，只能允许&lt;strong&gt;一个进程或线程&lt;/strong&gt;访问共享资源，防止并发执行时的资源冲突。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例如，打印机是共享资源，但同一时刻只能由一个进程打印，其他进程需等待。&lt;/li&gt;&#xA;&lt;li&gt;操作系统通过 &lt;strong&gt;互斥锁（Mutex）&lt;/strong&gt; 来保证同一时间内只有一个进程（或线程）能访问资源。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;2-同时&#34;&gt;2. 同时&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#2-%e5%90%8c%e6%97%b6&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h5&gt;&#xD;&#xA;&lt;p&gt;同时是指多个进程或线程&lt;strong&gt;在时间上交替执行&lt;/strong&gt;共享资源的访问请求，而非在同一时刻访问。&#xA;例如，某个设备在微观上并不是完全同时被多个进程访问，而是交替执行。&lt;/p&gt;&#xA;&lt;h4 id=&#34;虚拟&#34;&gt;&lt;strong&gt;虚拟&lt;/strong&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e8%99%9a%e6%8b%9f&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;操作系统通过软件技术为应用程序和用户提供的一种抽象和隔离机制，使得多个程序可以在相同的硬件资源上独立运行，并且每个程序认为它独占系统资源，实际上是操作系统通过合理调度和资源分配来共享这些资源。&lt;/p&gt;&#xA;&lt;h5 id=&#34;时分复用time-division-multiplexing-tdm&#34;&gt;时分复用（Time Division Multiplexing, TDM）&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e6%97%b6%e5%88%86%e5%a4%8d%e7%94%a8time-division-multiplexing-tdm&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h5&gt;&#xD;&#xA;&lt;p&gt;时分复用是指&lt;strong&gt;通过时间片轮转的方式&lt;/strong&gt;将处理器时间分配给多个用户或任务。每个用户在指定的时间段内占用资源，其他用户则需等待空闲时间。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;例子&lt;/strong&gt;：操作系统通过时间片轮转的方式将 CPU 时间分配给各个进程，保证每个进程都有机会执行。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;空分复用frequency-division-multiplexing-fdm&#34;&gt;空分复用（Frequency Division Multiplexing, FDM）&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%a9%ba%e5%88%86%e5%a4%8d%e7%94%a8frequency-division-multiplexing-fdm&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h5&gt;&#xD;&#xA;&lt;p&gt;空分复用通过将&lt;strong&gt;频带划分成多个较小的频带&lt;/strong&gt;来为不同的通信用户提供服务，每个用户在一个独立的频带内通信。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;例子&lt;/strong&gt;：在无线通信中，多个通信设备通过不同的频率带宽进行通讯。每个设备占用一个特定频段。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;异步&#34;&gt;异步&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%bc%82%e6%ad%a5&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在多道程序并发的环境下，每个程序何时执行、何时暂停 都是未知的，即他们以不可预知的速度向前推进，&lt;/p&gt;&#xA;&lt;p&gt;操作系统 应当保证程序执行结果的可再现性。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;执行顺序&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h5 id=&#34;同步&#34;&gt;同步&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%90%8c%e6%ad%a5&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h5&gt;&#xD;&#xA;&lt;p&gt;同步是指任务的执行是&lt;strong&gt;按顺序进行&lt;/strong&gt;的，一个任务完成后，另一个任务才能开始执行。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;例子&lt;/strong&gt;：多个进程依次在 CPU 上执行，前一个任务完成后，后一个任务才能开始。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;异步-1&#34;&gt;异步&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%bc%82%e6%ad%a5-1&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h5&gt;&#xD;&#xA;&lt;p&gt;异步是指任务的执行&lt;strong&gt;不必按顺序进行&lt;/strong&gt;，多个任务可以并行执行，任务之间的执行顺序不受限制。每个任务执行时不会阻塞其他任务的执行。&lt;/p&gt;</description>
    </item>
    <item>
      <title>线程</title>
      <link>http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</guid>
      <description>&lt;p&gt;进程&#xA;说简单点就是我们在电脑上启动的一个个应用。它是操作系统分配资源的最小单位。&lt;/p&gt;&#xA;&lt;p&gt;线程&#xA;是进程的子任务，是 CPU 调度和分派的基本单位，实现了进程内部的并发。&lt;/p&gt;&#xA;&lt;h4 id=&#34;线程与进程&#34;&gt;线程与进程&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e4%b8%8e%e8%bf%9b%e7%a8%8b&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;线程，是进程的子任务，是进程中的独立执行单元。多个线程可以共享同一个进程的资源，如内存；每个线程都有自己独立的栈和寄存器。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205083709918.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;并发环境下, 多线程存在下述问题&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;线程之间如何确保执行顺序,实现线程之间的协调与合作? 线程通信&lt;/li&gt;&#xA;&lt;li&gt;线程之间如何确保对临界资源修改不会冲突? 线程同步?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;线程通信线程通信md&#34;&gt;&lt;a href=&#34;http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/&#34;&gt;线程通信&lt;/a&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e9%80%9a%e4%bf%a1%e7%ba%bf%e7%a8%8b%e9%80%9a%e4%bf%a1md&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;Inter-thread communication in Java is a mechanism in which a thread is paused running in its critical section and another thread is allowed to enter (or lock) in the same critical section to be executed.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;线程间通信&lt;/strong&gt;&#xA;是一种机制，使得线程能够在执行时进行协作，通常用于解决某些线程需要等待其他线程完成任务的情况。它主要涉及线程之间的等待和通知机制，而不是同一临界区内的互斥访问。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;线程同步&#34;&gt;线程同步&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e5%90%8c%e6%ad%a5&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;Synchronization&lt;/strong&gt; is crucial for ensuring that multiple threads operate safely on shared resources. Without *&lt;strong&gt;Synchronization&lt;/strong&gt;, data inconsistency or corruption can occur when multiple threads try to access and modify shared variables simultaneously. In Java, it is a mechanism that ensures that only one thread can access a resource at any given time&lt;/p&gt;</description>
    </item>
    <item>
      <title>线程生命周期</title>
      <link>http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>&lt;p&gt;Java的线程分为两类, 用户线程和守护线程&lt;/p&gt;&#xA;&lt;p&gt;线程调度就是线程不同状态间的转换&lt;/p&gt;&#xA;&lt;p&gt;在&lt;a href=&#34;%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2.md&#34;&gt;操作系统&lt;/a&gt;中，线程被视为轻量级的进程，所以&lt;strong&gt;线程状态其实和进程状态是一致的&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205105116917.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Java线程有如下状态&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;// Thread.State 源码&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;enum&lt;/span&gt; State {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    NEW,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    RUNNABLE,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    BLOCKED,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    WAITING,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    TIMED_WAITING,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    TERMINATED;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;new&#34;&gt;NEW&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#new&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;处于 NEW 状态的线程是刚创建 &lt;code&gt;Thread&lt;/code&gt; 而尚未启动。这里的尚未启动指的是还没调用 Thread 实例的&lt;code&gt;start()&lt;/code&gt;方法。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;testStateNew&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Thread thread &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; Thread(() &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt; {});&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    System.&lt;span style=&#34;color:#8caaee&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#8caaee&#34;&gt;println&lt;/span&gt;(thread.&lt;span style=&#34;color:#8caaee&#34;&gt;getState&lt;/span&gt;()); &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;// 输出 NEW&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;runnable&#34;&gt;RUNNABLE&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#runnable&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;当前线程正在运行中。处于 RUNNABLE 状态的线程在 Java 虚拟机中运行，也有可能在等待 CPU 分配非IO资源。&lt;/p&gt;&#xA;&lt;p&gt;Java 线程的&lt;strong&gt;RUNNABLE&lt;/strong&gt;状态其实包括了操作系统线程的&lt;strong&gt;ready&lt;/strong&gt;和&lt;strong&gt;running&lt;/strong&gt;两个状态。&lt;/p&gt;&#xA;&lt;h4 id=&#34;block&#34;&gt;BLOCK&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#block&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;阻塞状态。处于 BLOCKED 状态的线程正等待锁（锁会在后面细讲）的释放以进入同步区。&lt;/p&gt;&#xA;&lt;h4 id=&#34;waiting&#34;&gt;WAITING&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#waiting&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;等待状态。处于等待状态的线程变成 RUNNABLE 状态需要其他线程唤醒。&lt;/p&gt;</description>
    </item>
    <item>
      <title>进程同步</title>
      <link>http://localhost:1313/docs/general/os/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/general/os/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;临界资源&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;一次只允许一个进程使用，多个进程同时使用就会造成系统混乱的资源&lt;/p&gt;&#xA;&lt;p&gt;诸进程间应采取互斥方式，实现对这种资源的共享。&lt;/p&gt;&#xA;&lt;p&gt;源如打印机、 磁带机、共享变量等&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;临界区&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;无论是硬件临界资源&lt;/p&gt;&#xA;&lt;p&gt;还是软件临界资源&lt;/p&gt;&#xA;&lt;p&gt;多个进程必须互斥的对它进行访问&lt;/p&gt;&#xA;&lt;p&gt;在每个进程中访问临界资源的这段&lt;strong&gt;代码&lt;/strong&gt;称之为临界区&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/image-20250109233136840.png&#34; alt=&#34;image-20250109233136840&#34;&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;临界区的作用&#34;&gt;临界区的作用&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%b8%b4%e7%95%8c%e5%8c%ba%e7%9a%84%e4%bd%9c%e7%94%a8&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;保护共享资源&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;通过互斥访问机制，任意时刻只有一个线程修改和访问共享数据&lt;/p&gt;&#xA;&lt;p&gt;从而保护资源一致性，完整性&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;防止竞态条件&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;多个线程同时访问共享资源时&lt;/p&gt;&#xA;&lt;p&gt;由于执行顺序的不确定导致结果不可预测&lt;/p&gt;&#xA;&lt;p&gt;临界区通过确保同一时间只有一个线程运行，避免竞态发生&lt;/p&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;提高程序稳定性&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;如果不能采取有效的措施，对多个进程的运行进行妥善的管理，&lt;/p&gt;&#xA;&lt;p&gt;必然会因为这些进程对系统资源的无序争夺给系统造成混乱。&lt;/p&gt;&#xA;&lt;p&gt;致使每次处理的结果存在着不确定性，即显现出其不可再现性。&lt;/p&gt;&#xA;&lt;p&gt;有多个进程需要同时修改某一数据，系统必须控制，&#xA;一次仅允许一个进程完成读数据，并修改数据两件事以后，才允许别的进程对同一数据的读和修改操作。&lt;/p&gt;</description>
    </item>
    <item>
      <title>进程的状态与转换</title>
      <link>http://localhost:1313/docs/general/os/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/general/os/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2/</guid>
      <description>&lt;h3 id=&#34;进程的状态与转换&#34;&gt;进程的状态与转换&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%8a%b6%e6%80%81%e4%b8%8e%e8%bd%ac%e6%8d%a2&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&#xD;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;多个进程在并发执行时共享系统资源，&lt;/p&gt;&#xA;&lt;p&gt;致使它们在 运行过程中呈现间断性的运行规律，&lt;/p&gt;&#xA;&lt;p&gt;所以进程在其生命周期内可能具有多种状态。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;基本状态&#34;&gt;基本状态&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e7%8a%b6%e6%80%81&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;就绪(Ready)状态&lt;/p&gt;&#xA;&lt;p&gt;执行(Running)状态&lt;/p&gt;&#xA;&lt;p&gt;阻塞(Block)状态&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205105205700.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;创建与终止状态&#34;&gt;创建与终止状态&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%88%9b%e5%bb%ba%e4%b8%8e%e7%bb%88%e6%ad%a2%e7%8a%b6%e6%80%81&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;创建状态&lt;/p&gt;&#xA;&lt;p&gt;进程正在被创建&lt;/p&gt;&#xA;&lt;p&gt;创建工作尚未完成，进程不能被调度运行&lt;/p&gt;&#xA;&lt;p&gt;终止状态&lt;/p&gt;&#xA;&lt;p&gt;进程从系统消失&lt;/p&gt;&#xA;&lt;p&gt;两个步骤：&lt;/p&gt;&#xA;&lt;p&gt;首先，是等待操作系统 进行善后处理，&lt;/p&gt;&#xA;&lt;p&gt;最后将其PCB清零，并将PCB空间返还系统。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/image-20250109201649501.png&#34; alt=&#34;image-20250109201649501&#34;&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;这里注意。就绪到运行获得处理机前需要获得其他所有资源&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Exam.&lt;/p&gt;&#xA;&lt;p&gt;进程描述中正确的&lt;/p&gt;&#xA;&lt;p&gt;A. 进程获得CPU是通过调度得到的&lt;/p&gt;&#xA;&lt;p&gt;B. 进程申请CPU未获满足时，其状态变为阻塞&lt;/p&gt;&#xA;&lt;p&gt;B 进程申请CPU未获满足仍为就绪，只有申请IO或资源失败才是阻塞&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/%7BCB7FEC31-EF3E-43F6-BE77-B17715A69A8F%7D.png&#34; alt=&#34;{CB7FEC31-EF3E-43F6-BE77-B17715A69A8F}&#34;&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
