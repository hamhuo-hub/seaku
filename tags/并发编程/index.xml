<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>并发编程 on 海阔集</title>
    <link>http://localhost:1313/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in 并发编程 on 海阔集</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="http://localhost:1313/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java基础能力</title>
      <link>http://localhost:1313/docs/basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/basic/</guid>
      <description>&lt;p&gt;内容来源:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;沉默王二 GitHub 上开源的知识库《&lt;a href=&#34;https://github.com/itwanger/toBeBetterJavaer&#34;&gt;Java 进阶之路&lt;/a&gt;》&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.rabbitmq.com/tutorials&#34;&gt;rabbitMQ&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>AQS</title>
      <link>http://localhost:1313/docs/basic/concurrent/aqs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/basic/concurrent/aqs/</guid>
      <description>&lt;p&gt;&lt;strong&gt;AQS&lt;/strong&gt;是&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;的简称，即&lt;code&gt;抽象的队列同步器&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;抽象：抽象类，只实现一些主要逻辑，有些方法由子类实现；&lt;/li&gt;&#xA;&lt;li&gt;队列：使用先进先出（FIFO）的队列存储数据；&lt;/li&gt;&#xA;&lt;li&gt;同步：实现了同步的功能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;为什么需要-aqs&#34;&gt;为什么需要 &lt;code&gt;AQS&lt;/code&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81-aqs&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的同步器&#xA;简单的说,  存储并管理线程同步的模板&lt;/p&gt;&#xA;&lt;p&gt;具体的同步器（如 &lt;code&gt;ReentrantLock&lt;/code&gt;、&lt;code&gt;CountDownLatch&lt;/code&gt;、&lt;code&gt;Semaphore&lt;/code&gt;, &lt;a href=&#34;http://localhost:1313/docs/basic/concurrent/%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C/&#34;&gt;FutureTask&lt;/a&gt;等）是通过继承 &lt;code&gt;AQS&lt;/code&gt; 并实现一些抽象方法来实现资源的具体获取和释放行为的。&lt;/p&gt;&#xA;&lt;h4 id=&#34;aqs的作用是什么&#34;&gt;&lt;code&gt;AQS&lt;/code&gt;的作用是什么?&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#aqs%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;了解&#xA;&lt;a href=&#34;http://localhost:1313/docs/basic/concurrent/%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8Eclh%E9%94%81/&#34;&gt;自旋锁与CLH锁&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;AQS&lt;/code&gt; 是一个 &lt;strong&gt;抽象类&lt;/strong&gt;，它为具体的同步器提供了一个通用的执行框架。&#xA;它定义了如何获取和释放共享资源的基本流程，但并没有实现具体的逻辑。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;AQS&lt;/code&gt; 提供了同步器所需要的 &lt;strong&gt;框架和基础设施&lt;/strong&gt;，比如：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如何在多个线程间协调资源的竞争。&lt;/li&gt;&#xA;&lt;li&gt;如何管理线程的队列（阻塞队列）以等待资源。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;其中AQS 的核心数据结构是基于&lt;a href=&#34;http://localhost:1313/docs/basic/concurrent/%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8Eclh%E9%94%81/&#34;&gt;CLH 锁&lt;/a&gt;改进的, 详情下述&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;线程的挂起与唤醒等机制。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;aqs的数据结构&#34;&gt;AQS的数据结构&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#aqs%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;既然是控制线程, 那么数据结构应对并发相应的优化&#xA;AQS的核心数据结构是基于 CLH队列锁改进的&#xA;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/Pasted%20image%2020250203211340.png&#34; alt=&#34;Pasted image 20250203211340.png&#34;&gt;&#xA;CLH队列锁有如下缺点&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;仍然基于自旋, 长时间自旋下CPU占用高&lt;/li&gt;&#xA;&lt;li&gt;功能单一, 不能挂起, 不能共享读, 只支持独占等&#xA;针对以上缺点, AQS进行改造&lt;/li&gt;&#xA;&lt;li&gt;AQS 将自旋操作改为阻塞线程操作。&lt;/li&gt;&#xA;&lt;li&gt;AQS 对 CLH 锁进行改造和扩展, 扩展每个节点的状态、显式的维护前驱节点和后继节点&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;AQS 内部使用了一个&lt;a href=&#34;http://localhost:1313/docs/basic/concurrent/volatile%E5%85%B3%E9%94%AE%E5%AD%97/&#34;&gt;volatile关键字&lt;/a&gt; 的变量 &lt;code&gt;state&lt;/code&gt; 来作为线程的状态标识。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; waitStatus;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该变量有如下状态, AQS提供原子读写&#xA;![[content/en/docs/Basic/Concurrent/Pasted image 20250203210552.png]]&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java并发编程</title>
      <link>http://localhost:1313/docs/basic/concurrent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/basic/concurrent/</guid>
      <description>&lt;p&gt;内容来源:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;沉默王二 GitHub 上开源的知识库《&lt;a href=&#34;https://github.com/itwanger/toBeBetterJavaer&#34;&gt;Java 进阶之路&lt;/a&gt;》&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://javaguide.cn/java/concurrent/&#34;&gt;JavaGuide&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg&#34;&gt;CLH锁 - Quner技术沙龙&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;操作系统 - 西电出版&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>JMM内存模型</title>
      <link>http://localhost:1313/docs/basic/concurrent/jmm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/basic/concurrent/jmm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;p&gt;Java 内存模型（Java Memory Model，JMM）定义了 Java 程序中的变量、线程如何和主存以及工作内存进行交互的规则, 可以理解为并发编程相关的一组规范&lt;/p&gt;&#xA;&lt;p&gt;JMM在Java中主要解决&lt;a href=&#34;http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/&#34;&gt;线程同步与通信&lt;/a&gt;问题, 涉及到内存可见性, 指令重排等问题&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Java 是最早尝试提供内存模型的编程语言。由于早期内存模型存在一些缺陷（比如非常容易削弱编译器的优化能力），从 Java5 开始，Java 开始使用新的内存模型&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;一般来说，编程语言也可以直接复用操作系统层面的内存模型。不过，不同的操作系统内存模型不同。如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了。&#xA;Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205095605661.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;红色区域称主内存, 是线程存放共享变量的区域&lt;/p&gt;&#xA;&lt;p&gt;白色为本地内存&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;主内存&lt;/strong&gt;：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量，还是局部变量，类信息、常量、静态变量都是放在主内存中。为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;本地内存&lt;/strong&gt;：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的副本。每个线程只能操作自己本地内存中的变量，无法直接访问其他线程的本地内存。如果线程间需要通信，必须通过主内存来进行。本地内存是 JMM 抽象出来的一个概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;内存可见性问题&#34;&gt;内存可见性问题&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%86%85%e5%ad%98%e5%8f%af%e8%a7%81%e6%80%a7%e9%97%ae%e9%a2%98&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;和 &lt;a href=&#34;CPU%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.md&#34;&gt;CPU cache&lt;/a&gt; 类似, 当多个线程同时读写共享变量时, 线程不存在同步机制会导致变量被覆写, 导致结果不可预见&#xA;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205100230451.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;如何解决内存可见性问题?&lt;/p&gt;&#xA;&lt;p&gt;关于主内存与工作内存直接的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义来以下八种同步操作&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205100905174.png&#34; alt=&#34;image.png&#34;&gt;&#xA;初次之外还规定了很多同步规则,这不重要&lt;/p&gt;&#xA;&lt;h4 id=&#34;指令重排序问题&#34;&gt;指令重排序问题&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e6%8c%87%e4%bb%a4%e9%87%8d%e6%8e%92%e5%ba%8f%e9%97%ae%e9%a2%98&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;什么是指令重排序？&lt;/strong&gt; 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。&lt;strong&gt;指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致&lt;/strong&gt; ，所以在多线程下，指令重排序可能会导致一些问题。&lt;/p&gt;&#xA;&lt;h4 id=&#34;happen-before-原则&#34;&gt;happen-before 原则&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#happen-before-%e5%8e%9f%e5%88%99&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;happens-before 这个概念最早诞生于 Leslie Lamport 于 1978 年发表的论文&lt;a href=&#34;https://lamport.azurewebsites.net/pubs/time-clocks.pdf&#34;&gt;《Time，Clocks and the Ordering of Events in a Distributed System》&lt;/a&gt;。在这篇论文中，Leslie Lamport 提出了逻辑时钟的概念，这也成了第一个逻辑时钟算法 。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ReentrantLock重入锁</title>
      <link>http://localhost:1313/docs/basic/concurrent/reentrantlock%E9%87%8D%E5%85%A5%E9%94%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/basic/concurrent/reentrantlock%E9%87%8D%E5%85%A5%E9%94%81/</guid>
      <description>&lt;h4 id=&#34;重入性&#34;&gt;重入性&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e9%87%8d%e5%85%a5%e6%80%a7&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;重入性指当线程需要再次获取同一把锁时, 不会因为自身而造成死锁, 锁的本质是&lt;strong&gt;作用于代码块或方法&lt;/strong&gt;，而不是线程的整个执行上下文。即使线程已经持有锁，进入新的同步方法或代码块时，仍然需要执行&lt;strong&gt;获取锁&lt;/strong&gt;的操作，确保锁的计数正确。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250209113038176.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;所以支持重入性应该解决下列问题&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由于获得多次相同的锁, 需要计数以释放相同次数&lt;/li&gt;&#xA;&lt;li&gt;相同线程再次获取锁应当直接成功, 防止死锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;为什么需要reentrantlock&#34;&gt;为什么需要&lt;code&gt;ReentrantLock&lt;/code&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81reentrantlock&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Java语言直接提供了&lt;code&gt;synchronized&lt;/code&gt;关键字用于加锁，但这种锁一是很重，二是获取时必须一直等待，没有额外的尝试机制。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;if&lt;/span&gt; (lock.&lt;span style=&#34;color:#8caaee&#34;&gt;tryLock&lt;/span&gt;(1, TimeUnit.&lt;span style=&#34;color:#8caaee&#34;&gt;SECONDS&lt;/span&gt;)) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ca9ee6&#34;&gt;try&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#ca9ee6&#34;&gt;finally&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        lock.&lt;span style=&#34;color:#8caaee&#34;&gt;unlock&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;java.util.concurrent.locks&lt;/code&gt;包提供的&lt;code&gt;ReentrantLock&lt;/code&gt;用于替代&lt;code&gt;synchronized&lt;/code&gt;加锁&lt;/p&gt;&#xA;&lt;p&gt;尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，&lt;code&gt;tryLock()&lt;/code&gt;返回&lt;code&gt;false&lt;/code&gt;，程序就可以做一些额外处理，而不是无限等待下去。&lt;/p&gt;&#xA;&lt;p&gt;所以，使用&lt;code&gt;ReentrantLock&lt;/code&gt;比直接使用&lt;code&gt;synchronized&lt;/code&gt;更安全，线程在&lt;code&gt;tryLock()&lt;/code&gt;失败的时候不会导致死锁。&lt;/p&gt;&#xA;&lt;h1 id=&#34;reentrantlock使用&#34;&gt;ReentrantLock使用&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#reentrantlock%e4%bd%bf%e7%94%a8&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#e5c890&#34;&gt;Counter&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//和关键字不同, 需要获得一个重入锁对象&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;final&lt;/span&gt; Lock lock &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; ReentrantLock();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; count;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; n) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//代码块加锁&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        lock.&lt;span style=&#34;color:#8caaee&#34;&gt;lock&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ca9ee6&#34;&gt;try&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            count &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;+=&lt;/span&gt; n;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#ca9ee6&#34;&gt;finally&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;        &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//在finally中解锁&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            lock.&lt;span style=&#34;color:#8caaee&#34;&gt;unlock&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>synchronized关键字</title>
      <link>http://localhost:1313/docs/basic/concurrent/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/basic/concurrent/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;在 Java 中，关键字 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)&#xA;synchronized 的另外一个重要的作用，synchronized 可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;synchronized 关键字最主要有以下 3 种应用方式：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同步方法，为当前对象加锁，进入同步代码前要获得当前对象的锁；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#e5c890&#34;&gt;AccountingSync&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;implements&lt;/span&gt; Runnable {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//共享资源(临界资源)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;// synchronized 同步方法&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;increase&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        i &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8caaee;font-weight:bold&#34;&gt;@Override&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;run&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ca9ee6&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; j&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;0;j&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;1000000;j&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;++&lt;/span&gt;){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            increase();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;main&lt;/span&gt;(String args&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;[]&lt;/span&gt;) &lt;span style=&#34;color:#e78284&#34;&gt;throws&lt;/span&gt; InterruptedException {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        AccountingSync instance &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; AccountingSync();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Thread t1 &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; Thread(instance);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Thread t2 &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; Thread(instance);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t1.&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t2.&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t1.&lt;span style=&#34;color:#8caaee&#34;&gt;join&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t2.&lt;span style=&#34;color:#8caaee&#34;&gt;join&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#8caaee&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#8caaee&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;static, i output:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;+&lt;/span&gt; i);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;同步静态方法，为当前类加锁，进入同步代码前要获得当前类的锁；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#e5c890&#34;&gt;AccountingSyncClass&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;implements&lt;/span&gt; Runnable {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;     * 同步静态方法,锁是当前class对象，也就是&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;     * AccountingSyncClass类对应的class对象&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;     */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;increase&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        i&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;// 非静态,访问时锁不一样不会发生互斥&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;increase4Obj&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        i&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8caaee;font-weight:bold&#34;&gt;@Override&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;run&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ca9ee6&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; j&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;0;j&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;1000000;j&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;++&lt;/span&gt;){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            increase();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;[]&lt;/span&gt; args) &lt;span style=&#34;color:#e78284&#34;&gt;throws&lt;/span&gt; InterruptedException {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//new新实例&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Thread t1&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; Thread(&lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; AccountingSyncClass());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//new新实例&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Thread t2&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; Thread(&lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; AccountingSyncClass());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//启动线程&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t1.&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();t2.&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t1.&lt;span style=&#34;color:#8caaee&#34;&gt;join&lt;/span&gt;();t2.&lt;span style=&#34;color:#8caaee&#34;&gt;join&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#8caaee&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#8caaee&#34;&gt;println&lt;/span&gt;(i);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt; * 输出结果:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt; * 2000000&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt; */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;同步代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#e5c890&#34;&gt;AccountingSync2&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;implements&lt;/span&gt; Runnable {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; AccountingSync2 instance &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; AccountingSync2(); &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;// 饿汉单例模式&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8caaee;font-weight:bold&#34;&gt;@Override&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;run&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//省略其他耗时操作....&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//使用同步代码块对变量i进行同步操作,锁对象为instance&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e78284&#34;&gt;synchronized&lt;/span&gt;(instance){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ca9ee6&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; j&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;0;j&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;1000000;j&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;++&lt;/span&gt;){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                i&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;[]&lt;/span&gt; args) &lt;span style=&#34;color:#e78284&#34;&gt;throws&lt;/span&gt; InterruptedException {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Thread t1&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; Thread(instance);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Thread t2&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; Thread(instance);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t1.&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();t2.&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t1.&lt;span style=&#34;color:#8caaee&#34;&gt;join&lt;/span&gt;();t2.&lt;span style=&#34;color:#8caaee&#34;&gt;join&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#8caaee&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#8caaee&#34;&gt;println&lt;/span&gt;(i);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;这里的锁指的是 Java 内置的隐式锁 monitor 也是 &lt;code&gt;synchronized&lt;/code&gt; 封装好的实现&#xA;每个对象都有一个对象锁，不同的对象，他们的锁不会互相影响。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ThreadLocal</title>
      <link>http://localhost:1313/docs/basic/concurrent/threadlocal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/basic/concurrent/threadlocal/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;前置&#xA;&lt;a href=&#34;http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0/&#34;&gt;线程池&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;是 Java 中提供的一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离，用于解决多线程中共享对象的线程安全问题。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210182243836.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;使用:&lt;/p&gt;&#xA;&lt;p&gt;创建 ThreadLocal对象&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//创建一个ThreadLocal变量&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; ThreadLocal&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; localVariable &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; ThreadLocal&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;设置值&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//设置ThreadLocal变量的值 localVariable.set(&amp;#34;0001&amp;#34;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;获取值&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//获取ThreadLocal变量的值 String value = localVariable.get();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;优点&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;线程隔离&#xA;实现了变量的独占, 使变量不需要同步处理&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数据传递方便&#xA;ThreadLocal 常用于在跨方法、跨类时传递上下文数据（如用户信息等），而不需要在方法间传递参数。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;threadlocalmap&#34;&gt;&lt;code&gt;ThreadLocalMap&lt;/code&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#threadlocalmap&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;ThreadLocalMap, 一个key-value数据形式结构，也是ThreadLocal的核心。&lt;/p&gt;&#xA;&lt;p&gt;Map内部维护了一个Entry数组, 真正的数据存储在 Entry中, map的key是每个线程中ThreadLocal对象的哈希, value是隔离变量&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;&#x9; * 初始容量&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;&#x9; */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; INITIAL_CAPACITY &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; 16;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;&#x9; * ThreadLocalMap数据真正存储在table中&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;&#x9; */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; Entry&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;[]&lt;/span&gt; table;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;&#x9; * ThreadLocalMap条数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;&#x9; */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; size &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;&#x9; * 达到这个大小，则扩容&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;&#x9; */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; threshold; &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;// 默认为0&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210192010058.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>TTL</title>
      <link>http://localhost:1313/docs/advanced/transmittablethreadlocalttl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/advanced/transmittablethreadlocalttl/</guid>
      <description>&lt;p&gt;&lt;code&gt;TransmittableThreadLocal&lt;/code&gt; (TTL) 是增强版的 &lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;前置:&#xA;&lt;a href=&#34;ThreadLocal&#34;&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://localhost:1313/docs/advanced/intercepter%E6%8B%A6%E6%88%AA%E5%99%A8/&#34;&gt;拦截器&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;实现ttl&#34;&gt;实现&lt;code&gt;TTL&lt;/code&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%ae%9e%e7%8e%b0ttl&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;流程图如下&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250216213034195.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;前置:&#xA;&lt;a href=&#34;http://localhost:1313/docs/advanced/%E7%BD%91%E5%85%B3gateway/&#34;&gt;网关Gateway&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;上半部分业务为用户请求登录并返回&lt;code&gt;Token&lt;/code&gt; 该业务从MVC剥离, 设置在网关进行&lt;/p&gt;&#xA;&lt;p&gt;我们主要关注下半部分, 用户携带 &lt;code&gt;Token&lt;/code&gt; 后如何在服务层获取用户信息&lt;/p&gt;&#xA;&lt;p&gt;整体流程为:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;用户登录请求&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户通过提交用户名和密码进行登录，经过网关的认证，认证服务（如 &lt;code&gt;Auth&lt;/code&gt;）验证用户身份并生成 &lt;code&gt;token&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;登录请求返回 &lt;code&gt;token&lt;/code&gt; 给用户，用户保存 &lt;code&gt;token&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;后续请求携带 Token 登录&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户在后续请求中携带该 &lt;code&gt;token&lt;/code&gt;，这个 &lt;code&gt;token&lt;/code&gt; 用于证明用户的身份。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Nginx 负载均衡&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;请求首先被发送到 &lt;code&gt;Nginx&lt;/code&gt;，Nginx 会根据负载均衡策略将请求转发到具体的 &lt;strong&gt;网关&lt;/strong&gt;（&lt;code&gt;Gateway&lt;/code&gt;）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;网关鉴权&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;网关负责根据请求中的 &lt;code&gt;token&lt;/code&gt; 进行 &lt;strong&gt;鉴权&lt;/strong&gt;，验证该 &lt;code&gt;token&lt;/code&gt; 是否有效。如果验证通过，网关会继续转发请求；如果验证失败，则拒绝请求或重定向至登录页面。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;拦截器将用户信息放入 TTL&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在请求经过网关后，网关会调用拦截器（如 &lt;code&gt;HeaderInterceptor&lt;/code&gt;）。拦截器会提取请求中的用户信息（如 &lt;code&gt;token&lt;/code&gt; 解密后的用户信息），然后将这些信息存放到 &lt;strong&gt;TTL&lt;/strong&gt;（Thread-Local）中。&lt;/li&gt;&#xA;&lt;li&gt;TTL 是一种线程局部存储机制，用于在当前线程内传递数据，确保在同一请求的生命周期内，后续的服务（如 &lt;code&gt;ProjectService&lt;/code&gt; 等）能够访问到这些用户信息。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;后续服务从 TTL 获取用户信息&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;后续的服务（如 &lt;code&gt;ProjectService&lt;/code&gt;）可以通过访问当前线程的 &lt;strong&gt;TTL&lt;/strong&gt; 中的数据来获取用户信息，而无需每次都从请求中提取或解析 &lt;code&gt;token&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;我们所关注的 TTL 在拦截器里实现&lt;/p&gt;</description>
    </item>
    <item>
      <title>volatile关键字</title>
      <link>http://localhost:1313/docs/basic/concurrent/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/basic/concurrent/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>&lt;h4 id=&#34;什么是-volatile&#34;&gt;什么是 &lt;code&gt;volatile&lt;/code&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af-volatile&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;h4 id=&#34;为什么要使用-volatile&#34;&gt;为什么要使用 &lt;code&gt;volatile&lt;/code&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8-volatile&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;[[线程安全问题]]&lt;/p&gt;&lt;/blockquote&gt;</description>
    </item>
    <item>
      <title>多线程入门</title>
      <link>http://localhost:1313/docs/basic/concurrent/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/basic/concurrent/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;h4 id=&#34;为什么要实现多线程&#34;&gt;为什么要实现多线程?&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%ae%9e%e7%8e%b0%e5%a4%9a%e7%ba%bf%e7%a8%8b&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;[!前置]&#xA;&lt;a href=&#34;http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/&#34;&gt;线程与进程&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;进程使得操作系统可以&lt;a href=&#34;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7.md&#34;&gt;并发&lt;/a&gt;的执行任务&#xA;但是在一段时间内单个进程只能执行一个任务&#xA;进程内的子任务只能逐个按顺序执行, 效率还有提升空间&lt;/p&gt;&#xA;&lt;p&gt;因此提出线程概念, 使得一个线程可以执行一个子任务使得进程内部也可实现并发, 提高效率&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;[!NOTE]&#xA;多线程的优势&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信很容易。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;进程是重量级的，而线程是轻量级的，多线程方式的系统开销更小。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;Java中创建线程的三种方式&lt;/p&gt;&#xA;&lt;h4 id=&#34;继承-thread-类&#34;&gt;继承 &lt;code&gt;Thread&lt;/code&gt; 类&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%bb%a7%e6%89%bf-thread-%e7%b1%bb&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;重写 &lt;code&gt;run&lt;/code&gt; 方法&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#e5c890&#34;&gt;MyThread&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;extends&lt;/span&gt; Thread {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8caaee;font-weight:bold&#34;&gt;@Override&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;run&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ca9ee6&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt; 100; i&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            System.&lt;span style=&#34;color:#8caaee&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#8caaee&#34;&gt;println&lt;/span&gt;(getName() &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;:打了&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;+&lt;/span&gt; i &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;个小兵&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;主函数启动线程&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//创建MyThread对象&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;MyThread t1&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; MyThread();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;MyThread t2&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; MyThread();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;MyThread t3&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; MyThread();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//设置线程的名字&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;t1.&lt;span style=&#34;color:#8caaee&#34;&gt;setName&lt;/span&gt;(&lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;鲁班&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;t2.&lt;span style=&#34;color:#8caaee&#34;&gt;setName&lt;/span&gt;(&lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;刘备&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;t3.&lt;span style=&#34;color:#8caaee&#34;&gt;setName&lt;/span&gt;(&lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;亚瑟&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//启动线程&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;t1.&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;t2.&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;t3.&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;实现-runnable-接口&#34;&gt;实现 &lt;code&gt;Runnable&lt;/code&gt; 接口&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%ae%9e%e7%8e%b0-runnable-%e6%8e%a5%e5%8f%a3&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;创建任务类实现 &lt;code&gt;Runnable&lt;/code&gt; 接口&lt;/p&gt;</description>
    </item>
    <item>
      <title>线程</title>
      <link>http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</guid>
      <description>&lt;p&gt;进程&#xA;说简单点就是我们在电脑上启动的一个个应用。它是操作系统分配资源的最小单位。&lt;/p&gt;&#xA;&lt;p&gt;线程&#xA;是进程的子任务，是 CPU 调度和分派的基本单位，实现了进程内部的并发。&lt;/p&gt;&#xA;&lt;h4 id=&#34;线程与进程&#34;&gt;线程与进程&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e4%b8%8e%e8%bf%9b%e7%a8%8b&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;线程，是进程的子任务，是进程中的独立执行单元。多个线程可以共享同一个进程的资源，如内存；每个线程都有自己独立的栈和寄存器。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205083709918.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;并发环境下, 多线程存在下述问题&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;线程之间如何确保执行顺序,实现线程之间的协调与合作? 线程通信&lt;/li&gt;&#xA;&lt;li&gt;线程之间如何确保对临界资源修改不会冲突? 线程同步?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;线程通信线程通信md&#34;&gt;&lt;a href=&#34;http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/&#34;&gt;线程通信&lt;/a&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e9%80%9a%e4%bf%a1%e7%ba%bf%e7%a8%8b%e9%80%9a%e4%bf%a1md&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;Inter-thread communication in Java is a mechanism in which a thread is paused running in its critical section and another thread is allowed to enter (or lock) in the same critical section to be executed.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;线程间通信&lt;/strong&gt;&#xA;是一种机制，使得线程能够在执行时进行协作，通常用于解决某些线程需要等待其他线程完成任务的情况。它主要涉及线程之间的等待和通知机制，而不是同一临界区内的互斥访问。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;线程同步&#34;&gt;线程同步&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e5%90%8c%e6%ad%a5&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;Synchronization&lt;/strong&gt; is crucial for ensuring that multiple threads operate safely on shared resources. Without *&lt;strong&gt;Synchronization&lt;/strong&gt;, data inconsistency or corruption can occur when multiple threads try to access and modify shared variables simultaneously. In Java, it is a mechanism that ensures that only one thread can access a resource at any given time&lt;/p&gt;</description>
    </item>
    <item>
      <title>线程安全问题</title>
      <link>http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;前置&#xA;&lt;a href=&#34;http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/&#34;&gt;线程与进程&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;线程安全是指, 在多线程环境下, 多个线程对共享资源进行并发访问和操作时可能出现的问题&lt;/p&gt;&#xA;&lt;h4 id=&#34;常见的线程安全问题&#34;&gt;常见的线程安全问题&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%b8%b8%e8%a7%81%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e9%97%ae%e9%a2%98&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;h5 id=&#34;可见性问题&#34;&gt;可见性问题&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%8f%af%e8%a7%81%e6%80%a7%e9%97%ae%e9%a2%98&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;确保一个线程对共享变量的修改可以立即被其他线程看到。&#xA;数据竞争&#xA;当多个线程同时访问和修改共享变量时,&#xA;没有适当的同步机制来保护数据一致性, 会导致不可预测的结果&lt;/p&gt;&#xA;&lt;p&gt;volatile 关键字可以保证了变量的修改对所有线程立即可见，并防止编译器优化导致的可见性问题。&lt;/p&gt;&#xA;&lt;h5 id=&#34;原子性问题&#34;&gt;原子性问题&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%8e%9f%e5%ad%90%e6%80%a7%e9%97%ae%e9%a2%98&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;确保当某个线程修改共享变量时，没有其他线程可以同时修改这个变量，即这个操作是不可分割的。&#xA;如果操作的原子性被破坏, 就会导致只有部分操作成功使得结果无法预测&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205194927449.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;原子性可以通过互斥锁（如 synchronized）或原子操作（如 AtomicInteger 类中的方法）来保证。&lt;/p&gt;&#xA;&lt;h5 id=&#34;活跃性问题&#34;&gt;活跃性问题&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e6%b4%bb%e8%b7%83%e6%80%a7%e9%97%ae%e9%a2%98&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;资源竞争&#xA;多个线程争夺有限的资源, 没有适当的同步机制会导致资源分配问题&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;死锁&#xA;两个或多个线程同时占用对方的资源且不释放, 这种情况下，线程将永久阻塞，导致程序无法继续执行&lt;/li&gt;&#xA;&lt;li&gt;饥饿&#xA;当某个线程长时间无法得到资源导致该进程无法继续执行, 会发生饥饿现象&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;引用:&#xA;&lt;a href=&#34;https://blog.csdn.net/a772304419/article/details/130979664&#34;&gt;https://blog.csdn.net/a772304419/article/details/130979664&lt;/a&gt;&#xA;&lt;a href=&#34;https://blog.csdn.net/qq_49217297/article/details/124546726&#34;&gt;https://blog.csdn.net/qq_49217297/article/details/124546726&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;</description>
    </item>
    <item>
      <title>线程池</title>
      <link>http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
      <description>&lt;h4 id=&#34;什么是线程池&#34;&gt;什么是线程池&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%bf%e7%a8%8b%e6%b1%a0&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;线程池(ThreadPool) 是一种基于池化思想管理线程的工具&lt;/p&gt;&#xA;&lt;p&gt;线程池解决的问题是, 在任意时刻下, 确定系统应该投入多少资源, 解决多少任务&lt;/p&gt;&#xA;&lt;p&gt;不将线程统一管理可能会出现以下问题&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。&lt;/li&gt;&#xA;&lt;li&gt;对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。&lt;/li&gt;&#xA;&lt;li&gt;系统无法合理管理内部的资源分布，会降低系统的稳定性。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210102309459.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;线程池内部维护了许多线程, 当有新任务时就会分配一个空闲线程执行&#xA;当所有线程都有任务时, 新的任务要么放到阻塞队列里面要么增加线程&lt;/p&gt;&#xA;&lt;h4 id=&#34;使用线程池&#34;&gt;使用线程池&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%bd%bf%e7%94%a8%e7%ba%bf%e7%a8%8b%e6%b1%a0&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;用法:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;// 创建固定大小的线程池:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ExecutorService executor &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; Executors.&lt;span style=&#34;color:#8caaee&#34;&gt;newFixedThreadPool&lt;/span&gt;(3);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;// 提交任务:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;executor.&lt;span style=&#34;color:#8caaee&#34;&gt;submit&lt;/span&gt;(task1);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;executor.&lt;span style=&#34;color:#8caaee&#34;&gt;submit&lt;/span&gt;(task2);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;executor.&lt;span style=&#34;color:#8caaee&#34;&gt;submit&lt;/span&gt;(task3);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;executor.&lt;span style=&#34;color:#8caaee&#34;&gt;submit&lt;/span&gt;(task4);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;executor.&lt;span style=&#34;color:#8caaee&#34;&gt;submit&lt;/span&gt;(task5);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述代码创建了大小为3的线程池, 并提交了5个任务&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;ExecutorService&lt;/code&gt;该接口要求实现工厂方法, 返回如下类型的线程池&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FixedThreadPool：线程数固定的线程池；&lt;/li&gt;&#xA;&lt;li&gt;CachedThreadPool：线程数根据任务动态调整的线程池；&lt;/li&gt;&#xA;&lt;li&gt;ScheduledThreadPool:  定时执行线程池&lt;/li&gt;&#xA;&lt;li&gt;SingleThreadExecutor：仅单线程执行的线程池。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;线程池原理解析&#34;&gt;线程池原理解析&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e5%8e%9f%e7%90%86%e8%a7%a3%e6%9e%90&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Java的线程池核心实现为 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210180713994.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;顶级接口 &lt;code&gt;Excutor&lt;/code&gt; 提供了一种思想, 将任务提交与任务执行解耦&#xA;用户只需提供 &lt;code&gt;Runnable&lt;/code&gt; 对像, 将任务提交到执行器中, 剩余的线程调配和任务执行由执行器完成&lt;/p&gt;&#xA;&lt;p&gt;ExecutorService接口增加了一些能力：&#xA;（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。&lt;/p&gt;&#xA;&lt;p&gt;线程池构造类 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&#xA;通过传入参数实现线程池的构造&#xA;如下是成员变量,&#xA;![[content/en/docs/Basic/Concurrent/Pasted image 20250203123133.png]]&#xA;参数解释&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;corePoolSize&lt;/code&gt;：线程池中用来工作的核心线程数量。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;maximumPoolSize&lt;/code&gt;：最大线程数，线程池允许创建的最大线程数, 可以理解为非核心线程 + 核心线程数&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;workQueue&lt;/code&gt;：任务队列，是一个阻塞队列，当线程数达到核心线程数后，会将任务存储在阻塞队列中。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;threadFactory&lt;/code&gt; ：线程池内部创建线程所用的工厂。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;handler&lt;/code&gt;：拒绝策略；当队列已满并且线程数量达到最大线程数量时，会调用该方法处理任务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;线程池使用前记得初始化&lt;/p&gt;</description>
    </item>
    <item>
      <title>线程生命周期</title>
      <link>http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>&lt;p&gt;Java的线程分为两类, 用户线程和守护线程&lt;/p&gt;&#xA;&lt;p&gt;线程调度就是线程不同状态间的转换&lt;/p&gt;&#xA;&lt;p&gt;在&lt;a href=&#34;%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2.md&#34;&gt;操作系统&lt;/a&gt;中，线程被视为轻量级的进程，所以&lt;strong&gt;线程状态其实和进程状态是一致的&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205105116917.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Java线程有如下状态&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;// Thread.State 源码&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;enum&lt;/span&gt; State {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    NEW,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    RUNNABLE,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    BLOCKED,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    WAITING,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    TIMED_WAITING,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    TERMINATED;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;new&#34;&gt;NEW&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#new&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;处于 NEW 状态的线程是刚创建 &lt;code&gt;Thread&lt;/code&gt; 而尚未启动。这里的尚未启动指的是还没调用 Thread 实例的&lt;code&gt;start()&lt;/code&gt;方法。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;testStateNew&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Thread thread &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; Thread(() &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt; {});&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    System.&lt;span style=&#34;color:#8caaee&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#8caaee&#34;&gt;println&lt;/span&gt;(thread.&lt;span style=&#34;color:#8caaee&#34;&gt;getState&lt;/span&gt;()); &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;// 输出 NEW&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;runnable&#34;&gt;RUNNABLE&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#runnable&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;当前线程正在运行中。处于 RUNNABLE 状态的线程在 Java 虚拟机中运行，也有可能在等待 CPU 分配非IO资源。&lt;/p&gt;&#xA;&lt;p&gt;Java 线程的&lt;strong&gt;RUNNABLE&lt;/strong&gt;状态其实包括了操作系统线程的&lt;strong&gt;ready&lt;/strong&gt;和&lt;strong&gt;running&lt;/strong&gt;两个状态。&lt;/p&gt;&#xA;&lt;h4 id=&#34;block&#34;&gt;BLOCK&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#block&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;阻塞状态。处于 BLOCKED 状态的线程正等待锁（锁会在后面细讲）的释放以进入同步区。&lt;/p&gt;&#xA;&lt;h4 id=&#34;waiting&#34;&gt;WAITING&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#waiting&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;等待状态。处于等待状态的线程变成 RUNNABLE 状态需要其他线程唤醒。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Object.wait()&lt;/code&gt;：使当前线程处于等待状态直到另一个线程唤醒它&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Thread.join()&lt;/code&gt;：等待线程执行完毕，底层调用的是 Object 的 wait 方法,等待期间可以通过&lt;code&gt;Object.notify()&lt;/code&gt;/&lt;code&gt;notifyAll()/Locksupport.unpark()&lt;/code&gt;唤醒&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;LockSupport.park()&lt;/code&gt;：除非获得调用许可，否则禁用当前线程进行线程调度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;timed_waiting&#34;&gt;TIMED_WAITING&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#timed_waiting&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。&lt;/p&gt;</description>
    </item>
    <item>
      <title>线程通信</title>
      <link>http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</guid>
      <description>&lt;p&gt;&lt;strong&gt;线程通信&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;是一种机制，使得线程能够在执行时进行协作，通常用于解决某些线程需要等待其他线程完成任务的情况。它主要涉及线程之间的等待和通知机制，而不是同一临界区内的互斥访问。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;线程之间传递信息有多种方式，&#xA;比如说使用共享对象、&lt;code&gt;wait()&lt;/code&gt; 和 &lt;code&gt;notify()&lt;/code&gt; 方法、Exchanger 和 &lt;code&gt;CompletableFuture&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;使用共享对象&#34;&gt;使用共享对象&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%bd%bf%e7%94%a8%e5%85%b1%e4%ba%ab%e5%af%b9%e8%b1%a1&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;多个线程同时访问和修改同一个对象, 从而实现信息传递&lt;/p&gt;&#xA;&lt;p&gt;比如 &lt;a href=&#34;http://localhost:1313/docs/basic/concurrent/volatile%E5%85%B3%E9%94%AE%E5%AD%97/&#34;&gt;&lt;code&gt;volatile&lt;/code&gt;&lt;/a&gt;&#xA;&lt;a href=&#34;http://localhost:1313/docs/basic/concurrent/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/&#34;&gt;&lt;code&gt;synchronized&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>自旋锁与CLH锁</title>
      <link>http://localhost:1313/docs/basic/concurrent/%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8Eclh%E9%94%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/basic/concurrent/%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8Eclh%E9%94%81/</guid>
      <description>&lt;p&gt;在并发编程中，锁是一种常用的保证线程安全的方法。&lt;/p&gt;&#xA;&lt;p&gt;Java 中常用的锁主要有两类，一种是关键字 &lt;a href=&#34;http://localhost:1313/docs/basic/concurrent/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/&#34;&gt;synchronized&lt;/a&gt; ，被称为 Java 内置锁或监视器锁。&lt;/p&gt;&#xA;&lt;p&gt;另一种就是在 J2SE 1.5版本之后的 java.util.concurrent包（下称j.u.c包）中的各类同步器&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;包括 ReentrantLock（可重入锁），ReentrantReadWriteLock（可重入读写锁），Semaphore（信号量），CountDownLatch 等&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;这些同步器都是基于 AbstractQueuedSynchronizer（下称 AQS）这个简单的框架来构建的&lt;/p&gt;&#xA;&lt;p&gt;AQS 类的核心数据结构是一种名为 &lt;code&gt;Craig, Landin, and Hagersten locks&lt;/code&gt;（下称 CLH 锁）的变体。&lt;/p&gt;&#xA;&lt;p&gt;CLH锁是自旋锁的一种改良&lt;/p&gt;&#xA;&lt;h4 id=&#34;自旋锁&#34;&gt;自旋锁&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e8%87%aa%e6%97%8b%e9%94%81&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;自旋锁是互斥锁的一种实现, 用于保证线程间正确互斥&lt;/p&gt;&#xA;&lt;p&gt;获取锁时，线程会对一个原子变量循环执行 &lt;code&gt;compareAndSet&lt;/code&gt; 方法，直到该方法返回成功时即为成功获取锁&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;compareAndSet&lt;/code&gt; 方法底层由[[CAS(compare-and-swap)]]实现&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;![[content/en/docs/Basic/Concurrent/Pasted image 20250203201648.png]]&lt;/p&gt;&#xA;&lt;p&gt;自旋锁减少了线程上下文开销, 减缓了频繁的&lt;a href=&#34;http://localhost:1313/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92/&#34;&gt;线程挂起操作&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;但是该锁有很严重的缺点&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;饥饿问题, 竞争激烈下, 可能有线程一直得不到锁&lt;/li&gt;&#xA;&lt;li&gt;性能问题, 长时间自旋并且由于锁状态变更需要修改状态变量, 导致CPU的高速缓存在线程间频繁同步, 很消耗CPU&#xA;![[content/en/docs/Basic/Concurrent/Pasted image 20250203202833.png]]&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;clh锁&#34;&gt;CLH锁&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#clh%e9%94%81&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://localhost:1313/docs/basic/concurrent/volatile%E5%85%B3%E9%94%AE%E5%AD%97/&#34;&gt;volatile关键字&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;这是对自旋锁的改进版本&#xA;主要针对上述两个缺点做了改进&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;饥饿问题, 将线程组织为队列, 先来先服务, 防止饥饿问题&lt;/li&gt;&#xA;&lt;li&gt;去中心化, 不在使用单独的锁状态变量, 而是在每个线程内维护一个状态变量, 后继线程监视前继线程的状态即可&#xA;CLH 锁数据结构很简单，类似一个链表队列，所有请求获取锁的线程会排列在链表队列中，自旋访问队列中前一个节点的状态。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;![[content/en/docs/Basic/Concurrent/Pasted image 20250203203420.png]]&lt;/p&gt;</description>
    </item>
    <item>
      <title>获取线程执行结果</title>
      <link>http://localhost:1313/docs/basic/concurrent/%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/basic/concurrent/%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;Java 1.5 提供了 Callable、Future、FutureTask，它们可以在任务执行完后得到执行结果, 可以实现业务之间的并发执行与返回&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;在[[多线程入门]] 我们讲述了创建线程实现任务并发的 3 种方式，&#xA;直接继承 &lt;code&gt;Thread&lt;/code&gt;&#xA;实现 &lt;code&gt;Runnable&lt;/code&gt; 接口&#xA;实现 &lt;code&gt;Callable&amp;lt;&amp;gt;&lt;/code&gt; 接口&lt;/p&gt;&#xA;&lt;p&gt;前 2 种方式都有一个缺陷：在执行完任务之后无法获取执行结果。这对需要前置任务返回值的线程来说很重要&lt;/p&gt;&#xA;&lt;p&gt;Java 1.5 提供了 Callable、Future、FutureTask，它们可以在任务执行完后得到执行结果&lt;/p&gt;&#xA;&lt;h4 id=&#34;callable&#34;&gt;Callable&amp;lt;&amp;gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#callable&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;&lt;code&gt;callable&lt;/code&gt; 源码如下&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#e5c890&#34;&gt;Callable&lt;/span&gt;&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;V&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    V &lt;span style=&#34;color:#8caaee&#34;&gt;call&lt;/span&gt;() &lt;span style=&#34;color:#e78284&#34;&gt;throws&lt;/span&gt; Exception;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到 &lt;code&gt;call()&lt;/code&gt; 方法返回值为泛型 V&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;而 &lt;code&gt;Callable&amp;lt;&amp;gt;&lt;/code&gt; 允许返回值的一个任务&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Runnable&lt;/code&gt; 接口代表一个可以由线程执行的任务, 实现 &lt;code&gt;Runnable&lt;/code&gt; 而不是 &lt;code&gt;callable&lt;/code&gt; 主要是线程池的兼容性考虑&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;future-异步计算结果接口&#34;&gt;&lt;code&gt;Future&lt;/code&gt; 异步计算结果接口&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#future-%e5%bc%82%e6%ad%a5%e8%ae%a1%e7%ae%97%e7%bb%93%e6%9e%9c%e6%8e%a5%e5%8f%a3&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Future&lt;/code&gt; 表示异步计算的结果，提供了用于检查计算是否完成、等待计算完成、以及检索计算结果的方法。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;Future&lt;/code&gt; 接口的设计目标是允许任务在一个线程中执行，并且可以返回执行结果或抛出异常&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#e5c890&#34;&gt;Future&lt;/span&gt;&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;V&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;cancel&lt;/span&gt;(&lt;span style=&#34;color:#e78284&#34;&gt;boolean&lt;/span&gt; mayInterruptIfRunning);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;isCancelled&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;isDone&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    V &lt;span style=&#34;color:#8caaee&#34;&gt;get&lt;/span&gt;() &lt;span style=&#34;color:#e78284&#34;&gt;throws&lt;/span&gt; InterruptedException, ExecutionException;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    V &lt;span style=&#34;color:#8caaee&#34;&gt;get&lt;/span&gt;(&lt;span style=&#34;color:#e78284&#34;&gt;long&lt;/span&gt; timeout, TimeUnit unit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e78284&#34;&gt;throws&lt;/span&gt; InterruptedException, ExecutionException, TimeoutException;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;取消任务；&lt;/li&gt;&#xA;&lt;li&gt;判断任务是否被取消;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;get()&lt;/code&gt;：等待任务完成，获取执行结果，如果任务取消会抛出异常&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;get(long timeout, TimeUnit unit)&lt;/code&gt;：指定等待任务完成的时间，等待超时会抛出异常&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;注意, &lt;code&gt;get()&lt;/code&gt; 方法会阻塞主进程, 一直阻塞到定时结束或者线程返回&lt;/p&gt;</description>
    </item>
    <item>
      <title>通信工具类</title>
      <link>http://localhost:1313/docs/basic/concurrent/%E9%80%9A%E4%BF%A1%E5%B7%A5%E5%85%B7%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/basic/concurrent/%E9%80%9A%E4%BF%A1%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid>
      <description>&lt;p&gt;JDK 中提供了一些并发编程中常用的通信工具类以供我们开发者使用&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;类&lt;/th&gt;&#xA;          &lt;th&gt;作用&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Semaphore&lt;/td&gt;&#xA;          &lt;td&gt;限制线程的数量&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Exchanger&lt;/td&gt;&#xA;          &lt;td&gt;两个线程交换数据&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CountDownLatch&lt;/td&gt;&#xA;          &lt;td&gt;线程等待直到计数器减为 0 时开始工作&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CyclicBarrier&lt;/td&gt;&#xA;          &lt;td&gt;作用跟 CountDownLatch 类似，但是可以重复使用&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Phaser&lt;/td&gt;&#xA;          &lt;td&gt;增强的 CyclicBarrier&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;countdownlatch&#34;&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#countdownlatch&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;一个减法计数器, 基于信号量&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#e5c890&#34;&gt;CountTest&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;  &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;[]&lt;/span&gt; args) &lt;span style=&#34;color:#e78284&#34;&gt;throws&lt;/span&gt; InterruptedException {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//设置一个尺寸为10的信号量&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9; &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//总数是10，必须要执行任务的时候，再使用&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        CountDownLatch countDownLatch &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; CountDownLatch(10);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ca9ee6&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;0; i&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;10; i&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; Thread(()&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                System.&lt;span style=&#34;color:#8caaee&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#8caaee&#34;&gt;println&lt;/span&gt;(Thread.&lt;span style=&#34;color:#8caaee&#34;&gt;currentThread&lt;/span&gt;().&lt;span style=&#34;color:#8caaee&#34;&gt;getName&lt;/span&gt;()&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34; Go out&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                countDownLatch.&lt;span style=&#34;color:#8caaee&#34;&gt;countDown&lt;/span&gt;(); &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//数量减1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            },String.&lt;span style=&#34;color:#8caaee&#34;&gt;valueOf&lt;/span&gt;(i)).&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        countDownLatch.&lt;span style=&#34;color:#8caaee&#34;&gt;await&lt;/span&gt;(); &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//等待计数器归零，再向下执行&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#8caaee&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#8caaee&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;Hello world!&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;两个方法&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;countDown()&lt;/code&gt; 调用后计数减一&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;await()&lt;/code&gt; 使线程挂起&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;exchanger&#34;&gt;&lt;code&gt;Exchanger&lt;/code&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#exchanger&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;A synchronization point at which threads can pair and swap elements within pairs. Each thread presents some object on entry to the &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Exchanger.html#exchange-V-&#34;&gt;&lt;code&gt;exchange&lt;/code&gt;&lt;/a&gt; method, matches with a partner thread, and receives its partner&amp;rsquo;s object on return. An Exchanger may be viewed as a bidirectional form of a &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/SynchronousQueue.html&#34; title=&#34;class in java.util.concurrent&#34;&gt;&lt;code&gt;SynchronousQueue&lt;/code&gt;&lt;/a&gt;. Exchangers may be useful in applications such as genetic algorithms and pipeline designs.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
