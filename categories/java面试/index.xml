<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java面试 on 海阔集</title>
    <link>http://localhost:58072/categories/java%E9%9D%A2%E8%AF%95/</link>
    <description>Recent content in Java面试 on 海阔集</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="http://localhost:58072/categories/java%E9%9D%A2%E8%AF%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>并发编程</title>
      <link>http://localhost:58072/interview/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:58072/interview/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h4 id=&#34;并行和并发的区别&#34;&gt;并行和并发的区别&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%b9%b6%e8%a1%8c%e5%92%8c%e5%b9%b6%e5%8f%91%e7%9a%84%e5%8c%ba%e5%88%ab&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;处理器同时处理多个任务为并行&#xA;处理器在一定的时间间隔, 交替处理任务交并发&lt;/p&gt;&#xA;&lt;p&gt;类似红绿灯, 路口所有车道车辆通信为并行&#xA;但是路口一定时间间隔内只允许一辆车通过, 不同车道的车交替通过叫并发&lt;/p&gt;&#xA;&lt;h4 id=&#34;什么是线程安全&#34;&gt;什么是线程安全&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;2/5/2025&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;线程安全是指,  多线程环境下访问共享资源时, 线程可以正确执行, 而不会出现问题&lt;/p&gt;&#xA;&lt;p&gt;线程安全有以下几个问题&lt;/p&gt;&#xA;&lt;p&gt;可见性问题&#xA;线程对共享变量的修改能被其他线程立即看到&#xA;可以通过 volatile 关键字保证数据一致性&lt;/p&gt;&#xA;&lt;p&gt;原子性问题&#xA;操作是不可分割的, 成功则全部成功, 失败则全部失败&#xA;原子性可以通过正确的同步机制 如 syncroizd 关键字实现线程同步以及原子操作来保证, 防止操作被意外中断&lt;/p&gt;&#xA;&lt;p&gt;活跃性问题&#xA;当多线程争夺有限资源时可能会导致死锁, 饥饿等问题&lt;/p&gt;&#xA;&lt;h4 id=&#34;如何保证线程安全&#34;&gt;如何保证线程安全&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;2/9&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;为了保证线程安全，可以使用 synchronized 关键字或 ReentrantLock 来保证共享资源的互斥访问。&lt;/p&gt;&#xA;&lt;p&gt;对于简单的变量操作，可以使用 Atomic 类来实现无锁线程安全。&lt;/p&gt;&#xA;&lt;p&gt;可以使用线程安全容器，如 ConcurrentHashMap 或 CopyOnWriteArrayList。&lt;/p&gt;&#xA;&lt;p&gt;对于每个线程独立的数据，可以使用 ThreadLocal 来为每个线程提供独立的变量副本。&lt;/p&gt;&#xA;&lt;p&gt;对于简单的状态标志，可以使用 volatile 关键字确保多线程间的可见性。&lt;/p&gt;&#xA;&lt;h4 id=&#34;有个int的变量为0十个线程轮流对其进行操作循环10000次结果是大于小于还是等于10万为什么&#34;&gt;有个int的变量为0，十个线程轮流对其进行++操作（循环10000次），结果是大于小于还是等于10万，为什么？&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e6%9c%89%e4%b8%aaint%e7%9a%84%e5%8f%98%e9%87%8f%e4%b8%ba0%e5%8d%81%e4%b8%aa%e7%ba%bf%e7%a8%8b%e8%bd%ae%e6%b5%81%e5%af%b9%e5%85%b6%e8%bf%9b%e8%a1%8c%e6%93%8d%e4%bd%9c%e5%be%aa%e7%8e%af10000%e6%ac%a1%e7%bb%93%e6%9e%9c%e6%98%af%e5%a4%a7%e4%ba%8e%e5%b0%8f%e4%ba%8e%e8%bf%98%e6%98%af%e7%ad%89%e4%ba%8e10%e4%b8%87%e4%b8%ba%e4%bb%80%e4%b9%88&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;小于&lt;/p&gt;&#xA;&lt;p&gt;int++ 实际上可以分解为三步：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;读取变量的值。&lt;/li&gt;&#xA;&lt;li&gt;将读取到的值加 1。&lt;/li&gt;&#xA;&lt;li&gt;将结果写回变量。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;多线程并发操作共享的i 会出现竞态条件&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
