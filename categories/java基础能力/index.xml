<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java基础能力 on 海阔集</title>
    <link>http://localhost:51674/categories/java%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B/</link>
    <description>Recent content in Java基础能力 on 海阔集</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="http://localhost:51674/categories/java%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java基础能力</title>
      <link>http://localhost:51674/docs/basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/</guid>
      <description>&lt;p&gt;内容来源:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;沉默王二 GitHub 上开源的知识库《&lt;a href=&#34;https://github.com/itwanger/toBeBetterJavaer&#34;&gt;Java 进阶之路&lt;/a&gt;》&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.rabbitmq.com/tutorials&#34;&gt;rabbitMQ&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>AQS</title>
      <link>http://localhost:51674/docs/basic/concurrent/aqs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/concurrent/aqs/</guid>
      <description>&lt;p&gt;&lt;strong&gt;AQS&lt;/strong&gt;是&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;的简称，即&lt;code&gt;抽象的队列同步器&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;抽象：抽象类，只实现一些主要逻辑，有些方法由子类实现；&lt;/li&gt;&#xA;&lt;li&gt;队列：使用先进先出（FIFO）的队列存储数据；&lt;/li&gt;&#xA;&lt;li&gt;同步：实现了同步的功能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;为什么需要-aqs&#34;&gt;为什么需要 &lt;code&gt;AQS&lt;/code&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81-aqs&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的同步器&#xA;简单的说,  存储并管理线程同步的模板&lt;/p&gt;&#xA;&lt;p&gt;具体的同步器（如 &lt;code&gt;ReentrantLock&lt;/code&gt;、&lt;code&gt;CountDownLatch&lt;/code&gt;、&lt;code&gt;Semaphore&lt;/code&gt;, &lt;a href=&#34;http://localhost:51674/docs/basic/concurrent/%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C/&#34;&gt;FutureTask&lt;/a&gt;等）是通过继承 &lt;code&gt;AQS&lt;/code&gt; 并实现一些抽象方法来实现资源的具体获取和释放行为的。&lt;/p&gt;&#xA;&lt;h4 id=&#34;aqs的作用是什么&#34;&gt;&lt;code&gt;AQS&lt;/code&gt;的作用是什么?&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#aqs%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;了解&#xA;&lt;a href=&#34;http://localhost:51674/docs/basic/concurrent/%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8Eclh%E9%94%81/&#34;&gt;自旋锁与CLH锁&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;AQS&lt;/code&gt; 是一个 &lt;strong&gt;抽象类&lt;/strong&gt;，它为具体的同步器提供了一个通用的执行框架。&#xA;它定义了如何获取和释放共享资源的基本流程，但并没有实现具体的逻辑。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;AQS&lt;/code&gt; 提供了同步器所需要的 &lt;strong&gt;框架和基础设施&lt;/strong&gt;，比如：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如何在多个线程间协调资源的竞争。&lt;/li&gt;&#xA;&lt;li&gt;如何管理线程的队列（阻塞队列）以等待资源。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;其中AQS 的核心数据结构是基于&lt;a href=&#34;http://localhost:51674/docs/basic/concurrent/%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8Eclh%E9%94%81/&#34;&gt;CLH 锁&lt;/a&gt;改进的, 详情下述&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;线程的挂起与唤醒等机制。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;aqs的数据结构&#34;&gt;AQS的数据结构&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#aqs%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;既然是控制线程, 那么数据结构应对并发相应的优化&#xA;AQS的核心数据结构是基于 CLH队列锁改进的&#xA;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/Pasted%20image%2020250203211340.png&#34; alt=&#34;Pasted image 20250203211340.png&#34;&gt;&#xA;CLH队列锁有如下缺点&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;仍然基于自旋, 长时间自旋下CPU占用高&lt;/li&gt;&#xA;&lt;li&gt;功能单一, 不能挂起, 不能共享读, 只支持独占等&#xA;针对以上缺点, AQS进行改造&lt;/li&gt;&#xA;&lt;li&gt;AQS 将自旋操作改为阻塞线程操作。&lt;/li&gt;&#xA;&lt;li&gt;AQS 对 CLH 锁进行改造和扩展, 扩展每个节点的状态、显式的维护前驱节点和后继节点&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;AQS 内部使用了一个&lt;a href=&#34;http://localhost:51674/docs/basic/concurrent/volatile%E5%85%B3%E9%94%AE%E5%AD%97/&#34;&gt;volatile关键字&lt;/a&gt; 的变量 &lt;code&gt;state&lt;/code&gt; 来作为线程的状态标识。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; waitStatus;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该变量有如下状态, AQS提供原子读写&#xA;![[content/en/docs/Basic/Concurrent/Pasted image 20250203210552.png]]&lt;/p&gt;</description>
    </item>
    <item>
      <title>Docker</title>
      <link>http://localhost:51674/docs/basic/docker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/docker/</guid>
      <description>&lt;p&gt;内容来源:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;沉默王二 GitHub 上开源的知识库《&lt;a href=&#34;https://github.com/itwanger/toBeBetterJavaer&#34;&gt;Java 进阶之路&lt;/a&gt;》&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Java并发编程</title>
      <link>http://localhost:51674/docs/basic/concurrent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/concurrent/</guid>
      <description>&lt;p&gt;内容来源:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;沉默王二 GitHub 上开源的知识库《&lt;a href=&#34;https://github.com/itwanger/toBeBetterJavaer&#34;&gt;Java 进阶之路&lt;/a&gt;》&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://javaguide.cn/java/concurrent/&#34;&gt;JavaGuide&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg&#34;&gt;CLH锁 - Quner技术沙龙&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;操作系统 - 西电出版&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Java的四种引用</title>
      <link>http://localhost:51674/docs/basic/jvm/java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/jvm/java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/</guid>
      <description>&lt;p&gt;强引用&#xA;A a=new A(); 此时引用a强引用对象A；不会被GC&#xA;即使OOM也不会回收对象, 而是抛异常&lt;/p&gt;&#xA;&lt;p&gt;弱引用&#xA;&lt;strong&gt;WeakReference.java&lt;/strong&gt; 是 Java1.2提供的一个类&#xA;当GC发现弱引用后会直接回收该对象&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java集合框架</title>
      <link>http://localhost:51674/docs/basic/container/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/container/</guid>
      <description>&lt;p&gt;内容来源:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;沉默王二 GitHub 上开源的知识库《&lt;a href=&#34;https://github.com/itwanger/toBeBetterJavaer&#34;&gt;Java 进阶之路&lt;/a&gt;》&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://javaguide.cn/java/concurrent/&#34;&gt;JavaGuide&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/&#34;&gt;Geeksforgeeks&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.runoob.com/&#34;&gt;菜鸟教程&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>JMM内存模型</title>
      <link>http://localhost:51674/docs/basic/concurrent/jmm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/concurrent/jmm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;p&gt;Java 内存模型（Java Memory Model，JMM）定义了 Java 程序中的变量、线程如何和主存以及工作内存进行交互的规则, 可以理解为并发编程相关的一组规范&lt;/p&gt;&#xA;&lt;p&gt;JMM在Java中主要解决&lt;a href=&#34;http://localhost:51674/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/&#34;&gt;线程同步与通信&lt;/a&gt;问题, 涉及到内存可见性, 指令重排等问题&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Java 是最早尝试提供内存模型的编程语言。由于早期内存模型存在一些缺陷（比如非常容易削弱编译器的优化能力），从 Java5 开始，Java 开始使用新的内存模型&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;一般来说，编程语言也可以直接复用操作系统层面的内存模型。不过，不同的操作系统内存模型不同。如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了。&#xA;Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205095605661.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;红色区域称主内存, 是线程存放共享变量的区域&lt;/p&gt;&#xA;&lt;p&gt;白色为本地内存&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;主内存&lt;/strong&gt;：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量，还是局部变量，类信息、常量、静态变量都是放在主内存中。为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;本地内存&lt;/strong&gt;：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的副本。每个线程只能操作自己本地内存中的变量，无法直接访问其他线程的本地内存。如果线程间需要通信，必须通过主内存来进行。本地内存是 JMM 抽象出来的一个概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;内存可见性问题&#34;&gt;内存可见性问题&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%86%85%e5%ad%98%e5%8f%af%e8%a7%81%e6%80%a7%e9%97%ae%e9%a2%98&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;和 &lt;a href=&#34;CPU%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.md&#34;&gt;CPU cache&lt;/a&gt; 类似, 当多个线程同时读写共享变量时, 线程不存在同步机制会导致变量被覆写, 导致结果不可预见&#xA;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205100230451.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;如何解决内存可见性问题?&lt;/p&gt;&#xA;&lt;p&gt;关于主内存与工作内存直接的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义来以下八种同步操作&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205100905174.png&#34; alt=&#34;image.png&#34;&gt;&#xA;初次之外还规定了很多同步规则,这不重要&lt;/p&gt;&#xA;&lt;h4 id=&#34;指令重排序问题&#34;&gt;指令重排序问题&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e6%8c%87%e4%bb%a4%e9%87%8d%e6%8e%92%e5%ba%8f%e9%97%ae%e9%a2%98&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;什么是指令重排序？&lt;/strong&gt; 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。&lt;strong&gt;指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致&lt;/strong&gt; ，所以在多线程下，指令重排序可能会导致一些问题。&lt;/p&gt;&#xA;&lt;h4 id=&#34;happen-before-原则&#34;&gt;happen-before 原则&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#happen-before-%e5%8e%9f%e5%88%99&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;happens-before 这个概念最早诞生于 Leslie Lamport 于 1978 年发表的论文&lt;a href=&#34;https://lamport.azurewebsites.net/pubs/time-clocks.pdf&#34;&gt;《Time，Clocks and the Ordering of Events in a Distributed System》&lt;/a&gt;。在这篇论文中，Leslie Lamport 提出了逻辑时钟的概念，这也成了第一个逻辑时钟算法 。&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM</title>
      <link>http://localhost:51674/docs/basic/jvm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/jvm/</guid>
      <description>&lt;p&gt;内容来源:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;沉默王二 GitHub 上开源的知识库《&lt;a href=&#34;https://github.com/itwanger/toBeBetterJavaer&#34;&gt;Java 进阶之路&lt;/a&gt;》&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://javaguide.cn/java/concurrent/&#34;&gt;JavaGuide&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/&#34;&gt;Geeksforgeeks&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.runoob.com/&#34;&gt;菜鸟教程&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>LinkedList</title>
      <link>http://localhost:51674/docs/basic/container/linkedlist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/container/linkedlist/</guid>
      <description>&lt;h4 id=&#34;什么是链表&#34;&gt;什么是链表&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e9%93%be%e8%a1%a8&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。&lt;/p&gt;&#xA;&lt;p&gt;链表可分为单向链表和双向链表。&lt;/p&gt;&#xA;&lt;p&gt;一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。&lt;/p&gt;&#xA;&lt;p&gt;单向链表&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250207180458615.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;双向链表&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250207180510867.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Doubly-linked list implementation of the &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Deque&lt;/code&gt; interfaces. Implements all optional list operations, and permits all elements (including &lt;code&gt;null&lt;/code&gt;).&#xA;&lt;code&gt;LinkedList&lt;/code&gt; 是基于双向链表的数据结构, 实现队列和列表接口的所有方法, 允许存放任意类型元素&lt;/p&gt;&#xA;&lt;h4 id=&#34;基础使用&#34;&gt;基础使用&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%9f%ba%e7%a1%80%e4%bd%bf%e7%94%a8&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;以下情况使用 LinkedList :&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;你需要通过循环迭代来访问列表中的某些元素。&lt;/li&gt;&#xA;&lt;li&gt;需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#e5c890&#34;&gt;LinkedList&lt;/span&gt;&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;E&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;extends&lt;/span&gt; AbstractSequentialList&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;E&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;implements&lt;/span&gt; List&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;E&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;, Deque&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;E&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;, Cloneable, Serializable&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用之前:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;LinkedList&lt;/code&gt; 类位于 &lt;code&gt;java.util&lt;/code&gt; 包中，使用前需要引入它&lt;/li&gt;&#xA;&lt;li&gt;链表实现了 &lt;code&gt;Queue&lt;/code&gt; 接口, 可以作为队列使用&lt;/li&gt;&#xA;&lt;li&gt;链表实现了 &lt;code&gt;List&lt;/code&gt; 接口, 可进行列表的相关操作&lt;/li&gt;&#xA;&lt;li&gt;链表添加标签 &lt;code&gt;Cloneable&lt;/code&gt; 允许克隆&lt;/li&gt;&#xA;&lt;li&gt;链表实现 &lt;code&gt;Serializable&lt;/code&gt; 可以序列化&lt;/li&gt;&#xA;&lt;li&gt;链表线程不安全, 依赖外部同步&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250207181217867.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL</title>
      <link>http://localhost:51674/docs/basic/mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/mysql/</guid>
      <description>&lt;p&gt;内容来源:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;沉默王二 GitHub 上开源的知识库《&lt;a href=&#34;https://github.com/itwanger/toBeBetterJavaer&#34;&gt;Java 进阶之路&lt;/a&gt;》&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>MySQL字符集和比较规则</title>
      <link>http://localhost:51674/docs/basic/mysql/mysql%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/mysql/mysql%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/</guid>
      <description>&lt;h4 id=&#34;字符集&#34;&gt;字符集&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%ad%97%e7%ac%a6%e9%9b%86&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;计算机的世界里，它是只认识 0 和 1 的, 那汉字怎么办? 英文怎么办?&lt;/p&gt;&#xA;&lt;p&gt;我们在屏幕上看到的英文、汉字等字符是二进制数转换之后的结果&lt;/p&gt;&#xA;&lt;p&gt;通俗的说，按照何种规则将字符存储在计算机中，如&amp;rsquo;a&amp;rsquo;用什么表示，称为&amp;quot;编码&amp;quot;；反之，将存储在计算机中的二进制数解析显示出来，称为&amp;quot;解码&amp;quot;,如果使用了错误的解码规则，则导致&amp;rsquo;a&amp;rsquo;解析成&amp;rsquo;b&amp;rsquo;或者乱码。&lt;/p&gt;&#xA;&lt;h4 id=&#34;ascii字符集编码&#34;&gt;ASCII字符集&amp;amp;编码&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#ascii%e5%ad%97%e7%ac%a6%e9%9b%86%e7%bc%96%e7%a0%81&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;ASCII(American Standard Code for Information Interchange，美国信息交换标准代码)&lt;/p&gt;&#xA;&lt;p&gt;是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250211010458860.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250211010511256.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;ASCII的最大缺点是只能显示26个基本拉丁字母、阿拉伯数目字和英式标点符号，因此只能用于显示现代美国英语&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;已经淘汰&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;gbxxxx字符集编码&#34;&gt;GBXXXX字符集&amp;amp;编码&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#gbxxxx%e5%ad%97%e7%ac%a6%e9%9b%86%e7%bc%96%e7%a0%81&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;计算机发明之处及后面很长一段时间，只用应用于美国及西方一些发达国家，ASCII能够很好满足用户的需求。&lt;/p&gt;&#xA;&lt;p&gt;但是当天朝也有了计算机之后，为了显示中文，必须设计一套编码规则用于将汉字转换为计算机可以接受的数字系统的字符集。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250211010616455.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;什么都有, 基本东亚文字全了&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;GBK是对GB2312-80的扩展, 收录了繁体&lt;/p&gt;&#xA;&lt;h2 id=&#34;unicode字符集utf编码&#34;&gt;Unicode字符集&amp;amp;UTF编码&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#unicode%e5%ad%97%e7%ac%a6%e9%9b%86utf%e7%bc%96%e7%a0%81&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;&lt;em&gt;你说的对, 但是每个国家有自己的编码&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;那网络聊天怎么办? 编码不同根本无法识别&lt;/p&gt;&#xA;&lt;p&gt;为了解决这个问题，一个伟大的创想产生了——Unicode。Unicode编码系统为表达任意语言的任意字符而设计。&#xA;被几种语言共用的字符通常使用相同的数字来编码, 不存在二义性。不再需要记录&amp;quot;模式&amp;quot;了&lt;/p&gt;&#xA;&lt;p&gt;MySQL的UTF-8最多支持三个字节&lt;/p&gt;&#xA;&lt;p&gt;UTF-8mb4支持四个字节&lt;/p&gt;&#xA;&lt;h4 id=&#34;比较规则&#34;&gt;比较规则&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e6%af%94%e8%be%83%e8%a7%84%e5%88%99&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;</description>
    </item>
    <item>
      <title>MySQL数据库操作</title>
      <link>http://localhost:51674/docs/basic/mysql/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/mysql/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</guid>
      <description>&lt;p&gt;十分钟快速上手MySQL&lt;/p&gt;&#xA;&lt;h4 id=&#34;创建数据库&#34;&gt;创建数据库&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%88%9b%e5%bb%ba%e6%95%b0%e6%8d%ae%e5%ba%93&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;create&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;database&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;数据库名&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;提示:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;上下箭头可以切换之前执行的指令&lt;/li&gt;&#xA;&lt;li&gt;记得加分号&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;切换数据库&#34;&gt;切换数据库&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%88%87%e6%8d%a2%e6%95%b0%e6%8d%ae%e5%ba%93&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;use &lt;span style=&#34;color:#e78284&#34;&gt;数据库名&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;删除数据库&#34;&gt;删除数据库&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%88%a0%e9%99%a4%e6%95%b0%e6%8d%ae%e5%ba%93&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;提示:&#xA;这个指令一般不用😂&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;drop&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;database&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;数据库名&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;了解&#xA;&lt;a href=&#34;http://localhost:51674/docs/basic/mysql/mysql%E8%A1%A8%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/&#34;&gt;表&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;java交互mysql&#34;&gt;Java交互MySQL&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#java%e4%ba%a4%e4%ba%92mysql&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;上述都是命令行操作&lt;/p&gt;&#xA;&lt;p&gt;如何在Java程序对数据库进行操作?&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;驱动&#xA;和显卡驱动, 网卡驱动类似, Java程序想要对MySQL做操作时也需要这样的桥梁&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/downloads/connector/j/&#34;&gt;MySQL Connector/J&lt;/a&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;classpath&lt;/code&gt;&#xA;也就是 &lt;code&gt;src/main/resources&lt;/code&gt; 目录&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;将下载的 &lt;code&gt;.jar&lt;/code&gt; 包放到项目 &lt;code&gt;classpath&lt;/code&gt; 下&lt;/p&gt;&#xA;&lt;p&gt;在IDE中写一个类连接到服务器&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#e5c890&#34;&gt;DatabaseCreator&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;final&lt;/span&gt; String URL &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;jdbc:mysql://localhost:3306/?useSSL=false&amp;amp;serverTimezone=UTC&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;final&lt;/span&gt; String USER &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;root&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;final&lt;/span&gt; String PASSWORD &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;Codingmore123&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;final&lt;/span&gt; String DATABASE_NAME &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;pai_coding&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;[]&lt;/span&gt; args) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ca9ee6&#34;&gt;try&lt;/span&gt; (Connection conn &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; DriverManager.&lt;span style=&#34;color:#8caaee&#34;&gt;getConnection&lt;/span&gt;(URL, USER, PASSWORD);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             Statement stmt &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; conn.&lt;span style=&#34;color:#8caaee&#34;&gt;createStatement&lt;/span&gt;()) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ca9ee6&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;!&lt;/span&gt;databaseExists(conn, DATABASE_NAME)) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                stmt.&lt;span style=&#34;color:#8caaee&#34;&gt;executeUpdate&lt;/span&gt;(&lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;CREATE DATABASE IF NOT EXISTS &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;+&lt;/span&gt; DATABASE_NAME);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                System.&lt;span style=&#34;color:#8caaee&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#8caaee&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;数据库创建成功&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            } &lt;span style=&#34;color:#ca9ee6&#34;&gt;else&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                System.&lt;span style=&#34;color:#8caaee&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#8caaee&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;数据库已经存在&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#ca9ee6&#34;&gt;catch&lt;/span&gt; (SQLException e) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            e.&lt;span style=&#34;color:#8caaee&#34;&gt;printStackTrace&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;databaseExists&lt;/span&gt;(Connection conn, String dbName) &lt;span style=&#34;color:#e78284&#34;&gt;throws&lt;/span&gt; SQLException {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ResultSet resultSet &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; conn.&lt;span style=&#34;color:#8caaee&#34;&gt;getMetaData&lt;/span&gt;().&lt;span style=&#34;color:#8caaee&#34;&gt;getCatalogs&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ca9ee6&#34;&gt;while&lt;/span&gt; (resultSet.&lt;span style=&#34;color:#8caaee&#34;&gt;next&lt;/span&gt;()) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ca9ee6&#34;&gt;if&lt;/span&gt; (dbName.&lt;span style=&#34;color:#8caaee&#34;&gt;equals&lt;/span&gt;(resultSet.&lt;span style=&#34;color:#8caaee&#34;&gt;getString&lt;/span&gt;(1))) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#ca9ee6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ef9f76&#34;&gt;true&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ca9ee6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ef9f76&#34;&gt;false&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;DriverManager.getConnection(URL, USER, PASSWORD)&lt;/code&gt;：通过 JDBC 建立到 MySQL 服务器的连接。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL数据库查询</title>
      <link>http://localhost:51674/docs/basic/mysql/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/mysql/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2/</guid>
      <description>&lt;p&gt;在日常的开发工作中，查询语句也是最常用的，因为表在一开始设计的时候已经确定了，后期很少去修改表结构，也就意味着插入数据的方式也是确定的&lt;/p&gt;&#xA;&lt;p&gt;但数据的展示方式却千奇百怪，用户端和 admin 管理端可能需要各种各样的数据，那 MySQL 就要提供最接近需求的数据，这样可以节省 Java 程序对数据的转换处理，也就相应提升了程序的性能。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;SELECT&lt;/code&gt; 语句可以灵活组织不同表的数据, 提供最接近需求的组合&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;提示:&#xA;接下来的操作默认是单库操作&#xA;也就是说需要先选中某个数据库,&#xA;快去选择吧&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;查询单个字段&#34;&gt;查询单个字段&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e6%9f%a5%e8%af%a2%e5%8d%95%e4%b8%aa%e5%ad%97%e6%ae%b5&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;记录&#xA;我们把表中的每一行叫做一个“记录”，每一个记录包含这行中的所有信息，就像在&lt;a href=&#34;https://baike.baidu.com/item/%E9%80%9A%E8%AE%AF%E5%BD%95/9635277?fromModule=lemma_inlink&#34;&gt;通讯录&lt;/a&gt;数据库中某个人全部的信息，但记录在数据库中并没有专门的记录名，常常用它所在的行数表示这是第几个记录。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;字段&#xA;字段是比记录更小的单位，字段集合组成记录，每个字段描述文献的某一特征，即&lt;a href=&#34;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%A1%B9/3227309?fromModule=lemma_inlink&#34;&gt;数据项&lt;/a&gt;，并有唯一的供计算机识别的&lt;a href=&#34;https://baike.baidu.com/item/%E5%AD%97%E6%AE%B5%E6%A0%87%E8%AF%86%E7%AC%A6/53627692?fromModule=lemma_inlink&#34;&gt;字段标识符&lt;/a&gt;。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;字段名&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;表名&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250211000414373.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;别名&#34;&gt;别名&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%88%ab%e5%90%8d&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;查出来的字段名字太长, 先更换名字&#xA;可以使用 &lt;code&gt;AS&lt;/code&gt; 关键字，格式如下所示&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;字段名&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;别名&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;表名&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这通常会在多表进行联合查询或者 Java 程序端和 MySQL 表字段不一致时使用。&lt;/p&gt;&#xA;&lt;p&gt;比如说，Java 程序端的字段名是 &lt;code&gt;articleTitle&lt;/code&gt;，那我们就可以使用别名来解决这个问题。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;SELECT&lt;/span&gt; title &lt;span style=&#34;color:#ca9ee6&#34;&gt;AS&lt;/span&gt; articleTitle &lt;span style=&#34;color:#ca9ee6&#34;&gt;FROM&lt;/span&gt; article;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;查询多个字段&#34;&gt;查询多个字段&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e6%9f%a5%e8%af%a2%e5%a4%9a%e4%b8%aa%e5%ad%97%e6%ae%b5&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;有时候我们需要同时拿到多个字段&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;字段&lt;/span&gt;&lt;span style=&#34;color:#ef9f76&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#e78284&#34;&gt;字段&lt;/span&gt;&lt;span style=&#34;color:#ef9f76&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#e78284&#34;&gt;字段&lt;/span&gt;&lt;span style=&#34;color:#ef9f76&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;表名&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;查询所有字段&#34;&gt;查询所有字段&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e6%9f%a5%e8%af%a2%e6%89%80%e6%9c%89%e5%ad%97%e6%ae%b5&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;了解&#xA;&lt;a href=&#34;%E9%80%9A%E9%85%8D%E7%AC%A6.md&#34;&gt;通配符&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;表名&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;查询结果去重&#34;&gt;查询结果去重&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e6%9f%a5%e8%af%a2%e7%bb%93%e6%9e%9c%e5%8e%bb%e9%87%8d&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;有可能多个记录会有相同的字段值, 这很正常&#xA;懒得一个个分辨可以去重&#xA;使用 &lt;code&gt;DISTINCT&lt;/code&gt; 关键字进行查询&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;DISTINCT&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;字段名&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;表名&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;查询结果排序&#34;&gt;查询结果排序&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e6%9f%a5%e8%af%a2%e7%bb%93%e6%9e%9c%e6%8e%92%e5%ba%8f&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;当结果集中需要排序时，可以使用 &lt;code&gt;ORDER BY&lt;/code&gt; 关键字进行查询，格式如下所示：&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL数据类型</title>
      <link>http://localhost:51674/docs/basic/mysql/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/mysql/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>&lt;p&gt;表是由不同数据类型的列组成的，然后填充了一行一行的数据。当我们要创建表的时候，就要根据业务需求，选择合适的数据类型。&lt;/p&gt;&#xA;&lt;h4 id=&#34;整数类型&#34;&gt;整数类型&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e6%95%b4%e6%95%b0%e7%b1%bb%e5%9e%8b&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;类型名称&lt;/th&gt;&#xA;          &lt;th&gt;存储空间&lt;/th&gt;&#xA;          &lt;th&gt;范围&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;tinyint&lt;/td&gt;&#xA;          &lt;td&gt;1 字节&lt;/td&gt;&#xA;          &lt;td&gt;-128 到 127 或者 0 到 255&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;int&lt;/td&gt;&#xA;          &lt;td&gt;4 字节&lt;/td&gt;&#xA;          &lt;td&gt;-2147483648 到 2147483647 或者 0 到 4294967295&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;bigint&lt;/td&gt;&#xA;          &lt;td&gt;8 字节&lt;/td&gt;&#xA;          &lt;td&gt;-9223372036854775808 到 9223372036854775807 或者 0 到 18446744073709551615&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;其实还有个 2 字节的 smallint 但是不常用&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;设计表时&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于状态\类型字段使用 &lt;code&gt;tinyint&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;记录id, 主键id等使用 &lt;code&gt;bigint&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;其他用&lt;code&gt;int&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;符号&#34;&gt;符号?&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%ac%a6%e5%8f%b7&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h5&gt;&#xD;&#xA;&lt;p&gt;这里注意, MySQL是存在有/无符号整型之分的, Java默认有符号&lt;/p&gt;&#xA;&lt;p&gt;当涉及到负数表示时, 为了兼容, Java中必须使用&lt;code&gt;Long&lt;/code&gt; 型&lt;/p&gt;&#xA;&lt;p&gt;因为Java的&lt;code&gt;int&lt;/code&gt;范围和MySQL不同分别是-2147483648 到 2147483647, 和 0 到 4294967295(无符号)&lt;/p&gt;&#xA;&lt;p&gt;所以在设计表时, 整数的符号也要考虑&lt;/p&gt;&#xA;&lt;p&gt;像自增 ID，肯定是无符号的，所以我们会在定义的时候将其设置为 &lt;code&gt;unsigned&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL条件查询</title>
      <link>http://localhost:51674/docs/basic/mysql/mysql%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/mysql/mysql%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/</guid>
      <description>&lt;p&gt;SELECT 查询没有查询条件。比如只返回姓名为xx的人, 年龄为xx的人等条件&lt;/p&gt;&#xA;&lt;p&gt;要知道，真实的业务场景中，数量会非常大，有些甚至会有几百万、几千万条数据，如果不带上查询条件，一次性把全部数据查出来是不太现实的。&lt;/p&gt;&#xA;&lt;p&gt;所以，我们通常要求在执行 SELECT 查询时，都要带上查询条件。那这一节，我们就来学习一些简单的 WHERE 条件查询。&lt;/p&gt;&#xA;&lt;h4 id=&#34;查询操作符&#34;&gt;查询操作符&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e6%9f%a5%e8%af%a2%e6%93%8d%e4%bd%9c%e7%ac%a6&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;操作符&lt;/th&gt;&#xA;          &lt;th&gt;示例&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;=&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;user_id = 1&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;等于&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;!=&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;user_id != 1&lt;/code&gt; 或 &lt;code&gt;user_id &amp;lt;&amp;gt; 1&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;不等于&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;user_id &amp;gt; 1&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;大于&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;user_id &amp;lt; 1&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;小于&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;user_id &amp;gt;= 1&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;大于等于&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;user_id &amp;lt;= 1&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;小于等于&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;示例:&#xA;查找id大于1000的文章&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;SELECT&lt;/span&gt; title, user_id, create_time &lt;span style=&#34;color:#ca9ee6&#34;&gt;FROM&lt;/span&gt; article &lt;span style=&#34;color:#ca9ee6&#34;&gt;WHERE&lt;/span&gt; user_id &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ef9f76&#34;&gt;1000&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;区间查询&#34;&gt;区间查询&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%8c%ba%e9%97%b4%e6%9f%a5%e8%af%a2&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;利用一个 &lt;code&gt;&amp;gt;=&lt;/code&gt; 和一个 &lt;code&gt;&amp;lt;=&lt;/code&gt;，配合 &lt;code&gt;AND&lt;/code&gt; 关键字，就可以实现区间查询&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;字段名&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;表&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;WHERE&lt;/span&gt; user_id &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ef9f76&#34;&gt;1000&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;AND&lt;/span&gt; user_id &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ef9f76&#34;&gt;2000&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查询上下界id为1000 到 2000 的文章&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL索引</title>
      <link>http://localhost:51674/docs/basic/mysql/mysql%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/mysql/mysql%E7%B4%A2%E5%BC%95/</guid>
      <description>&lt;h4 id=&#34;索引介绍&#34;&gt;索引介绍&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%b4%a2%e5%bc%95%e4%bb%8b%e7%bb%8d&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;我们知道一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，所以查询语句的优化显然是重中之重。&lt;/p&gt;&#xA;&lt;p&gt;**索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。通过存储指向数据行的指针，可以快速定位和访问表中的特定数据。&lt;/p&gt;&#xA;&lt;p&gt;开始之前, 我们直观的体会下索引&lt;/p&gt;&#xA;&lt;p&gt;如果要查询 mysql 单词, 我们就需要字符匹配, 首先是 m, y 之后是 s,q l&#xA;在接近上万条的记录中我们需要把整个表过一遍, 天哪&#xA;因此索引的目的就是为了缩小搜索范围来获取想要的数据结果&#xA;很容易想到将表分段, 通过确定某个分段的方式来获取数据&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;了解:&#xA;&lt;a href=&#34;%E9%82%A3%E4%BA%9B%E7%88%B1%E8%BF%87%E7%9A%84%E6%A0%91,%E5%B7%B2%E7%BB%8F%E9%95%BF%E6%88%90%E4%BA%86%E6%A3%AE%E6%9E%97.md&#34;&gt;数据结构-树&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;索引的类型&#34;&gt;索引的类型&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%b4%a2%e5%bc%95%e7%9a%84%e7%b1%bb%e5%9e%8b&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;h5 id=&#34;主键索引&#34;&gt;主键索引:&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%b8%bb%e9%94%ae%e7%b4%a2%e5%bc%95&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h5&gt;&#xD;&#xA;&lt;p&gt;数据表的主键列使用的就是主键索引。&lt;/p&gt;&#xA;&lt;p&gt;一张数据表只能有一个主键, 并且不能重复, 不能为NULL&lt;/p&gt;&#xA;&lt;p&gt;INNODB中, 引擎在没有显示指定主键的情况下, 会优先判断检查是否有唯一索引且没有NULL的字段, 如果有就选择该字段为默认的主键, 否则引擎自动创建一个自增主键&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL表操作</title>
      <link>http://localhost:51674/docs/basic/mysql/mysql%E8%A1%A8%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/mysql/mysql%E8%A1%A8%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</guid>
      <description>&lt;p&gt;有了数据库以后，我们就可以在数据库中对表进行增删改查了&lt;/p&gt;&#xA;&lt;p&gt;MySQL是关系型数据库, 这个名词通俗来说就是把世界上的一切物体都实体化, 通过属性之间的关系管理数据&lt;/p&gt;&#xA;&lt;p&gt;实体化的结果叫做表, 数据库中以表为组织单位存储数据&lt;/p&gt;&#xA;&lt;h4 id=&#34;查表&#34;&gt;查表&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e6%9f%a5%e8%a1%a8&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;首先指定数据库&lt;/p&gt;&#xA;&lt;p&gt;查看当前数据库中的所有表，可以使用 &lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;show tables&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;不首先指定数据库的话&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;show tables from 数据库名;&lt;/code&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;提示:&#xA;这是查看表名的操作, 跟表结构没关系&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;建表&#34;&gt;建表&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%bb%ba%e8%a1%a8&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;create&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;表名&lt;/span&gt;(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;列名&lt;/span&gt;&lt;span style=&#34;color:#ef9f76&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;数据类型&lt;/span&gt;&lt;span style=&#34;color:#ef9f76&#34;&gt;1&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;列名&lt;/span&gt;&lt;span style=&#34;color:#ef9f76&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;数据类型&lt;/span&gt;&lt;span style=&#34;color:#ef9f76&#34;&gt;2&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;列名&lt;/span&gt;n &lt;span style=&#34;color:#e78284&#34;&gt;数据类型&lt;/span&gt;n&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;了解:&#xA;&lt;a href=&#34;http://localhost:51674/docs/basic/mysql/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/&#34;&gt;MySQL数据类型&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;这里可能会遇到问题&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210235135096.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;指示表已经存在了, 这时只能删掉以前的表&#xA;为了避免这种情况，我们可以在建表的时候，先判断表是否存在，如果不存在，再创建表，语法如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;create&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;exists&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;表名&lt;/span&gt;(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;列名&lt;/span&gt;&lt;span style=&#34;color:#ef9f76&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;数据类型&lt;/span&gt;&lt;span style=&#34;color:#ef9f76&#34;&gt;1&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;列名&lt;/span&gt;&lt;span style=&#34;color:#ef9f76&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;数据类型&lt;/span&gt;&lt;span style=&#34;color:#ef9f76&#34;&gt;2&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;列名&lt;/span&gt;n &lt;span style=&#34;color:#e78284&#34;&gt;数据类型&lt;/span&gt;n&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;注释&#34;&gt;注释&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e6%b3%a8%e9%87%8a&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;是的, 表也有注释, 在上百张表的情况下, 注释就很重要了&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;create&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;表名&lt;/span&gt;(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;列名&lt;/span&gt;&lt;span style=&#34;color:#ef9f76&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;数据类型&lt;/span&gt;&lt;span style=&#34;color:#ef9f76&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;comment&lt;/span&gt; &lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#39;注释1&amp;#39;&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;列名&lt;/span&gt;&lt;span style=&#34;color:#ef9f76&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;数据类型&lt;/span&gt;&lt;span style=&#34;color:#ef9f76&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;comment&lt;/span&gt; &lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#39;注释2&amp;#39;&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;列名&lt;/span&gt;n &lt;span style=&#34;color:#e78284&#34;&gt;数据类型&lt;/span&gt;n &lt;span style=&#34;color:#ca9ee6&#34;&gt;comment&lt;/span&gt; &lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#39;注释n&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) &lt;span style=&#34;color:#ca9ee6&#34;&gt;comment&lt;/span&gt; &lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#39;表注释&amp;#39;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;查看表结构&#34;&gt;查看表结构&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e6%9f%a5%e7%9c%8b%e8%a1%a8%e7%bb%93%e6%9e%84&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;desc&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;表名&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;describe&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;表名&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;explain&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;表名&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;show&lt;/span&gt; columns &lt;span style=&#34;color:#ca9ee6&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;表名&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;show&lt;/span&gt; fields &lt;span style=&#34;color:#ca9ee6&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;表名&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述指令效果完全一样&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL连接</title>
      <link>http://localhost:51674/docs/basic/mysql/mysql%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/mysql/mysql%E8%BF%9E%E6%8E%A5/</guid>
      <description>&lt;p&gt;在前几章节中，我们已经学会了如何在一张表中读取数据，这是相对简单的，但是在真正的应用中经常需要从多个数据表中读取数据。&lt;/p&gt;&#xA;&lt;p&gt;连接分为三种 内,  左, 右&lt;/p&gt;&#xA;&lt;h4 id=&#34;内连接&#34;&gt;内连接&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%86%85%e8%bf%9e%e6%8e%a5&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;INNER JOIN 返回两个表中满足连接条件的匹配行，以下是 INNER JOIN 语句的基本语法&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;SELECT&lt;/span&gt; column1, column2, ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;FROM&lt;/span&gt; table1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;INNER&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;JOIN&lt;/span&gt; table2 &lt;span style=&#34;color:#ca9ee6&#34;&gt;ON&lt;/span&gt; table1.&lt;span style=&#34;color:#ca9ee6&#34;&gt;column_name&lt;/span&gt; &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; table2.&lt;span style=&#34;color:#ca9ee6&#34;&gt;column_name&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;table1.column_name = table2.column_name&lt;/code&gt; 是连接条件，指定了两个表中用于匹配的列。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;左连接&#34;&gt;左连接&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%b7%a6%e8%bf%9e%e6%8e%a5&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;LEFT JOIN 返回左表的所有行，并包括右表中匹配的行，如果右表中没有匹配的行，将返回 NULL 值，以下是 LEFT JOIN 语句的基本语法：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;SELECT&lt;/span&gt; column1, column2, ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;FROM&lt;/span&gt; table1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;LEFT&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;JOIN&lt;/span&gt; table2 &lt;span style=&#34;color:#ca9ee6&#34;&gt;ON&lt;/span&gt; table1.&lt;span style=&#34;color:#ca9ee6&#34;&gt;column_name&lt;/span&gt; &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; table2.&lt;span style=&#34;color:#ca9ee6&#34;&gt;column_name&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;返回左表的所有行, 如果右表没有匹配就为NULL&lt;/p&gt;&#xA;&lt;h4 id=&#34;右连接&#34;&gt;右连接&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%8f%b3%e8%bf%9e%e6%8e%a5&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;不常使用, 因为可以用左连接交换表顺序达到相同效果&lt;/p&gt;</description>
    </item>
    <item>
      <title>ReentrantLock重入锁</title>
      <link>http://localhost:51674/docs/basic/concurrent/reentrantlock%E9%87%8D%E5%85%A5%E9%94%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/concurrent/reentrantlock%E9%87%8D%E5%85%A5%E9%94%81/</guid>
      <description>&lt;h4 id=&#34;重入性&#34;&gt;重入性&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e9%87%8d%e5%85%a5%e6%80%a7&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;重入性指当线程需要再次获取同一把锁时, 不会因为自身而造成死锁, 锁的本质是&lt;strong&gt;作用于代码块或方法&lt;/strong&gt;，而不是线程的整个执行上下文。即使线程已经持有锁，进入新的同步方法或代码块时，仍然需要执行&lt;strong&gt;获取锁&lt;/strong&gt;的操作，确保锁的计数正确。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250209113038176.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;所以支持重入性应该解决下列问题&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由于获得多次相同的锁, 需要计数以释放相同次数&lt;/li&gt;&#xA;&lt;li&gt;相同线程再次获取锁应当直接成功, 防止死锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;为什么需要reentrantlock&#34;&gt;为什么需要&lt;code&gt;ReentrantLock&lt;/code&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81reentrantlock&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;Java语言直接提供了&lt;code&gt;synchronized&lt;/code&gt;关键字用于加锁，但这种锁一是很重，二是获取时必须一直等待，没有额外的尝试机制。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;if&lt;/span&gt; (lock.&lt;span style=&#34;color:#8caaee&#34;&gt;tryLock&lt;/span&gt;(1, TimeUnit.&lt;span style=&#34;color:#8caaee&#34;&gt;SECONDS&lt;/span&gt;)) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ca9ee6&#34;&gt;try&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#ca9ee6&#34;&gt;finally&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        lock.&lt;span style=&#34;color:#8caaee&#34;&gt;unlock&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;java.util.concurrent.locks&lt;/code&gt;包提供的&lt;code&gt;ReentrantLock&lt;/code&gt;用于替代&lt;code&gt;synchronized&lt;/code&gt;加锁&lt;/p&gt;&#xA;&lt;p&gt;尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，&lt;code&gt;tryLock()&lt;/code&gt;返回&lt;code&gt;false&lt;/code&gt;，程序就可以做一些额外处理，而不是无限等待下去。&lt;/p&gt;&#xA;&lt;p&gt;所以，使用&lt;code&gt;ReentrantLock&lt;/code&gt;比直接使用&lt;code&gt;synchronized&lt;/code&gt;更安全，线程在&lt;code&gt;tryLock()&lt;/code&gt;失败的时候不会导致死锁。&lt;/p&gt;&#xA;&lt;h1 id=&#34;reentrantlock使用&#34;&gt;ReentrantLock使用&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#reentrantlock%e4%bd%bf%e7%94%a8&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h1&gt;&#xD;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#e5c890&#34;&gt;Counter&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//和关键字不同, 需要获得一个重入锁对象&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;final&lt;/span&gt; Lock lock &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; ReentrantLock();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; count;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; n) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//代码块加锁&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        lock.&lt;span style=&#34;color:#8caaee&#34;&gt;lock&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ca9ee6&#34;&gt;try&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            count &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;+=&lt;/span&gt; n;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#ca9ee6&#34;&gt;finally&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;        &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//在finally中解锁&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            lock.&lt;span style=&#34;color:#8caaee&#34;&gt;unlock&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>synchronized关键字</title>
      <link>http://localhost:51674/docs/basic/concurrent/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/concurrent/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;在 Java 中，关键字 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)&#xA;synchronized 的另外一个重要的作用，synchronized 可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;synchronized 关键字最主要有以下 3 种应用方式：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同步方法，为当前对象加锁，进入同步代码前要获得当前对象的锁；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#e5c890&#34;&gt;AccountingSync&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;implements&lt;/span&gt; Runnable {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//共享资源(临界资源)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;// synchronized 同步方法&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;increase&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        i &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8caaee;font-weight:bold&#34;&gt;@Override&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;run&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ca9ee6&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; j&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;0;j&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;1000000;j&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;++&lt;/span&gt;){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            increase();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;main&lt;/span&gt;(String args&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;[]&lt;/span&gt;) &lt;span style=&#34;color:#e78284&#34;&gt;throws&lt;/span&gt; InterruptedException {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        AccountingSync instance &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; AccountingSync();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Thread t1 &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; Thread(instance);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Thread t2 &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; Thread(instance);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t1.&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t2.&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t1.&lt;span style=&#34;color:#8caaee&#34;&gt;join&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t2.&lt;span style=&#34;color:#8caaee&#34;&gt;join&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#8caaee&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#8caaee&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;static, i output:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;+&lt;/span&gt; i);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;同步静态方法，为当前类加锁，进入同步代码前要获得当前类的锁；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#e5c890&#34;&gt;AccountingSyncClass&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;implements&lt;/span&gt; Runnable {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;     * 同步静态方法,锁是当前class对象，也就是&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;     * AccountingSyncClass类对应的class对象&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;     */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;increase&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        i&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;// 非静态,访问时锁不一样不会发生互斥&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;increase4Obj&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        i&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8caaee;font-weight:bold&#34;&gt;@Override&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;run&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ca9ee6&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; j&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;0;j&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;1000000;j&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;++&lt;/span&gt;){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            increase();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;[]&lt;/span&gt; args) &lt;span style=&#34;color:#e78284&#34;&gt;throws&lt;/span&gt; InterruptedException {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//new新实例&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Thread t1&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; Thread(&lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; AccountingSyncClass());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//new新实例&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Thread t2&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; Thread(&lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; AccountingSyncClass());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//启动线程&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t1.&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();t2.&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t1.&lt;span style=&#34;color:#8caaee&#34;&gt;join&lt;/span&gt;();t2.&lt;span style=&#34;color:#8caaee&#34;&gt;join&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#8caaee&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#8caaee&#34;&gt;println&lt;/span&gt;(i);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt; * 输出结果:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt; * 2000000&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt; */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;同步代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#e5c890&#34;&gt;AccountingSync2&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;implements&lt;/span&gt; Runnable {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; AccountingSync2 instance &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; AccountingSync2(); &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;// 饿汉单例模式&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8caaee;font-weight:bold&#34;&gt;@Override&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;run&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//省略其他耗时操作....&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//使用同步代码块对变量i进行同步操作,锁对象为instance&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e78284&#34;&gt;synchronized&lt;/span&gt;(instance){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ca9ee6&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; j&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;0;j&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;1000000;j&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;++&lt;/span&gt;){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                i&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;[]&lt;/span&gt; args) &lt;span style=&#34;color:#e78284&#34;&gt;throws&lt;/span&gt; InterruptedException {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Thread t1&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; Thread(instance);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Thread t2&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; Thread(instance);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t1.&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();t2.&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t1.&lt;span style=&#34;color:#8caaee&#34;&gt;join&lt;/span&gt;();t2.&lt;span style=&#34;color:#8caaee&#34;&gt;join&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#8caaee&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#8caaee&#34;&gt;println&lt;/span&gt;(i);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;这里的锁指的是 Java 内置的隐式锁 monitor 也是 &lt;code&gt;synchronized&lt;/code&gt; 封装好的实现&#xA;每个对象都有一个对象锁，不同的对象，他们的锁不会互相影响。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ThreadLocal</title>
      <link>http://localhost:51674/docs/basic/concurrent/threadlocal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/concurrent/threadlocal/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;前置&#xA;&lt;a href=&#34;http://localhost:51674/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0/&#34;&gt;线程池&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;是 Java 中提供的一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离，用于解决多线程中共享对象的线程安全问题。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210182243836.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;使用:&lt;/p&gt;&#xA;&lt;p&gt;创建 ThreadLocal对象&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//创建一个ThreadLocal变量&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; ThreadLocal&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; localVariable &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; ThreadLocal&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;设置值&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//设置ThreadLocal变量的值 localVariable.set(&amp;#34;0001&amp;#34;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;获取值&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//获取ThreadLocal变量的值 String value = localVariable.get();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;优点&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;线程隔离&#xA;实现了变量的独占, 使变量不需要同步处理&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数据传递方便&#xA;ThreadLocal 常用于在跨方法、跨类时传递上下文数据（如用户信息等），而不需要在方法间传递参数。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;threadlocalmap&#34;&gt;&lt;code&gt;ThreadLocalMap&lt;/code&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#threadlocalmap&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;ThreadLocalMap, 一个key-value数据形式结构，也是ThreadLocal的核心。&lt;/p&gt;&#xA;&lt;p&gt;Map内部维护了一个Entry数组, 真正的数据存储在 Entry中, map的key是每个线程中ThreadLocal对象的哈希, value是隔离变量&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;&#x9; * 初始容量&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;&#x9; */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; INITIAL_CAPACITY &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; 16;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;&#x9; * ThreadLocalMap数据真正存储在table中&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;&#x9; */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; Entry&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;[]&lt;/span&gt; table;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;&#x9; * ThreadLocalMap条数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;&#x9; */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; size &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;&#x9; * 达到这个大小，则扩容&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;&#x9; */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; threshold; &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;// 默认为0&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210192010058.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>volatile关键字</title>
      <link>http://localhost:51674/docs/basic/concurrent/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/concurrent/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>&lt;h4 id=&#34;什么是-volatile&#34;&gt;什么是 &lt;code&gt;volatile&lt;/code&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af-volatile&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;h4 id=&#34;为什么要使用-volatile&#34;&gt;为什么要使用 &lt;code&gt;volatile&lt;/code&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8-volatile&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;[[线程安全问题]]&lt;/p&gt;&lt;/blockquote&gt;</description>
    </item>
    <item>
      <title>事务</title>
      <link>http://localhost:51674/docs/basic/mysql/%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/mysql/%E4%BA%8B%E5%8A%A1/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;引用:&#xA;go语言大佬, go语言设计与原理作者&#xA;[面向信仰编程 - draveness](&lt;a href=&#34;https://draveness.me/mysql-innodb/&#34;&gt;https://draveness.me/mysql-innodb/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;在关系型数据库中，事务的重要性不言而喻，只要对数据库稍有了解的人都知道事务具有 ACID 四个基本属性，&lt;/p&gt;&#xA;&lt;p&gt;而我们不知道的可能就是数据库是如何实现这四个属性的；在这篇文章中，我们将对事务的实现进行分析，尝试理解数据库是如何实现事务的，当然我们也会在文章中简单对 MySQL 中对 ACID 的实现进行简单的介绍。&lt;/p&gt;&#xA;&lt;p&gt;原子性, 一致性, 隔离性, 持久性&#xA;ACID&lt;/p&gt;&#xA;&lt;h4 id=&#34;原子性&#34;&gt;原子性&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%8e%9f%e5%ad%90%e6%80%a7&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;事务就是一系列的操作，要么全部都执行，要都不执行，这其实就是对事务原子性的刻画&lt;/p&gt;&#xA;&lt;p&gt;如果事务不具备原子性，那么就没办法保证同一个事务中的所有操作都被执行或者未被执行了，整个数据库系统就既不可用也不可信。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;数据库的事务提交也是多线程并发的, 适用并发编程&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;持久性&#34;&gt;持久性&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e6%8c%81%e4%b9%85%e6%80%a7&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250211011722492.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;数据被写入到数据库中，那么数据一定能够被安全存储在磁盘上, 这就是持久性&lt;/p&gt;&#xA;&lt;p&gt;可能会奇怪, 除非硬盘挂掉, 为什么会存在持久性问题呢&lt;/p&gt;&#xA;&lt;p&gt;其实持久性并非问题, 而是一种原则&lt;/p&gt;&#xA;&lt;p&gt;一旦事务被提交，那么数据一定会被写入到数据库中并持久存储起来。&#xA;也就是当数据被写到硬盘后, 不允许撤销!&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;当事务已经被提交之后，就无法再次回滚了，唯一能够撤回已经提交的事务的方式就是创建一个相反的事务对原操作进行『补偿』，这也是事务持久性的体现之一。&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;隔离性&#34;&gt;隔离性&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e9%9a%94%e7%a6%bb%e6%80%a7&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;数据库的事务之间没有隔离性, 就会发生级联回滚的问题, 造成性能上的巨大损失&lt;/p&gt;&#xA;&lt;p&gt;如果所有的事务的执行顺序都是线性的，那么对于事务的管理容易得多，但是允许事务的并行执行却能能够提升吞吐量和资源利用率，并且可以减少每个事务的等待时间。&lt;/p&gt;&#xA;&lt;h4 id=&#34;一致性&#34;&gt;一致性&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%b8%80%e8%87%b4%e6%80%a7&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;分为两种一致性&lt;/p&gt;&#xA;&lt;p&gt;ACID 和 CAP&lt;/p&gt;&#xA;&lt;p&gt;其中ACID定义为, 如果事务原子性的一个一致的数据库中独立运行, 那么执行之后数据库的状态是一定的, 在事务的执行的前后以及过程中不会违背对数据完整性的约束, 所有对数据库写入的操作都应该是合法的，并不能产生不合法的数据状态。&lt;/p&gt;&#xA;&lt;p&gt;CAP则是通常的一致性, 其实是说分布式系统中的各个节点中对于同一数据的拷贝有着相同的值, 也就是存储可见性&lt;/p&gt;</description>
    </item>
    <item>
      <title>多线程入门</title>
      <link>http://localhost:51674/docs/basic/concurrent/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/concurrent/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;h4 id=&#34;为什么要实现多线程&#34;&gt;为什么要实现多线程?&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%ae%9e%e7%8e%b0%e5%a4%9a%e7%ba%bf%e7%a8%8b&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;[!前置]&#xA;&lt;a href=&#34;http://localhost:51674/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/&#34;&gt;线程与进程&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;进程使得操作系统可以&lt;a href=&#34;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7.md&#34;&gt;并发&lt;/a&gt;的执行任务&#xA;但是在一段时间内单个进程只能执行一个任务&#xA;进程内的子任务只能逐个按顺序执行, 效率还有提升空间&lt;/p&gt;&#xA;&lt;p&gt;因此提出线程概念, 使得一个线程可以执行一个子任务使得进程内部也可实现并发, 提高效率&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;[!NOTE]&#xA;多线程的优势&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信很容易。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;进程是重量级的，而线程是轻量级的，多线程方式的系统开销更小。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;Java中创建线程的三种方式&lt;/p&gt;&#xA;&lt;h4 id=&#34;继承-thread-类&#34;&gt;继承 &lt;code&gt;Thread&lt;/code&gt; 类&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%bb%a7%e6%89%bf-thread-%e7%b1%bb&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;重写 &lt;code&gt;run&lt;/code&gt; 方法&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#e5c890&#34;&gt;MyThread&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;extends&lt;/span&gt; Thread {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8caaee;font-weight:bold&#34;&gt;@Override&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;run&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ca9ee6&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt; 100; i&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            System.&lt;span style=&#34;color:#8caaee&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#8caaee&#34;&gt;println&lt;/span&gt;(getName() &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;:打了&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;+&lt;/span&gt; i &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;个小兵&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;主函数启动线程&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//创建MyThread对象&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;MyThread t1&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; MyThread();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;MyThread t2&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; MyThread();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;MyThread t3&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; MyThread();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//设置线程的名字&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;t1.&lt;span style=&#34;color:#8caaee&#34;&gt;setName&lt;/span&gt;(&lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;鲁班&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;t2.&lt;span style=&#34;color:#8caaee&#34;&gt;setName&lt;/span&gt;(&lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;刘备&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;t3.&lt;span style=&#34;color:#8caaee&#34;&gt;setName&lt;/span&gt;(&lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;亚瑟&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//启动线程&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;t1.&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;t2.&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;t3.&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;实现-runnable-接口&#34;&gt;实现 &lt;code&gt;Runnable&lt;/code&gt; 接口&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%ae%9e%e7%8e%b0-runnable-%e6%8e%a5%e5%8f%a3&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;创建任务类实现 &lt;code&gt;Runnable&lt;/code&gt; 接口&lt;/p&gt;</description>
    </item>
    <item>
      <title>数据库设计规范</title>
      <link>http://localhost:51674/docs/basic/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</guid>
      <description>&lt;p&gt;数据库的三大范式，它是数据库设计中最基本的三个规范，那么，三大范式是什么？在实际开发中，我们一定要严格遵守三大范式吗？&lt;/p&gt;&#xA;&lt;h4 id=&#34;第一范式&#34;&gt;第一范式&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%ac%ac%e4%b8%80%e8%8c%83%e5%bc%8f&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;确保每列原子性&#xA;也就是字段的值是原子的, 不可再分割&lt;/p&gt;&#xA;&lt;h4 id=&#34;第二范式&#34;&gt;第二范式&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%ac%ac%e4%ba%8c%e8%8c%83%e5%bc%8f&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;确保表中的每列和主键相关&lt;/p&gt;&#xA;&lt;p&gt;第二范式在第一范式的基础上, 消除表的部分依赖&lt;/p&gt;&#xA;&lt;p&gt;即非主键字段必须完全依赖于主键，而不是仅依赖于主键的一部分。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250212002938008.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这里和订单id(主键) 有关的只有数量和商品ID&lt;/p&gt;&#xA;&lt;p&gt;拆成两张表&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250212003059979.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250212003105718.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;第三范式&#34;&gt;第三范式&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%ac%ac%e4%b8%89%e8%8c%83%e5%bc%8f&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;确保每列都与主键列直接相关, 而不是间接相关&lt;/p&gt;&#xA;&lt;p&gt;在第二范式的基础上, 消除表的传递依赖&lt;/p&gt;&#xA;&lt;p&gt;所有非主键字段必须直接依赖于主键，而不是通过其他非主键字段间接依赖。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250212004058261.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在这个表中，&lt;code&gt;部门名称&lt;/code&gt;依赖于&lt;code&gt;部门ID&lt;/code&gt;，而&lt;code&gt;部门ID&lt;/code&gt;依赖于主键&lt;code&gt;员工ID&lt;/code&gt;，形成了传递依赖，违反了3NF。&lt;/p&gt;</description>
    </item>
    <item>
      <title>线程</title>
      <link>http://localhost:51674/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</guid>
      <description>&lt;p&gt;进程&#xA;说简单点就是我们在电脑上启动的一个个应用。它是操作系统分配资源的最小单位。&lt;/p&gt;&#xA;&lt;p&gt;线程&#xA;是进程的子任务，是 CPU 调度和分派的基本单位，实现了进程内部的并发。&lt;/p&gt;&#xA;&lt;h4 id=&#34;线程与进程&#34;&gt;线程与进程&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e4%b8%8e%e8%bf%9b%e7%a8%8b&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;线程，是进程的子任务，是进程中的独立执行单元。多个线程可以共享同一个进程的资源，如内存；每个线程都有自己独立的栈和寄存器。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205083709918.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;并发环境下, 多线程存在下述问题&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;线程之间如何确保执行顺序,实现线程之间的协调与合作? 线程通信&lt;/li&gt;&#xA;&lt;li&gt;线程之间如何确保对临界资源修改不会冲突? 线程同步?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;线程通信线程通信md&#34;&gt;&lt;a href=&#34;http://localhost:51674/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/&#34;&gt;线程通信&lt;/a&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e9%80%9a%e4%bf%a1%e7%ba%bf%e7%a8%8b%e9%80%9a%e4%bf%a1md&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;Inter-thread communication in Java is a mechanism in which a thread is paused running in its critical section and another thread is allowed to enter (or lock) in the same critical section to be executed.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;线程间通信&lt;/strong&gt;&#xA;是一种机制，使得线程能够在执行时进行协作，通常用于解决某些线程需要等待其他线程完成任务的情况。它主要涉及线程之间的等待和通知机制，而不是同一临界区内的互斥访问。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;线程同步&#34;&gt;线程同步&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e5%90%8c%e6%ad%a5&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;Synchronization&lt;/strong&gt; is crucial for ensuring that multiple threads operate safely on shared resources. Without *&lt;strong&gt;Synchronization&lt;/strong&gt;, data inconsistency or corruption can occur when multiple threads try to access and modify shared variables simultaneously. In Java, it is a mechanism that ensures that only one thread can access a resource at any given time&lt;/p&gt;</description>
    </item>
    <item>
      <title>线程安全问题</title>
      <link>http://localhost:51674/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;前置&#xA;&lt;a href=&#34;http://localhost:51674/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/&#34;&gt;线程与进程&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;线程安全是指, 在多线程环境下, 多个线程对共享资源进行并发访问和操作时可能出现的问题&lt;/p&gt;&#xA;&lt;h4 id=&#34;常见的线程安全问题&#34;&gt;常见的线程安全问题&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%b8%b8%e8%a7%81%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e9%97%ae%e9%a2%98&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;h5 id=&#34;可见性问题&#34;&gt;可见性问题&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%8f%af%e8%a7%81%e6%80%a7%e9%97%ae%e9%a2%98&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h5&gt;&#xD;&#xA;&lt;p&gt;确保一个线程对共享变量的修改可以立即被其他线程看到。&#xA;数据竞争&#xA;当多个线程同时访问和修改共享变量时,&#xA;没有适当的同步机制来保护数据一致性, 会导致不可预测的结果&lt;/p&gt;&#xA;&lt;p&gt;volatile 关键字可以保证了变量的修改对所有线程立即可见，并防止编译器优化导致的可见性问题。&lt;/p&gt;&#xA;&lt;h5 id=&#34;原子性问题&#34;&gt;原子性问题&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e5%8e%9f%e5%ad%90%e6%80%a7%e9%97%ae%e9%a2%98&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h5&gt;&#xD;&#xA;&lt;p&gt;确保当某个线程修改共享变量时，没有其他线程可以同时修改这个变量，即这个操作是不可分割的。&#xA;如果操作的原子性被破坏, 就会导致只有部分操作成功使得结果无法预测&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205194927449.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;原子性可以通过互斥锁（如 synchronized）或原子操作（如 AtomicInteger 类中的方法）来保证。&lt;/p&gt;&#xA;&lt;h5 id=&#34;活跃性问题&#34;&gt;活跃性问题&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e6%b4%bb%e8%b7%83%e6%80%a7%e9%97%ae%e9%a2%98&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h5&gt;&#xD;&#xA;&lt;p&gt;资源竞争&#xA;多个线程争夺有限的资源, 没有适当的同步机制会导致资源分配问题&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;死锁&#xA;两个或多个线程同时占用对方的资源且不释放, 这种情况下，线程将永久阻塞，导致程序无法继续执行&lt;/li&gt;&#xA;&lt;li&gt;饥饿&#xA;当某个线程长时间无法得到资源导致该进程无法继续执行, 会发生饥饿现象&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;引用:&#xA;&lt;a href=&#34;https://blog.csdn.net/a772304419/article/details/130979664&#34;&gt;https://blog.csdn.net/a772304419/article/details/130979664&lt;/a&gt;&#xA;&lt;a href=&#34;https://blog.csdn.net/qq_49217297/article/details/124546726&#34;&gt;https://blog.csdn.net/qq_49217297/article/details/124546726&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;</description>
    </item>
    <item>
      <title>线程池</title>
      <link>http://localhost:51674/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
      <description>&lt;h4 id=&#34;什么是线程池&#34;&gt;什么是线程池&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%bf%e7%a8%8b%e6%b1%a0&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;线程池(ThreadPool) 是一种基于池化思想管理线程的工具&lt;/p&gt;&#xA;&lt;p&gt;线程池解决的问题是, 在任意时刻下, 确定系统应该投入多少资源, 解决多少任务&lt;/p&gt;&#xA;&lt;p&gt;不将线程统一管理可能会出现以下问题&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。&lt;/li&gt;&#xA;&lt;li&gt;对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。&lt;/li&gt;&#xA;&lt;li&gt;系统无法合理管理内部的资源分布，会降低系统的稳定性。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210102309459.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;线程池内部维护了许多线程, 当有新任务时就会分配一个空闲线程执行&#xA;当所有线程都有任务时, 新的任务要么放到阻塞队列里面要么增加线程&lt;/p&gt;&#xA;&lt;h4 id=&#34;使用线程池&#34;&gt;使用线程池&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%bd%bf%e7%94%a8%e7%ba%bf%e7%a8%8b%e6%b1%a0&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;用法:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;// 创建固定大小的线程池:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ExecutorService executor &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; Executors.&lt;span style=&#34;color:#8caaee&#34;&gt;newFixedThreadPool&lt;/span&gt;(3);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;// 提交任务:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;executor.&lt;span style=&#34;color:#8caaee&#34;&gt;submit&lt;/span&gt;(task1);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;executor.&lt;span style=&#34;color:#8caaee&#34;&gt;submit&lt;/span&gt;(task2);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;executor.&lt;span style=&#34;color:#8caaee&#34;&gt;submit&lt;/span&gt;(task3);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;executor.&lt;span style=&#34;color:#8caaee&#34;&gt;submit&lt;/span&gt;(task4);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;executor.&lt;span style=&#34;color:#8caaee&#34;&gt;submit&lt;/span&gt;(task5);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述代码创建了大小为3的线程池, 并提交了5个任务&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;ExecutorService&lt;/code&gt;该接口要求实现工厂方法, 返回如下类型的线程池&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FixedThreadPool：线程数固定的线程池；&lt;/li&gt;&#xA;&lt;li&gt;CachedThreadPool：线程数根据任务动态调整的线程池；&lt;/li&gt;&#xA;&lt;li&gt;ScheduledThreadPool:  定时执行线程池&lt;/li&gt;&#xA;&lt;li&gt;SingleThreadExecutor：仅单线程执行的线程池。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;线程池原理解析&#34;&gt;线程池原理解析&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e5%8e%9f%e7%90%86%e8%a7%a3%e6%9e%90&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;Java的线程池核心实现为 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210180713994.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;顶级接口 &lt;code&gt;Excutor&lt;/code&gt; 提供了一种思想, 将任务提交与任务执行解耦&#xA;用户只需提供 &lt;code&gt;Runnable&lt;/code&gt; 对像, 将任务提交到执行器中, 剩余的线程调配和任务执行由执行器完成&lt;/p&gt;&#xA;&lt;p&gt;ExecutorService接口增加了一些能力：&#xA;（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。&lt;/p&gt;&#xA;&lt;p&gt;线程池构造类 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&#xA;通过传入参数实现线程池的构造&#xA;如下是成员变量,&#xA;![[content/en/docs/Basic/Concurrent/Pasted image 20250203123133.png]]&#xA;参数解释&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;corePoolSize&lt;/code&gt;：线程池中用来工作的核心线程数量。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;maximumPoolSize&lt;/code&gt;：最大线程数，线程池允许创建的最大线程数, 可以理解为非核心线程 + 核心线程数&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;workQueue&lt;/code&gt;：任务队列，是一个阻塞队列，当线程数达到核心线程数后，会将任务存储在阻塞队列中。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;threadFactory&lt;/code&gt; ：线程池内部创建线程所用的工厂。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;handler&lt;/code&gt;：拒绝策略；当队列已满并且线程数量达到最大线程数量时，会调用该方法处理任务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;线程池使用前记得初始化&lt;/p&gt;</description>
    </item>
    <item>
      <title>线程生命周期</title>
      <link>http://localhost:51674/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>&lt;p&gt;Java的线程分为两类, 用户线程和守护线程&lt;/p&gt;&#xA;&lt;p&gt;线程调度就是线程不同状态间的转换&lt;/p&gt;&#xA;&lt;p&gt;在&lt;a href=&#34;%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2.md&#34;&gt;操作系统&lt;/a&gt;中，线程被视为轻量级的进程，所以&lt;strong&gt;线程状态其实和进程状态是一致的&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205105116917.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Java线程有如下状态&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;// Thread.State 源码&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;enum&lt;/span&gt; State {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    NEW,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    RUNNABLE,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    BLOCKED,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    WAITING,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    TIMED_WAITING,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    TERMINATED;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;new&#34;&gt;NEW&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#new&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;处于 NEW 状态的线程是刚创建 &lt;code&gt;Thread&lt;/code&gt; 而尚未启动。这里的尚未启动指的是还没调用 Thread 实例的&lt;code&gt;start()&lt;/code&gt;方法。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;testStateNew&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Thread thread &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; Thread(() &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt; {});&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    System.&lt;span style=&#34;color:#8caaee&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#8caaee&#34;&gt;println&lt;/span&gt;(thread.&lt;span style=&#34;color:#8caaee&#34;&gt;getState&lt;/span&gt;()); &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;// 输出 NEW&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;runnable&#34;&gt;RUNNABLE&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#runnable&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;当前线程正在运行中。处于 RUNNABLE 状态的线程在 Java 虚拟机中运行，也有可能在等待 CPU 分配非IO资源。&lt;/p&gt;&#xA;&lt;p&gt;Java 线程的&lt;strong&gt;RUNNABLE&lt;/strong&gt;状态其实包括了操作系统线程的&lt;strong&gt;ready&lt;/strong&gt;和&lt;strong&gt;running&lt;/strong&gt;两个状态。&lt;/p&gt;&#xA;&lt;h4 id=&#34;block&#34;&gt;BLOCK&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#block&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;阻塞状态。处于 BLOCKED 状态的线程正等待锁（锁会在后面细讲）的释放以进入同步区。&lt;/p&gt;&#xA;&lt;h4 id=&#34;waiting&#34;&gt;WAITING&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#waiting&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;等待状态。处于等待状态的线程变成 RUNNABLE 状态需要其他线程唤醒。&lt;/p&gt;</description>
    </item>
    <item>
      <title>线程通信</title>
      <link>http://localhost:51674/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</guid>
      <description>&lt;p&gt;&lt;strong&gt;线程通信&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;是一种机制，使得线程能够在执行时进行协作，通常用于解决某些线程需要等待其他线程完成任务的情况。它主要涉及线程之间的等待和通知机制，而不是同一临界区内的互斥访问。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;线程之间传递信息有多种方式，&#xA;比如说使用共享对象、&lt;code&gt;wait()&lt;/code&gt; 和 &lt;code&gt;notify()&lt;/code&gt; 方法、Exchanger 和 &lt;code&gt;CompletableFuture&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;使用共享对象&#34;&gt;使用共享对象&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e4%bd%bf%e7%94%a8%e5%85%b1%e4%ba%ab%e5%af%b9%e8%b1%a1&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;多个线程同时访问和修改同一个对象, 从而实现信息传递&lt;/p&gt;&#xA;&lt;p&gt;比如 &lt;a href=&#34;http://localhost:51674/docs/basic/concurrent/volatile%E5%85%B3%E9%94%AE%E5%AD%97/&#34;&gt;&lt;code&gt;volatile&lt;/code&gt;&lt;/a&gt;&#xA;&lt;a href=&#34;http://localhost:51674/docs/basic/concurrent/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/&#34;&gt;&lt;code&gt;synchronized&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>自旋锁与CLH锁</title>
      <link>http://localhost:51674/docs/basic/concurrent/%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8Eclh%E9%94%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/concurrent/%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8Eclh%E9%94%81/</guid>
      <description>&lt;p&gt;在并发编程中，锁是一种常用的保证线程安全的方法。&lt;/p&gt;&#xA;&lt;p&gt;Java 中常用的锁主要有两类，一种是关键字 &lt;a href=&#34;http://localhost:51674/docs/basic/concurrent/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/&#34;&gt;synchronized&lt;/a&gt; ，被称为 Java 内置锁或监视器锁。&lt;/p&gt;&#xA;&lt;p&gt;另一种就是在 J2SE 1.5版本之后的 java.util.concurrent包（下称j.u.c包）中的各类同步器&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;包括 ReentrantLock（可重入锁），ReentrantReadWriteLock（可重入读写锁），Semaphore（信号量），CountDownLatch 等&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;这些同步器都是基于 AbstractQueuedSynchronizer（下称 AQS）这个简单的框架来构建的&lt;/p&gt;&#xA;&lt;p&gt;AQS 类的核心数据结构是一种名为 &lt;code&gt;Craig, Landin, and Hagersten locks&lt;/code&gt;（下称 CLH 锁）的变体。&lt;/p&gt;&#xA;&lt;p&gt;CLH锁是自旋锁的一种改良&lt;/p&gt;&#xA;&lt;h4 id=&#34;自旋锁&#34;&gt;自旋锁&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%e8%87%aa%e6%97%8b%e9%94%81&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;自旋锁是互斥锁的一种实现, 用于保证线程间正确互斥&lt;/p&gt;&#xA;&lt;p&gt;获取锁时，线程会对一个原子变量循环执行 &lt;code&gt;compareAndSet&lt;/code&gt; 方法，直到该方法返回成功时即为成功获取锁&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;compareAndSet&lt;/code&gt; 方法底层由[[CAS(compare-and-swap)]]实现&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;![[content/en/docs/Basic/Concurrent/Pasted image 20250203201648.png]]&lt;/p&gt;&#xA;&lt;p&gt;自旋锁减少了线程上下文开销, 减缓了频繁的&lt;a href=&#34;http://localhost:51674/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92/&#34;&gt;线程挂起操作&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;但是该锁有很严重的缺点&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;饥饿问题, 竞争激烈下, 可能有线程一直得不到锁&lt;/li&gt;&#xA;&lt;li&gt;性能问题, 长时间自旋并且由于锁状态变更需要修改状态变量, 导致CPU的高速缓存在线程间频繁同步, 很消耗CPU&#xA;![[content/en/docs/Basic/Concurrent/Pasted image 20250203202833.png]]&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;clh锁&#34;&gt;CLH锁&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#clh%e9%94%81&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://localhost:51674/docs/basic/concurrent/volatile%E5%85%B3%E9%94%AE%E5%AD%97/&#34;&gt;volatile关键字&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;这是对自旋锁的改进版本&#xA;主要针对上述两个缺点做了改进&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;饥饿问题, 将线程组织为队列, 先来先服务, 防止饥饿问题&lt;/li&gt;&#xA;&lt;li&gt;去中心化, 不在使用单独的锁状态变量, 而是在每个线程内维护一个状态变量, 后继线程监视前继线程的状态即可&#xA;CLH 锁数据结构很简单，类似一个链表队列，所有请求获取锁的线程会排列在链表队列中，自旋访问队列中前一个节点的状态。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;![[content/en/docs/Basic/Concurrent/Pasted image 20250203203420.png]]&lt;/p&gt;</description>
    </item>
    <item>
      <title>获取线程执行结果</title>
      <link>http://localhost:51674/docs/basic/concurrent/%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/concurrent/%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;Java 1.5 提供了 Callable、Future、FutureTask，它们可以在任务执行完后得到执行结果, 可以实现业务之间的并发执行与返回&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;在[[多线程入门]] 我们讲述了创建线程实现任务并发的 3 种方式，&#xA;直接继承 &lt;code&gt;Thread&lt;/code&gt;&#xA;实现 &lt;code&gt;Runnable&lt;/code&gt; 接口&#xA;实现 &lt;code&gt;Callable&amp;lt;&amp;gt;&lt;/code&gt; 接口&lt;/p&gt;&#xA;&lt;p&gt;前 2 种方式都有一个缺陷：在执行完任务之后无法获取执行结果。这对需要前置任务返回值的线程来说很重要&lt;/p&gt;&#xA;&lt;p&gt;Java 1.5 提供了 Callable、Future、FutureTask，它们可以在任务执行完后得到执行结果&lt;/p&gt;&#xA;&lt;h4 id=&#34;callable&#34;&gt;Callable&amp;lt;&amp;gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#callable&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;&lt;code&gt;callable&lt;/code&gt; 源码如下&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#e5c890&#34;&gt;Callable&lt;/span&gt;&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;V&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    V &lt;span style=&#34;color:#8caaee&#34;&gt;call&lt;/span&gt;() &lt;span style=&#34;color:#e78284&#34;&gt;throws&lt;/span&gt; Exception;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到 &lt;code&gt;call()&lt;/code&gt; 方法返回值为泛型 V&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;而 &lt;code&gt;Callable&amp;lt;&amp;gt;&lt;/code&gt; 允许返回值的一个任务&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Runnable&lt;/code&gt; 接口代表一个可以由线程执行的任务, 实现 &lt;code&gt;Runnable&lt;/code&gt; 而不是 &lt;code&gt;callable&lt;/code&gt; 主要是线程池的兼容性考虑&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;future-异步计算结果接口&#34;&gt;&lt;code&gt;Future&lt;/code&gt; 异步计算结果接口&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#future-%e5%bc%82%e6%ad%a5%e8%ae%a1%e7%ae%97%e7%bb%93%e6%9e%9c%e6%8e%a5%e5%8f%a3&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;&lt;code&gt;Future&lt;/code&gt; 表示异步计算的结果，提供了用于检查计算是否完成、等待计算完成、以及检索计算结果的方法。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;Future&lt;/code&gt; 接口的设计目标是允许任务在一个线程中执行，并且可以返回执行结果或抛出异常&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#e5c890&#34;&gt;Future&lt;/span&gt;&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;V&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;cancel&lt;/span&gt;(&lt;span style=&#34;color:#e78284&#34;&gt;boolean&lt;/span&gt; mayInterruptIfRunning);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;isCancelled&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e78284&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;isDone&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    V &lt;span style=&#34;color:#8caaee&#34;&gt;get&lt;/span&gt;() &lt;span style=&#34;color:#e78284&#34;&gt;throws&lt;/span&gt; InterruptedException, ExecutionException;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    V &lt;span style=&#34;color:#8caaee&#34;&gt;get&lt;/span&gt;(&lt;span style=&#34;color:#e78284&#34;&gt;long&lt;/span&gt; timeout, TimeUnit unit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e78284&#34;&gt;throws&lt;/span&gt; InterruptedException, ExecutionException, TimeoutException;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;取消任务；&lt;/li&gt;&#xA;&lt;li&gt;判断任务是否被取消;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;get()&lt;/code&gt;：等待任务完成，获取执行结果，如果任务取消会抛出异常&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;get(long timeout, TimeUnit unit)&lt;/code&gt;：指定等待任务完成的时间，等待超时会抛出异常&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;注意, &lt;code&gt;get()&lt;/code&gt; 方法会阻塞主进程, 一直阻塞到定时结束或者线程返回&lt;/p&gt;</description>
    </item>
    <item>
      <title>通信工具类</title>
      <link>http://localhost:51674/docs/basic/concurrent/%E9%80%9A%E4%BF%A1%E5%B7%A5%E5%85%B7%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/concurrent/%E9%80%9A%E4%BF%A1%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid>
      <description>&lt;p&gt;JDK 中提供了一些并发编程中常用的通信工具类以供我们开发者使用&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;类&lt;/th&gt;&#xA;          &lt;th&gt;作用&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Semaphore&lt;/td&gt;&#xA;          &lt;td&gt;限制线程的数量&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Exchanger&lt;/td&gt;&#xA;          &lt;td&gt;两个线程交换数据&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CountDownLatch&lt;/td&gt;&#xA;          &lt;td&gt;线程等待直到计数器减为 0 时开始工作&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CyclicBarrier&lt;/td&gt;&#xA;          &lt;td&gt;作用跟 CountDownLatch 类似，但是可以重复使用&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Phaser&lt;/td&gt;&#xA;          &lt;td&gt;增强的 CyclicBarrier&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;countdownlatch&#34;&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#countdownlatch&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;一个减法计数器, 基于信号量&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e78284&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#e5c890&#34;&gt;CountTest&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;  &lt;span style=&#34;color:#e78284&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#e78284&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8caaee&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;[]&lt;/span&gt; args) &lt;span style=&#34;color:#e78284&#34;&gt;throws&lt;/span&gt; InterruptedException {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//设置一个尺寸为10的信号量&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9; &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//总数是10，必须要执行任务的时候，再使用&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        CountDownLatch countDownLatch &lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; CountDownLatch(10);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ca9ee6&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#e78284&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;=&lt;/span&gt;0; i&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;10; i&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ca9ee6&#34;&gt;new&lt;/span&gt; Thread(()&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                System.&lt;span style=&#34;color:#8caaee&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#8caaee&#34;&gt;println&lt;/span&gt;(Thread.&lt;span style=&#34;color:#8caaee&#34;&gt;currentThread&lt;/span&gt;().&lt;span style=&#34;color:#8caaee&#34;&gt;getName&lt;/span&gt;()&lt;span style=&#34;color:#99d1db;font-weight:bold&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34; Go out&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                countDownLatch.&lt;span style=&#34;color:#8caaee&#34;&gt;countDown&lt;/span&gt;(); &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//数量减1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            },String.&lt;span style=&#34;color:#8caaee&#34;&gt;valueOf&lt;/span&gt;(i)).&lt;span style=&#34;color:#8caaee&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        countDownLatch.&lt;span style=&#34;color:#8caaee&#34;&gt;await&lt;/span&gt;(); &lt;span style=&#34;color:#737994;font-style:italic&#34;&gt;//等待计数器归零，再向下执行&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#8caaee&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#8caaee&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#a6d189&#34;&gt;&amp;#34;Hello world!&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;两个方法&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;countDown()&lt;/code&gt; 调用后计数减一&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;await()&lt;/code&gt; 使线程挂起&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;exchanger&#34;&gt;&lt;code&gt;Exchanger&lt;/code&gt;&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#exchanger&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;A synchronization point at which threads can pair and swap elements within pairs. Each thread presents some object on entry to the &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Exchanger.html#exchange-V-&#34;&gt;&lt;code&gt;exchange&lt;/code&gt;&lt;/a&gt; method, matches with a partner thread, and receives its partner&amp;rsquo;s object on return. An Exchanger may be viewed as a bidirectional form of a &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/SynchronousQueue.html&#34; title=&#34;class in java.util.concurrent&#34;&gt;&lt;code&gt;SynchronousQueue&lt;/code&gt;&lt;/a&gt;. Exchangers may be useful in applications such as genetic algorithms and pipeline designs.&lt;/p&gt;</description>
    </item>
    <item>
      <title>通配符</title>
      <link>http://localhost:51674/docs/basic/%E9%80%9A%E9%85%8D%E7%AC%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:51674/docs/basic/%E9%80%9A%E9%85%8D%E7%AC%A6/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;In software, a wildcard character is a kind of placeholder represented by a single character, such as an asterisk (*), which can be interpreted as a number of literal characters or an empty string. It is often used in file searches so the full name need not be typed.&lt;/p&gt;&#xA;&lt;p&gt;简单来说, 使用通配符来进行模糊查询&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;-通配符&#34;&gt;&lt;code&gt;%&lt;/code&gt; 通配符&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#-%e9%80%9a%e9%85%8d%e7%ac%a6&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;&lt;code&gt;%&lt;/code&gt; 通配符用于匹配任意长度的字符串，包括零长度，在查询文章标题、用户名等此类字段时，会非常有用。&lt;/p&gt;&#xA;&lt;h4 id=&#34;-通配符-1&#34;&gt;&lt;code&gt;*&lt;/code&gt; 通配符&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#-%e9%80%9a%e9%85%8d%e7%ac%a6-1&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;代表匹配所有值&lt;/p&gt;&#xA;&lt;h4 id=&#34;-参数占位符&#34;&gt;&lt;code&gt;?&lt;/code&gt; 参数占位符&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#-%e5%8f%82%e6%95%b0%e5%8d%a0%e4%bd%8d%e7%ac%a6&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;插值表达式传参使用&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
