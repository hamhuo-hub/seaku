[{"body":" Welcome to the Java Overview page. Here you will find key information about what Java is, why you might want to use it, and how it can benefit your projects.\nWhat is Java?\rJava is a widely-used, high-level programming language known for its simplicity, portability, and performance. It allows developers to write code once and run it anywhere, thanks to the Java Virtual Machine (JVM). Java has been a staple of enterprise-level applications and Android development for decades.\nJava is object-oriented, which helps in structuring and managing large codebases. It also provides extensive libraries and frameworks that can be leveraged for a wide range of application types, from web services to mobile apps.\nKey Features:\rPlatform Independence: “Write once, run anywhere” philosophy. Object-Oriented: Java emphasizes reusable, modular code. Rich Ecosystem: Access to powerful frameworks and libraries. Multi-threading: Supports concurrent execution, which helps in building highly responsive applications. Why do I want Java?\rJava is an ideal choice for developers who need to create cross-platform applications, mobile apps, or enterprise-grade systems. Here are some reasons why you might want to use Java:\nWhat is Java good for?\rEnterprise Applications: Java has been a go-to language for building large-scale enterprise systems (e.g., banking systems, e-commerce platforms). Android Development: Java is the primary language for Android app development. Cross-Platform Applications: The JVM allows Java programs to run on any system that supports Java without modification. Scalable Systems: Java’s robust threading and memory management features make it great for handling large-scale applications. What is Java not good for?\rLow-Level System Programming: Java is not suitable for tasks that require direct hardware manipulation or low-level systems programming, where languages like C or C++ excel. Rapid Prototyping: Java’s verbosity can sometimes slow down development, making it less ideal for quick prototyping compared to languages like Python or JavaScript. What is Java not yet good for?\rReactive Programming: Although Java supports reactive programming with frameworks like Spring WebFlux, other languages such as Scala or JavaScript might offer more native solutions. Native Mobile Development: While Java is widely used for Android development, cross-platform frameworks like Flutter are gaining popularity for iOS and Android apps. ","categories":"","description":"Learn about Java, its features, and why it's a great choice for your next project.","excerpt":"Learn about Java, its features, and why it's a great choice for your …","ref":"/docs/overview/","tags":"","title":"Java Overview"},{"body":"内容来源:\n沉默王二 GitHub 上开源的知识库《Java 进阶之路》 rabbitMQ ","categories":"Java基础能力","description":"","excerpt":"内容来源:\n沉默王二 GitHub 上开源的知识库《Java 进阶之路》 rabbitMQ ","ref":"/docs/basic/","tags":["并发编程","MySQL","Docker"],"title":"Java基础能力"},{"body":"","categories":"","description":"计科学生必备的能力","excerpt":"计科学生必备的能力","ref":"/docs/general/","tags":"","title":"通用能力"},{"body":"内容来源:\n沉默王二 GitHub 上开源的知识库《Java 进阶之路》 rabbitMQ JavaGuide 知乎-阿里大淘宝 Java进阶能力 Java作为一门编程语言, 需要和其他组件一起完成某个项目 一名好的程序员不仅要知道去哪里import, 更要知道import什么组件, 甚至为组件贡献代码\nRedis WebSocket FastExcel报表 Gateway网关(SpringCloudGateway) 中间件 消息队列 Nacos配置中心 Sential声明式服务 需要相关模块依赖, 如下是模块的实例\nwms-sample-mq 模块 pom.xml\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cparent\u003e \u003cgroupId\u003ecom.hamhuo.star\u003c/groupId\u003e \u003cartifactId\u003ewms-java\u003c/artifactId\u003e \u003cversion\u003e${revision}\u003c/version\u003e \u003crelativePath\u003e../pom.xml\u003c/relativePath\u003e \u003c/parent\u003e \u003cartifactId\u003ewms-sample\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!-- spring mvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- common --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.hamhuo\u003c/groupId\u003e \u003cartifactId\u003ewms-common\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.hamhuo.star\u003c/groupId\u003e \u003cartifactId\u003ewms-domain\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- alibaba nacos discovery --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- alibaba nacos config --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-config\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 启动类\n/** * \u003cp\u003e 描述：模块程序启动入口 * \u003c/p\u003e */ @SpringBootApplication @EnableDiscoveryClient @EnableBinding(Source.class) public class MqApplication { public static void main(String[] args) { SpringApplication.run(MqApplication.class, args); } } ","categories":"","description":"","excerpt":"内容来源:\n沉默王二 GitHub 上开源的知识库《Java 进阶之路》 rabbitMQ JavaGuide 知乎-阿里大淘宝 Java进 …","ref":"/docs/advanced/","tags":"","title":""},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/advanced/fastdfs/","tags":"","title":""},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/advanced/rocktmq/","tags":"","title":""},{"body":"题意:\r给你一个二叉树的根节点 root ， 检查它是否轴对称。\n难度:\r简单\n示例:\r输入：root = [1,2,2,3,4,4,3] 输出：true\n解析:\r递归检查子树即可, 要求每一层的左右子树必须一致\n先写辅助的递归, 在递归中检查左右子树是否一致, 也就是每一层左右节点是否相等\npublic boolean isMirror(TreeNode r1, TreeNode r2){ //第一出口, 左右节点同时为NULL if(r1 == null \u0026\u0026 r2 == null){ return true; } //如果两个节点不同时为空, 代表左右两颗树层数不一致 if(r1 == null || r2 == null){ return false; } //递归体, 检查该层节点以及子树是否相等 return (r1.val == r2.val) \u0026\u0026 ismirror(r1.left, r2.right) \u0026\u0026 ismirror(r2.left, r1.right); } 首先传递, 当某一层节点为NULL是回归 一旦发现左右子树不一致就返回false, 并将错误回归 当左右子树同时传递完成, 代表层数一致, 检查节点数值 之后按照对称性, 传递\n左节点的左子树, 右节点的右子树;\n右节点的左子树和左节点的右子树\n","categories":"算法","description":"给你一个二叉树的根节点 root ， 检查它是否轴对称。","excerpt":"给你一个二叉树的根节点 root ， 检查它是否轴对称。","ref":"/leetcode/tree/101.-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","tags":["树"],"title":"101. 对称二叉树"},{"body":"题意:\r给定一个二叉树 root ，返回其最大深度。\n二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。\n难度:\r简单\n示例:\r解析:\r此题就是经典的遍历\n那么二叉树有两种遍历, BFS.DFS 我们选择DFS\nDFS使用递归实现深度遍历 我们编写递归函数\npublic int search(TreeNode root){ //递归 //归条件 if(root == null){ return 0; } //递右节点 int left = search(root.left); //递右节点 int right = search(root.right); //归条件 return (right \u003e= left) ? right + 1 : left + 1; } 递归体中, 不断向下遍历子节点 第一个出口, 节点为零时回归 第二个出口, 子节点变量完成\n选择左右两支中最深的返回即可\n","categories":"算法","description":"","excerpt":"题意:\r给定一个二叉树 root ，返回其最大深度。\n二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。\n难度:\r简单\n示 …","ref":"/leetcode/tree/104.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","tags":"","title":"104. 二叉树的最大深度"},{"body":" #### 题意: 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。\n构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。\n例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --\u003e Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --\u003e y 。\n返回复制链表的头节点。\n用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：\nval：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 你的代码 只 接受原链表的头节点 head 作为传入参数。\n难度:\r中等\n分析:\r和通常的深拷贝不同的是, 这里的节点多了随机指针\n那么在拷贝随机指针之前, 就必须有原链表\n因此分为三步\n拷贝原链表 拷贝随机指针 分离链表 复制节点并插入原节点后面：\nwhile (cur != null) { Node newNode = new Node(cur.val); newNode.next = cur.next; cur.next = newNode; cur = newNode.next; } 比如原链表：A-\u003eB-\u003eC 变成 A-\u003eA’-\u003eB-\u003eB’-\u003eC-\u003eC'\n复制随机指针：\nwhile (cur != null) { if (cur.random != null) { cur.next.random = cur.random.next; } cur = cur.next.next; } 利用第一步创建的节点关系，设置复制节点的random指针：\n如果原节点A的random指向节点C 那么A’的random就应该指向C’（即C的next） 分离两个链表：\nwhile (cur != null) { Node next = cur.next.next; Node copy = cur.next; copyCur.next = copy; copyCur = copy; cur.next = next; cur = next; } 将交织在一起的链表分开：\n原链表恢复原样：A-\u003eB-\u003eC 得到复制的链表：A’-\u003eB’-\u003eC' 整体:\rclass Solution { public Node copyRandomList(Node head) { if (head == null) { return null; } // 第一步：在每个原节点后创建一个新节点 Node cur = head; while (cur != null) { Node newNode = new Node(cur.val); newNode.next = cur.next; cur.next = newNode; cur = newNode.next; } // 第二步：处理random指针 cur = head; while (cur != null) { if (cur.random != null) { cur.next.random = cur.random.next; } cur = cur.next.next; } // 第三步：分离两个链表 Node dummy = new Node(0); Node copyCur = dummy; cur = head; while (cur != null) { // 保存下一个原始节点 Node next = cur.next.next; // 复制的节点 Node copy = cur.next; copyCur.next = copy; copyCur = copy; // 恢复原始链表 cur.next = next; cur = next; } return dummy.next; } } ","categories":"算法","description":"构造这个链表的 深拷贝。","excerpt":"构造这个链表的 深拷贝。","ref":"/leetcode/linkedlist/138.-%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/","tags":["链表"],"title":"138. 随机链表的复制"},{"body":"题意:\r给你一个链表的头节点 head ，判断链表中是否有环。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。\n如果链表中存在环 ，则返回 true 。 否则，返回 false 。\n难度:\r简单\n示例:\r示例 1：\n输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。\n解析:\r使用循环遍历链表查重的方法内存和时间开销很大\n这里介绍一种算法, 龟兔赛跑算法, 就是快慢指针\n定义两个指针, 二者遍历速度不同, 这样就可以保证快指针在有环的情况下可以追上慢指针\npublic class Solution { public boolean hasCycle(ListNode head) { if (head == null || head.next == null) { return false; } ListNode slow = head; ListNode fast = head.next; while (slow != fast) { if (fast == null || fast.next == null) { return false; } slow = slow.next; fast = fast.next.next; } return true; } } ","categories":"算法","description":"给你一个链表的头节点 head ，判断链表中是否有环。","excerpt":"给你一个链表的头节点 head ，判断链表中是否有环。","ref":"/leetcode/linkedlist/141.-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","tags":["链表","双指针"],"title":"141. 环形链表"},{"body":"题意:\r给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n图示两个链表在节点 c1 开始相交\n题目数据 保证 整个链式结构中不存在环。\n难度:\r简单\n示例:\r示例 1：\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at ‘8’\n分析:\r判断相交在链表中是一项很基本, 也很重要的算法\n我们可以将两个链表分别遍历并放入哈希表中去重, 但是当数组较长时会浪费许多资源\n其实这道题的核心是找出第一个相交节点, 而非全部节点, 所以可以使用双指针同时遍历两个链表\n大致思路如下:\n设置两个指针分别指向两个链表的头部 判断是否重复, 重复即为相交 首先移动其中一个指针, 判断重复 移动另一个指针, 判断重复 直至某个指针为空返回false public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) {// 定义两个指针，初始分别指向两个链表头部 // 如果任一链表为空，则不可能相交 if (headA == null || headB == null) { return null; } ListNode ptrA = headA; ListNode ptrB = headB; // 当两个指针不相等时继续遍历 while (ptrA != ptrB) { // 移动指针A ptrA = ptrA == null ? headB : ptrA.next; // 移动指针B ptrB = ptrB == null ? headA : ptrB.next; } // 返回相交节点，如果不存在则返回null return ptrA; ","categories":"算法","description":"给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。","excerpt":"给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。","ref":"/leetcode/linkedlist/160.-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/","tags":["双指针","链表"],"title":"160. 相交链表"},{"body":"题意:\r给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n示例:\r输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5]\n难度:\r中等\n分析:\r题目一共要求做两件事\n找到链表的倒数第n个节点 删除该节点 对于单项链表, 如何找到节点的位置?\n可以两次遍历, 第一次遍历拿链表长度\n第二次才获取具体的节点\n如何删除该节点?\n删除节点涉及到三个部分\n前驱节点, 该节点, 后驱节点\n所以我们在第一步拿到前驱节点, 并保存后驱节点, 修改引用就算删除完毕\n遍历链表\nwhile (current != null) { length++; current = current.next; } 注意是倒数第 n 个节点，所以要用链表的长度减去 n。倒数第 4 个节点的前一个节点就是 5-4=1，也就是第一个节点。\nclass Solution { public ListNode removeNthFromEnd(ListNode head, int n) { // 创建一个虚拟头节点，简化边界条件处理 ListNode dummy = new ListNode(0); dummy.next = head; // 第一次遍历，计算链表的总长度 int length = 0; ListNode current = head; while (current != null) { length++; current = current.next; } // 设置长度为到达要删除的节点的前一个节点 int index = length - n; current = dummy; // 第二次遍历，找到要删除的节点的前一个节点 for (int i = 0; i \u003c index; i++) { current = current.next; } // 删除节点，即跳过要删除的节点 current.next = current.next.next; return dummy.next; } } ","categories":"算法","description":"给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。","excerpt":"给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。","ref":"/leetcode/linkedlist/19.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9/","tags":["链表","递归"],"title":"19. 删除链表的倒数第 N 个结点"},{"body":"题意:\r翻转给定的链表\n示例:\r输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1]\n难度:\r简单\n分析:\r链表翻转有两种方法\n迭代 递归 这里我们用迭代法\n从图中可以看出, 对链表的翻转可以理解为箭头方向变化\n这样我们可以讲链表转为两两一组的节点对, 从头开始迭代\n对于节点对, 我们分为首节点和次节点, 在单向链表, 次节点指向其他节点, 一旦断开次节点的引用, 其他节点会丢失\n所以需要提前存储其他节点\n改变引用关系大致流程如下:\n获得首节点 临时存储其他节点 次节点指向首节点 迭代, 次节点为下一代的首节点, 临时存储节点为次节点 class Solution { public ListNode reverseList(ListNode head) { //迭代法 ListNode current = head; ListNode previous = null; while(current != null){ ListNode temp = current.next; current.next = previous; previous = current; current = temp; } return previous; } } ","categories":"算法","description":"给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。","excerpt":"给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。","ref":"/leetcode/linkedlist/206.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","tags":["链表"],"title":"206. 反转链表"},{"body":"题意:\r将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n难度:\r简单\n示例:\r输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4]\n分析:\r提供的链表有序, 所以可以同时遍历. 连接较小的节点即可\n创建哑结点, 作为链表头, 当前节点为哑结点 同时比较两个链表, 当前节点连接较小节点, 当前节点后驱, 当前节点为新节点 直至某个链表遍历完成, 拼接其剩余节点 class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { // 创建哑节点作为合并后链表的头部 ListNode dummy = new ListNode(0); ListNode current = dummy; // 同时遍历两个链表，比较节点值 while (l1 != null \u0026\u0026 l2 != null) { if (l1.val \u003c= l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } // 将剩余节点接到合并后的链表末尾 current.next = (l1 != null) ? l1 : l2; return dummy.next; } } ","categories":"算法","description":"将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。","excerpt":"将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。","ref":"/leetcode/linkedlist/21.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","tags":["链表"],"title":"21. 合并两个有序链表"},{"body":"题意:\r给你一个链表数组，每个链表都已经按升序排列。\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\n示例:\r合并链表. 最容易想到的就是依次合并\n首先合并 1,2 之后合并3 这样依次合并\n如何合并?\n因为所提供的链表都是有顺序的 所以采用双指针方式\n比较两个节点的值 将较小的节点连接到结果链表 移动较小节点所在链表的指针 移动结果链表的指针 遍历完成后, 剩余节点直接拼接 但很遗憾，这样做的话，每一次合并后的新链表就会非常臃肿，并且在与第 K 个链表合并时，之前链表的节点会多次被访问。\n我们可以使用分治的思想解决\n为了解决臃肿和重复遍历的问题, 把链表的整体合并转为两两合并链表的子问题\n首先判空\nif (lists == null || lists.length == 0) { return null; } 设置间隔, 每次只对间隔的头结点做合并操作\nint interval = 1; // 初始间隔为1 while (interval \u003c n) { // 当间隔小于链表总数时继续循环 这里使用interval来控制合并的步长，比如：\n第一轮：interval = 1，两两合并 第二轮：interval = 2，每次合并相隔2个位置的链表 第三轮：interval = 4，每次合并相隔4个位置的链表 合并\nfor (int i = 0; i \u003c n - interval; i += interval * 2) { lists[i] = merge2Lists(lists[i], lists[i + interval]); } 合并逻辑\nwhile (l1 != null \u0026\u0026 l2 != null) { if (l1.val \u003c= l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } //处理剩余节点 current.next = (l1 != null) ? l1 : l2; 整体如下:\nclass Solution { public ListNode mergeKLists(ListNode[] lists) { if (lists == null || lists.length == 0) { return null; } int n = lists.length; int interval = 1; while (interval \u003c n) { for (int i = 0; i \u003c n - interval; i += interval * 2) { lists[i] = merge2Lists(lists[i], lists[i + interval]); } interval *= 2; } return lists[0]; } private ListNode merge2Lists(ListNode l1, ListNode l2) { // 创建哑节点作为合并后链表的头部 ListNode dummy = new ListNode(0); ListNode current = dummy; // 同时遍历两个链表，比较节点值 while (l1 != null \u0026\u0026 l2 != null) { if (l1.val \u003c= l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } // 将剩余节点接到合并后的链表末尾 current.next = (l1 != null) ? l1 : l2; return dummy.next; } } ","categories":"算法","description":"给你一个链表数组，每个链表都已经按升序排列。\r\r请你将所有链表合并到一个升序链表中，返回合并后的链表","excerpt":"给你一个链表数组，每个链表都已经按升序排列。\r\r请你将所有链表合并到一个升序链表中，返回合并后的链表","ref":"/leetcode/linkedlist/23.-%E5%90%88%E5%B9%B6-k-%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/","tags":["分治","链表"],"title":"23. 合并 K 个升序链表"},{"body":"题意:\r给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。 你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n难度:\r中等\n示例:\r输入：head = [1,2,3,4] 输出：[2,1,4,3]\n分析:\r看到这道题，我们要先搞清楚什么是两两交换，比如 1-\u003e2-\u003e3-\u003e4，交换后就是 2-\u003e1-\u003e4-\u003e3。\n第一个和第二个交换，第三个和第四个交换，以此类推。\n那么就可以把整个链转为子链, 通过递归处理\n/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { return swapAndConnect(head); } public ListNode swapAndConnect(ListNode node) { if (node == null || node.next == null) { // 如果当前节点或下一个节点为空，直接返回当前节点 return node; } // 递归：获取后面的交换结果 ListNode partner = node.next; ListNode next = swapAndConnect(partner.next); // 交换当前节点和下一个节点 node.next = next; partner.next = node; // 返回交换后的新头节点 return partner; } } ","categories":"算法","description":"给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）","excerpt":"给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）","ref":"/leetcode/linkedlist/24.-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","tags":["链表","递归"],"title":"24. 两两交换链表中的节点"},{"body":"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseKGroup(ListNode head, int k) { // 基本判断 if (head == null || k == 1) return head; // 计算当前组的长度是否够k个节点 ListNode curr = head; int count = 0; while (curr != null \u0026\u0026 count \u003c k) { curr = curr.next; count++; } // 如果不够k个节点，保持原有顺序 if (count \u003c k) return head; // 递归处理后续节点组 curr = reverseKGroup(curr, k); // 翻转当前组的k个节点 ListNode prev = curr; ListNode now = head; while (count \u003e 0) { ListNode next = now.next; now.next = prev; prev = now; now = next; count--; } return prev; } } ","categories":"算法","description":"给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。\r\rk 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\r\r你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。","excerpt":"给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。\r\rk 是一个正整数，它的值小于或等于链表的长度。如果节点总 …","ref":"/leetcode/linkedlist/25.-k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/","tags":["递归","链表"],"title":"25. K 个一组翻转链表"},{"body":"知识网络的构建非常有效 完成了知识体系梳理, 让知识点之间互相联系, 达到互相补充的目的, 达到系统性学习的要求 使用Obisidian后完成单元的时间从1个月缩短至5天\n目前的问题: 在知识点构建过程会引用未知知识点, 如果使用深度优先策略会导致单个知识点构建时间过长 使用广度优先策略会导致知识点构建不充分, 导致难以理解甚至错误\ntodo: 找到构建知识点的策略\n待实践: 层次递进法（分层次学习）\n先广度遍历建立基础，再针对难点深度学习。 先粗略标注知识点（例如在 Obsidian 中使用标签），然后逐步填充内容。 设定“深度阈值”，例如最多深入两层，避免陷入细节漩涡。\n关键路径法（关键知识点优先） 找出知识体系中的核心概念（如“动机图”或“概念网络”），优先构建这些关键点。 采用“知识辐射”策略，从核心知识点向外扩展，保证整体理解不受阻碍。\n自适应探索法（按难度动态调整） 在学习过程中动态调整策略：遇到理解困难时，切换为局部深度探索，否则维持广度推进。 利用\n问题驱动学习（Problem-Based Learning, PBL），遇到卡点时再深入，而非预先穷举所有相关知识。\n时间配额法（限制单个知识点时间） 设定时间上限，例如每个知识点最多20分钟，如果仍有未解决的问题，则标记为“待深入”，后续再集中攻克。 通过设定学习周期（如“5天初步构建，10天复盘深化”）来避免单点耗时过多。\n","categories":"","description":"","excerpt":"知识网络的构建非常有效 完成了知识体系梳理, 让知识点之间互相联系, 达到互相补充的目的, 达到系统性学习的要求 使用Obisidian后完 …","ref":"/dairy/2%E6%9C%8810%E6%97%A5/","tags":"","title":"2月10日"},{"body":"太忙了, 忘记写日志了\n实践了层次递进法 将任务量缩减分层遍历任务, 逐层深入, 在一天完成了MySQL 模块的整体结构\n归纳如下, 遍历层数限制为2层, 当知识点层数超过2层时采取两种策略\nAI 归纳, 减少搜索深度 放弃, 继续广度学习 第一种策略很好理解, AI将深度的理论归纳为表层结果, 减少厚度\n第二种策略的理论基础是, 知识点并非树状而是网状结构\n并发编程下有子节点\n子节点下还有 孙 节点\n这看起来是层层递进的树结构, 但是总体来看:\n这是一张网络, 当广度搜索时原先的节点在不同的搜索区域会升级, 从子节点升级为父节点, 从而达到 缩小厚度的结果\n比如搜索路径 并发编程\n此时 AQS 是第三层节点, 学习自旋锁和CLH锁时就应该放弃\n放弃后转为广度搜索, 开始遍历之前的二级节点\n此时在广度搜索基础上, AQS 自动降级了, 通俗来讲就是学习AQS的基础打牢了, 可以将任意的二级节点作为基础向下遍历了\n上述可知, 层级学习的核心是广度搜索结合深度搜索, 前提是有系统的学习路径, 思想是逐层递进, 优先搭建网络, 之后丰满节点\n阅读:\n***问题驱动学习（Problem-Based Learning, PBL）\n","categories":"","description":"","excerpt":"太忙了, 忘记写日志了\n实践了层次递进法 将任务量缩减分层遍历任务, 逐层深入, 在一天完成了MySQL 模块的整体结构\n归纳如下, 遍历层 …","ref":"/dairy/2%E6%9C%8811%E6%97%A5/","tags":"","title":"2月11日"},{"body":"站点成功注册到google 其中几个要点\n默认的 hugo server 指令会在所有页面拒绝索引, 要使用 hugo –gc 或者 hugo google收录的sitemap有一个陈年bug, 站点地图必须使用双斜线并且末尾加斜线 百度收录推荐用www但是加上前缀会导致跳转, 盲猜是个bug ","categories":"","description":"","excerpt":"站点成功注册到google 其中几个要点\n默认的 hugo server 指令会在所有页面拒绝索引, 要使用 hugo –gc …","ref":"/dairy/2%E6%9C%8819%E6%97%A5/","tags":"","title":"2月19日"},{"body":"项目开始了\n高兴 加入了天才噜噜噜的群 高兴 redis缓存一致模型我一个人搞出来了 ","categories":"","description":"","excerpt":"项目开始了\n高兴 加入了天才噜噜噜的群 高兴 redis缓存一致模型我一个人搞出来了 ","ref":"/dairy/2%E6%9C%8820%E6%97%A5/","tags":"","title":"2月20日"},{"body":"题意:\r难度:\r示例:\r解析:\r","categories":"算法","description":"","excerpt":"题意:\r难度:\r示例:\r解析:\r","ref":"/leetcode/tree/543.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/","tags":"","title":"543. 二叉树的直径"},{"body":"给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n示例:\r输入：n = 3 输出：[1,2,3],[8,9,4],[7,6,5]\n难度:\r中等\n分析:\r定义边界法： 使用四个变量记录当前要填充区域的边界：left、right、top、bottom 初始时 left=0、right=n-1、top=0、bottom=n-1 每填充完一条边，相应的边界就向内收缩一格 填充规则： 从左到右填充上边界：固定行(top)，列从 left 到 right 从上到下填充右边界：固定列(right)，行从 top 到 bottom 从右到左填充下边界：固定行(bottom)，列从 right 到 left 从下到上填充左边界：固定列(left)，行从 bottom 到 top 循环终止条件： 当填入的数字达到 n² 时停止 或者当四个边界相互交错时停止 class Solution { public int[][] generateMatrix(int n) { // 正确初始化二维数组 int[][] matrix = new int[n][n]; // 定义四个边界 int left = 0; int right = n - 1; int top = 0; int bottom = n - 1; // 数字从1开始填充 int num = 1; while (num \u003c= n * n) { // 从左到右填充上边界 for (int i = left; i \u003c= right; i++) { matrix[top][i] = num++; } top++; // 从上到下填充右边界 for (int i = top; i \u003c= bottom; i++) { matrix[i][right] = num++; } right--; // 从右到左填充下边界 for (int i = right; i \u003e= left; i--) { matrix[bottom][i] = num++; } bottom--; // 从下到上填充左边界 for (int i = bottom; i \u003e= top; i--) { matrix[i][left] = num++; } left++; } return matrix; } } ","categories":"算法","description":"给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。","excerpt":"给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。","ref":"/leetcode/matrix/59.-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-ii/","tags":["矩阵"],"title":"59. 螺旋矩阵 II"},{"body":"AQS是AbstractQueuedSynchronizer的简称，即抽象的队列同步器\n抽象：抽象类，只实现一些主要逻辑，有些方法由子类实现； 队列：使用先进先出（FIFO）的队列存储数据； 同步：实现了同步的功能。 为什么需要 AQS\rAQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的同步器 简单的说, 存储并管理线程同步的模板\n具体的同步器（如 ReentrantLock、CountDownLatch、Semaphore, FutureTask等）是通过继承 AQS 并实现一些抽象方法来实现资源的具体获取和释放行为的。\nAQS的作用是什么?\r了解 自旋锁与CLH锁\nAQS 是一个 抽象类，它为具体的同步器提供了一个通用的执行框架。 它定义了如何获取和释放共享资源的基本流程，但并没有实现具体的逻辑。\nAQS 提供了同步器所需要的 框架和基础设施，比如：\n如何在多个线程间协调资源的竞争。 如何管理线程的队列（阻塞队列）以等待资源。 其中AQS 的核心数据结构是基于CLH 锁改进的, 详情下述\n线程的挂起与唤醒等机制。 AQS的数据结构\r既然是控制线程, 那么数据结构应对并发相应的优化 AQS的核心数据结构是基于 CLH队列锁改进的 CLH队列锁有如下缺点\n仍然基于自旋, 长时间自旋下CPU占用高 功能单一, 不能挂起, 不能共享读, 只支持独占等 针对以上缺点, AQS进行改造 AQS 将自旋操作改为阻塞线程操作。 AQS 对 CLH 锁进行改造和扩展, 扩展每个节点的状态、显式的维护前驱节点和后继节点 AQS 内部使用了一个volatile关键字 的变量 state 来作为线程的状态标识。\nvolatile int waitStatus; 该变量有如下状态, AQS提供原子读写 ![[content/en/docs/Basic/Concurrent/Pasted image 20250203210552.png]]\nCANCELLED：表示当前节点（对应的线程）已被取消。当等待超时或被中断，会触发进入为此状态，进入该状态后节点状态不再变化； SIGNAL：后面节点等待当前节点唤醒； CONDITION：当前线程阻塞在Condition，如果其他线程调用了Condition的signal方法，这个节点将从等待队列转移到同步队列队尾，等待获取同步锁； 了解Condition等待通知条件\nPROPAGATE：共享模式，前置节点唤醒后面节点后，唤醒操作无条件传播下去； 0：中间状态，当前节点后面的节点已经唤醒，但是当前节点线程还没有执行完成。 状态多了不少, 但是AQS为了优化, 抛弃了自旋设计,这导致线程被阻塞时没办法获取前驱节点的状态 所以AQS显式维护前后节点, 在锁释放时主动通知后继线程解除阻塞 (T1 释放锁后主动唤醒 T2，使 T2 检测到锁已释放，获取锁成功。)\n在释放锁时，如果当前节点的后驱节点不可用时，将从利用队尾指针 Tail 从尾部遍历到直到找到当前节点正确的后驱节点。 这是因为双端队列的插入没有相应的原子操作, 因此后驱节点的设置并非作为原子性插入操作的一部分，而仅是在节点被插入后简单地赋值\nAQS还实现了共享读 资源有两种共享模式，或者说两种同步方式：\n独占模式（Exclusive）：资源是独占的，一次只能有一个线程获取。如 ReentrantLock重入锁 synchronized关键字\n共享模式（Share）：同时可以被多个线程获取，具体的资源个数可以通过参数指定。如 Semaphore/CountDownLatch\n这两种模式是在内部类 Node 中实现的\nNode源码\n可以看到 node中的状态信息都是常量, 无法修改的\nstatic final class Node { // 标记一个结点（对应的线程）在共享模式下等待 static final Node SHARED = new Node(); // 标记一个结点（对应的线程）在独占模式下等待 static final Node EXCLUSIVE = null; // waitStatus的值，表示该结点（对应的线程）已被取消 static final int CANCELLED = 1; // waitStatus的值，表示后继结点（对应的线程）需要被唤醒 static final int SIGNAL = -1; // waitStatus的值，表示该结点（对应的线程）在等待某一条件 static final int CONDITION = -2; /*waitStatus的值，表示有资源可用，新head结点需要继续唤醒后继结点（共享模式下，多线程并发释放资源，而head唤醒其后继结点后，需要把多出来的资源留给后面的结点；设置新的head结点时，会继续唤醒其后继结点）*/ static final int PROPAGATE = -3; // 等待状态，取值范围，-3，-2，-1，0，1 volatile int waitStatus; volatile Node prev; // 前驱结点 volatile Node next; // 后继结点 volatile Thread thread; // 结点对应的线程 Node nextWaiter; // 等待队列里下一个等待条件的结点 // 判断共享模式的方法 final boolean isShared() { return nextWaiter == SHARED; } Node(Thread thread, Node mode) { // Used by addWaiter this.nextWaiter = mode; this.thread = thread; } // 其它方法忽略，可以参考具体的源码 } // AQS里面的addWaiter私有方法 private Node addWaiter(Node mode) { // 使用了Node的这个构造函数 Node node = new Node(Thread.currentThread(), mode); // 其它代码省略 } AQS源码解析\rAQS 的设计是基于模板方法的，它有一些方法必须要子类实现，它们主要有：\nisHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。 tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。 tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。 tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回 true，否则返回 false。 比较特殊的是, 这里的抽象方法并没有加 abstract 关键字 这是因为并非AQS的所有抽象方法都需要子类实现, 所以子类只重写需要的方法就行\n子类不是重点, 我们来看模板类, 也就是AQS的逻辑\n获取资源\r获取资源的入口是 acquire(int arg)方法。arg 是要获取的资源个数，在独占模式下始终为 1。我们先来看看这个方法的逻辑：\npublic final void accquire(int arg) { // tryAcquire 再次尝试获取锁资源，如果尝试成功，返回true，尝试失败返回false if (!tryAcquire(arg) \u0026\u0026 // 走到这，代表获取锁资源失败，需要将当前线程封装成一个Node，追加到AQS的队列中 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // 线程中断 selfInterrupt(); } 首先调用 tryAcquire 尝试去获取资源。如果获取资源失败，就通过 addWaiter(Node.EXCLUSIVE) 方法把这个线程插入到等待队列中。其中传入的参数代表要插入的 Node 是独占式的。\nprivate Node addWaiter(Node mode) { //创建 Node 类，并且设置 thread 为当前线程，设置为排它锁 Node node = new Node(Thread.currentThread(), mode); // 获取 AQS 中队列的尾部节点 Node pred = tail; // 如果 tail == null，说明是空队列， // 不为 null，说明现在队列中有数据， if (pred != null) { // 将当前节点的 prev 指向刚才的尾部节点，那么当前节点应该设置为尾部节点 node.prev = pred; // CAS 将 tail 节点设置为当前节点 if (compareAndSetTail(pred, node)) { // 将之前尾节点的 next 设置为当前节点 pred.next = node; // 返回当前节点 return node; } } enq(node); return node; } // 自旋CAS插入等待队列 private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // Must initialize if (compareAndSetHead(new Node())) tail = head; } else { node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } 在队列的尾部插入新的 Node 节点，但是需要注意的是由于 AQS 中会存在多个线程同时争夺资源的情况，因此肯定会出现多个线程同时插入节点的操作，在这里是通过 CAS 自旋的方式保证了操作的线程安全性。\n释放资源\rpublic final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null \u0026\u0026 h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } private void unparkSuccessor(Node node) { // 如果状态是负数，尝试把它设置为0 int ws = node.waitStatus; if (ws \u003c 0) compareAndSetWaitStatus(node, ws, 0); // 得到头结点的后继结点head.next Node s = node.next; // 如果这个后继结点为空或者状态大于0 // 通过前面的定义我们知道，大于0只有一种可能，就是这个结点已被取消（只有 Node.CANCELLED(=1) 这一种状态大于0） if (s == null || s.waitStatus \u003e 0) { s = null; // 从尾部开始倒着寻找第一个还未取消的节点（真正的后继者） for (Node t = tail; t != null \u0026\u0026 t != node; t = t.prev) if (t.waitStatus \u003c= 0) s = t; } // 如果后继结点不为空， if (s != null) LockSupport.unpark(s.thread); } 如果tryRelease(arg)成功释放了锁，那么接下来会检查队列的头结点。如果头结点存在并且waitStatus不为0（这意味着有线程在等待），那么会调用unparkSuccessor(Node h)方法来唤醒等待的线程。\n","categories":"Java基础能力","description":"**AQS**是`AbstractQueuedSynchronizer`的简称，即`抽象的队列同步器`","excerpt":"**AQS**是`AbstractQueuedSynchronizer`的简称，即`抽象的队列同步器`","ref":"/docs/basic/concurrent/aqs/","tags":["并发编程"],"title":"AQS"},{"body":"URL, URI\rWe have to deal with URLs every day. URL is an acronym that stands for Uniform Resource Locator.\nyou can simply call it address. It’s used as a string that denotes the location of a given resource on the Internet: a web page, an image, a mailbox, etc.\nWhat Is a URI?\nThe URI acronym stands for Uniform Resource Identifier. It’s follow rules same as URL\nSo, are URLs and URIs the same thing? not really.\na URL is a URI. Beyond the fact that it uses the same URI syntax, it also identifies a resource through an address. URI doesn’t allow you to access any resource on the Web. URI work like an identifier. This identifier is nothing but a URI: a logical identifier for your API.\n","categories":"通用能力","description":"计算机因特网-电子工业版","excerpt":"计算机因特网-电子工业版","ref":"/docs/general/computer-internet/","tags":["Internet"],"title":"Computer Internet"},{"body":"CPU 缓存是为了解决 CPU 处理速度和内存处理速度不对等的问题。\nCPU Cache 的工作方式： 先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 内存缓存不一致性的问题 ！比如我执行一个 i++ 操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 i++ 运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。\n操作系统屏蔽了底层硬件的操作细节，将各种硬件资源虚拟化。于是，操作系统也就同样需要解决内存缓存不一致性问题。\n操作系统通过 内存模型（Memory Model） 定义一系列规范来解决这个问题。无论是 Windows 系统，还是 Linux 系统，它们都有特定的内存模型。\n","categories":"通用能力","description":"CPU 缓存是为了解决 CPU 处理速度和内存处理速度不对等的问题。","excerpt":"CPU 缓存是为了解决 CPU 处理速度和内存处理速度不对等的问题。","ref":"/docs/general/os/cpu%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/","tags":["操作系统"],"title":"CPU Cache 高速缓存"},{"body":"内容来源:\n沉默王二 GitHub 上开源的知识库《Java 进阶之路》 ","categories":"Java基础能力","description":"应用运行容器, 傻瓜式安装程序环境, 还不怕中病毒","excerpt":"应用运行容器, 傻瓜式安装程序环境, 还不怕中病毒","ref":"/docs/basic/docker/","tags":"","title":"Docker"},{"body":"为什么需要文件服务器?\r浏览器请求可能会携带头像文件, 服务器处理后存储在本地磁盘\n但是假如还有一个服务需要操作订单\n那么就需要异步从存储头像拿头像\n也就是说用户信息业务崩溃后, 导致订单服务器也一并崩溃\n为了解耦合, 我们把文件存储到专门的服务器里, 保证系统稳定\n当用户在订单管理修改信息后, 还需要同步到用户信息服务器\n这需要传递两次, 还要保证一致性, 倒不如直接把服务器分离, 只传递文件地址 这样就可以减少服务间的传递, 而且也不需要传递大尺寸的文件, 只要传链接就可以\n使用\r检查nacos配置 第三方服务\n下载地址是由nginx管理的, 所以还需要nginx配置\n注入fastdfs客户端 配置文件服务器url 也就是 nginx的IP地址\n上传文件 传入 MultipatFile file 首先提取后缀名, 左闭右开去掉点放到新的子串 直接调客户端上传即可 用户回显, 是否上传成功, 看有没有文件信息就可以\n下载 也就是响应文件, 创建响应实体内部放字节流 调客户端下载, 传入group组和文件id 下载完成的文件命名, 用时间就可以 定义好的名字回传道响应的响应头\n删除文件 还是组和文件id 调客户端删除 回调是int值, 匹配定义的预设输出传回即可\n","categories":"Java进阶能力","description":"分布式存储中间件","excerpt":"分布式存储中间件","ref":"/docs/advanced/fastdfs/fastdfs%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/","tags":["分布式","中间件"],"title":"FastDFS分布式存储"},{"body":"提前封装好一些服务\n快速导入\r组件扫描\n写一个单元测试 导入excel客户端 生成excle 新建一个数组 调用导入功能\n解析 传入文件\n","categories":"Java进阶能力","description":"报表组件","excerpt":"报表组件","ref":"/docs/advanced/fastexcel%E6%8A%A5%E8%A1%A8%E7%BB%84%E4%BB%B6/","tags":["中间件"],"title":"FastExcel报表组件"},{"body":"什么是网关\r网关负责路由请求、负载均衡、安全认证、流量控制、监控和日志记录等任务。\n我的理解是, 网关是请求真正进入服务前的过滤, 管理, 控制(重定向), 可以理解为保安大哥\n网关的结构\n路由 网关的基本模块, 由断言和过滤器组成\n断言 匹配规则, 当请求路径匹配时允许路由到相关服务 实现一组匹配规则，让请求找到对应的 Route 进行处理\n过滤器 响应式的过滤器链, 实现请求的过滤\n全局过滤器 全局过滤器作用于所有的路由，不需要单独配置 客户端发起请求, 由 Gateway Handler Mapping 接收, 这里执行断言并路由到 Gateway Web Handler 这里做过滤链, 过滤请求, 最后传递给服务 过滤器可以在执行前和执行后回调\n在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等;\n在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。\n了解: 响应式编程\n过滤器\r过滤器是由 Servlet 容器管理的, 也就是说初始化\n自定义网关实现全局过滤器\r网关选型SpringCloudGateway 这是目前比较新的选择\n模板工程基于 pmhub\n新建自定义的全局过滤器\n全局过滤器需要实现 GlobalFilter 过滤器需要确定执行顺序, 实现Order 接口\n@Component public class AuthFilter implements GlobalFilter, Ordered 该过滤器实现如下功能\n请求耗时记录 白名单过滤 Token鉴权 日志输出 请求耗时记录:\n全局过滤器的优先级较高, 因此把请求进入过滤器的时间作为起点, 业务执行完毕执行post 业务逻辑. 进行简单的时间相减\n白名单过滤:\nnacos 配置白名单, 有些路径不需要严格的鉴权, 比如首页. 所有人发请求都能通过, 就直接跳过完事\nToken鉴权:\n作为全局过滤器, 当用户请求进入应当进行身份鉴权, 过滤无效的请求 从请求头里拿 Token , 跟缓存做匹配即可\nRedis 策略是到期销毁, 不做更新\n日志输出: 在过滤链回调后执行, 代表服务执行完成 结束时间减去开始时间就行\n为了方便解释, 我们一项项实现\n请求耗时:\n@Component public class AuthFilter implements GlobalFilter, Ordered{ //常量, 记录开始访问的时间 private static final String BEGIN_VISIT_TIME = \"begin_visit_time\";//开始访问时间 //补上日志实例 private static final Logger log = LoggerFactory.getLogger(AuthFilter.class); //过滤器接口方法, 这个必须实现 @Override public Mono\u003cVoid\u003e filter(ServerWebExchange exchange, GatewayFilterChain chain) { //token和白名单稍后实现 //在上下文加上开始时间 exchange.getAttributes().put(BEGIN_VISIT_TIME, System.currentTimeMillis()); //等待链执行完成回调 return chain.filter(exchange) //链式调用then, 使用Mono.fromRunnable方法顺序执行日志输出 .then(Mono.fromRunnable{}) //日志输出的逻辑 // 记录接口访问日志 Long beginVisitTime = exchange.getAttribute(BEGIN_VISIT_TIME); if (beginVisitTime != null){ logData.put(\"duration\", (System.currentTimeMillis() - beginVisitTime) + \"ms\"); log.info(\"访问接口信息: {}\", logData); } } } 白名单过滤\n@Component public class AuthFilter implements GlobalFilter, Ordered{ //常量, 记录开始访问的时间 private static final String BEGIN_VISIT_TIME = \"begin_visit_time\";//开始访问时间 //补上日志 private static final Logger log = LoggerFactory.getLogger(AuthFilter.class); //过滤器接口方法 @Override public Mono\u003cVoid\u003e filter(ServerWebExchange exchange, GatewayFilterChain chain) { //白名单 //首先拿到请求路径 //上下文拿请求 ServerHttpRequest request = exchange.getRequest(); //请求拿请求路径, 先拿URI, 再去掉首部 String url = request.getURI().getPath(); // 跳过不需要验证的路径, 直接进下一级 if (StringUtils.matches(url, ignoreWhite.getWhites())) { return chain.filter(exchange); } //在上下文加上开始时间 exchange.getAttributes().put(BEGIN_VISIT_TIME, System.currentTimeMillis()); //等待链执行完成回调 return chain.filter(exchange) //链式调用then, 使用Mono.fromRunnable方法顺序执行日志输出 .then(Mono.fromRunnable{}) //日志输出的逻辑 // 记录接口访问日志 Long beginVisitTime = exchange.getAttribute(BEGIN_VISIT_TIME); if (beginVisitTime != null){ logData.put(\"duration\", (System.currentTimeMillis() - beginVisitTime) + \"ms\"); log.info(\"访问接口信息: {}\", logData); } } } token鉴权: 选型 Jwt\n下图是流程, 我们将鉴权的业务从服务层分离移至网关进行, 优化性能\n鉴权（认证）是在网关层进行的，而 请求并没有进入到 MVC 控制器中, 也就没有触发拦截器\n了解: SpringMVC\n@Component public class AuthFilter implements GlobalFilter, Ordered{ //常量, 记录开始访问的时间 private static final String BEGIN_VISIT_TIME = \"begin_visit_time\";//开始访问时间 //补上日志 private static final Logger log = LoggerFactory.getLogger(AuthFilter.class); //补上redis @Autowired private RedisService redisService; //过滤器接口方法 @Override public Mono\u003cVoid\u003e filter(ServerWebExchange exchange, GatewayFilterChain chain) { //白名单 //首先拿到请求路径 //上下文拿请求 ServerHttpRequest request = exchange.getRequest(); //请求拿请求路径, 先拿URI, 再去掉首部 String url = request.getURI().getPath(); // 跳过不需要验证的路径, 直接进下一级, 返回链的执行结果 if (StringUtils.matches(url, ignoreWhite.getWhites())) { return chain.filter(exchange); } //剩下的请求过筛子 //从请求拿token String token = getToken(request); if (StringUtils.isEmpty(token)) { return unauthorizedResponse(exchange, \"令牌不能为空\"); } //拿JWT的声明, 这里写了一个字符串工具拿声明, 令牌秘钥就在工具里 Claims claims = JwtUtils.parseToken(token); if (claims == null) { return unauthorizedResponse(exchange, \"令牌已过期或验证不正确！\"); } //从声明拿用户ID String userkey = JwtUtils.getUserKey(claims); //从缓存匹配用户ID的token, 这里getTokenKey格式化, 就加了个前缀 boolean islogin = redisService.hasKey(getTokenKey(userkey)); if (!islogin) { return unauthorizedResponse(exchange, \"登录状态已过期\"); } //最后从声明拿用户详细信息 String userid = JwtUtils.getUserId(claims); String username = JwtUtils.getUserName(claims); if (StringUtils.isEmpty(userid) || StringUtils.isEmpty(username)) { return unauthorizedResponse(exchange, \"令牌验证失败\"); } //重新设置请求, 鉴权完毕 //设置用户信息到请求 addHeader(mutate, SecurityConstants.USER_KEY, userkey); addHeader(mutate, SecurityConstants.DETAILS_USER_ID, userid); addHeader(mutate, SecurityConstants.DETAILS_USERNAME, username); // 内部请求来源参数清除（防止网关携带内部请求标识，造成系统安全风险） removeHeader(mutate, SecurityConstants.FROM_SOURCE); //在上下文加上开始时间 exchange.getAttributes().put(BEGIN_VISIT_TIME, System.currentTimeMillis()); //等待链执行完成回调 return chain.filter(exchange) //链式调用then, 使用Mono.fromRunnable方法顺序执行日志输出 .then(Mono.fromRunnable{}) //日志输出的逻辑 // 记录接口访问日志 Long beginVisitTime = exchange.getAttribute(BEGIN_VISIT_TIME); if (beginVisitTime != null) { URI uri = exchange.getRequest().getURI(); Map\u003cString, Object\u003e logData = new HashMap\u003c\u003e(); logData.put(\"host\", uri.getHost()); logData.put(\"port\", uri.getPort()); logData.put(\"path\", uri.getPath()); logData.put(\"query\", uri.getRawQuery()); logData.put(\"duration\", (System.currentTimeMillis() - beginVisitTime) + \"ms\"); log.info(\"访问接口信息: {}\", logData); log.info(\"我是美丽分割线: ###################################################\"); } } } addHeader 和 removeHeader 其实没什么说的, 就是重新构造了个请求, 方便后续服务直接拿信息\nprivate void addHeader(ServerHttpRequest.Builder mutate, String name, Object value) { if (value == null) { return; } String valueStr = value.toString(); String valueEncode = ServletUtils.urlEncode(valueStr); mutate.header(name, valueEncode); } private void removeHeader(ServerHttpRequest.Builder mutate, String name) { mutate.headers(httpHeaders -\u003e httpHeaders.remove(name)).build(); } ","categories":"Java进阶能力","description":"网关是一个位于微服务架构前端的组件，它充当了所有微服务的入口","excerpt":"网关是一个位于微服务架构前端的组件，它充当了所有微服务的入口","ref":"/docs/advanced/gateway%E7%BD%91%E5%85%B3/","tags":["分布式","Spring"],"title":"Gateway网关"},{"body":"","categories":"Java进阶能力","description":"拦截器 Interceptor 在 Spring MVC 中的地位等同于 Servlet 规范中的过滤器 Filter，拦截的是处理器的执行，由于是全局行为，因此常用于做一些通用的功能，如请求日志打印、权限控制等。","excerpt":"拦截器 Interceptor 在 Spring MVC 中的地位等同于 Servlet 规范中的过滤器 Filter，拦截的是处理器的执 …","ref":"/docs/advanced/intercepter%E6%8B%A6%E6%88%AA%E5%99%A8/","tags":["Spring"],"title":"Intercepter拦截器"},{"body":"讲一下数据高准确性如何保证\r两种方案\nBigDecimal 这个类是Java中专门用于处理高精度的类, 特别适用于需要高精度的场景, 比如金融计算, BigDecimal 是基于字符串来存储数值的, 可以进行高精度的算数运算\n具体到某一种场景, 可以把大单位数字通过单位转换, 转化为小单位, 比如说 10.95元, 转换为1095分, 把浮点运算转为整数运算, 保证高准确性\n拓展 [BigDecimal](content/en/docs/Basic/Java数据类型#BigDecimal 类)\nBigDecimal num1 = new BigDecimal(\"0.1\"); BigDecimal num2 = new BigDecimal(\"0.2\"); 请说下多态, 重载, 重写\r多态:\n多态指的是执行一段代码, Java可以根据运行时对象类型产生不同的结果 也就是不同对象上调用同一个方法, 有不同的结果 多态实现的前提有三个\n继承关系, 要有父类 重写父类方法 父类引用指向子类的对象 父类定义一个方法, 子类可以自己提供实现, 子类对象调用父类的方法就可以重新引用到具体的子类方法, 从而实现同一方法, 不同结果的多态\n子类自己提供实现 这个行为叫做重写父类方法\n重载:\n在同一个类中，允许定义多个方法名相同但参数不同的方法, 叫方法重载, 方法重载可以提高程序的可读性, 对于同一种逻辑, 只是传入的参数不同没必要用不同的名字, 代码更简洁 比如计算矩形面积, 传入两条边的边长就是计算矩形面积, 只传一条边长, 就是计算正方形面积 这两个方法的名字都可以是 area\n重写例子:\n// 父类：动物 class Animal { void makeSound() { System.out.println(\"动物在叫\"); } } // 子类：猫 class Cat extends Animal { void makeSound() { System.out.println(\"猫在喵喵叫\"); } } // 子类：狗 class Dog extends Animal { void makeSound() { System.out.println(\"狗在汪汪叫\"); } } 重载例子:\npublic class Shape { // 计算矩形的面积（长和宽） public int area(int length, int width) { return length * width; } // 计算正方形的面积（只给定一条边） public int area(int side) { return side * side; } } 继承和抽象的区别\r继承允许子类直接复用或者重写父类方法 抽象\n","categories":"面试","description":"Java Platform, Standard Edition (Java SE) lets you develop and deploy Java applications on desktops and servers. Java offers the rich user interface, performance, versatility, portability, and security that today's applications require.","excerpt":"Java Platform, Standard Edition (Java SE) lets you develop and deploy …","ref":"/interview/javase/","tags":"","title":"JavaSE"},{"body":"内容来源:\n沉默王二 GitHub 上开源的知识库《Java 进阶之路》 ","categories":"Java基础能力","description":"web目录","excerpt":"web目录","ref":"/docs/basic/javaweb/","tags":["JavaWeb"],"title":"JavaWeb"},{"body":"内容来源:\n沉默王二 GitHub 上开源的知识库《Java 进阶之路》 JavaGuide CLH锁 - Quner技术沙龙 操作系统 - 西电出版 ","categories":"Java基础能力","description":"","excerpt":"内容来源:\n沉默王二 GitHub 上开源的知识库《Java 进阶之路》 JavaGuide CLH锁 - Quner技术沙龙 操作系统 - …","ref":"/docs/basic/concurrent/","tags":["并发编程"],"title":"Java并发编程"},{"body":"BigDecimal 类\rImmutable, arbitrary-precision signed decimal numbers. A BigDecimal consists of an arbitrary precision integer unscaled value and a 32-bit integer scale.\n不可变的, 有符号任意精度数, 有32位的标度和未缩放值组成, 精度极高 计算式\nBigDecimal bd1 = new BigDecimal(\"12.345\"); BigDecimal bd2 = new BigDecimal(\"0.005\"); BigDecimal result = bd1.add(bd2); System.out.println(result); // 输出 12.350 ","categories":"Java基础能力","description":"变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。\r\r内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。","excerpt":"变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。\r\r内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能 …","ref":"/docs/basic/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","tags":["Java数据类型"],"title":"Java数据类型"},{"body":"强引用 A a=new A(); 此时引用a强引用对象A；不会被GC 即使OOM也不会回收对象, 而是抛异常\n弱引用 WeakReference.java 是 Java1.2提供的一个类 当GC发现弱引用后会直接回收该对象\n","categories":"Java基础能力","description":"强引用不会被垃圾回收，除非手动弱化；软引用在内存不足时回收，可用于内存敏感的高速缓存；弱引用不管内存是否充足，垃圾回收时都会回收；虚引用不决定对象生命周期，主要用于跟踪对象回收。","excerpt":"强引用不会被垃圾回收，除非手动弱化；软引用在内存不足时回收，可用于内存敏感的高速缓存；弱引用不管内存是否充足，垃圾回收时都会回收；虚引用不决 …","ref":"/docs/basic/jvm/java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/","tags":["JVM","GC"],"title":"Java的四种引用"},{"body":"内容来源:\n沉默王二 GitHub 上开源的知识库《Java 进阶之路》 JavaGuide Geeksforgeeks 菜鸟教程 ","categories":"Java基础能力","description":"","excerpt":"内容来源:\n沉默王二 GitHub 上开源的知识库《Java 进阶之路》 JavaGuide Geeksforgeeks 菜鸟教程 ","ref":"/docs/basic/container/","tags":"","title":"Java集合框架"},{"body":"Java 内存模型（Java Memory Model，JMM）定义了 Java 程序中的变量、线程如何和主存以及工作内存进行交互的规则, 可以理解为并发编程相关的一组规范\nJMM在Java中主要解决线程同步与通信问题, 涉及到内存可见性, 指令重排等问题\nJava 是最早尝试提供内存模型的编程语言。由于早期内存模型存在一些缺陷（比如非常容易削弱编译器的优化能力），从 Java5 开始，Java 开始使用新的内存模型\n一般来说，编程语言也可以直接复用操作系统层面的内存模型。不过，不同的操作系统内存模型不同。如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了。 Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。\n红色区域称主内存, 是线程存放共享变量的区域\n白色为本地内存\n主内存：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量，还是局部变量，类信息、常量、静态变量都是放在主内存中。为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。 本地内存：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的副本。每个线程只能操作自己本地内存中的变量，无法直接访问其他线程的本地内存。如果线程间需要通信，必须通过主内存来进行。本地内存是 JMM 抽象出来的一个概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。 内存可见性问题\r和 CPU cache 类似, 当多个线程同时读写共享变量时, 线程不存在同步机制会导致变量被覆写, 导致结果不可预见 如何解决内存可见性问题?\n关于主内存与工作内存直接的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义来以下八种同步操作\n初次之外还规定了很多同步规则,这不重要\n指令重排序问题\r为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。\n什么是指令重排序？ 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致 ，所以在多线程下，指令重排序可能会导致一些问题。\nhappen-before 原则\rhappens-before 这个概念最早诞生于 Leslie Lamport 于 1978 年发表的论文《Time，Clocks and the Ordering of Events in a Distributed System》。在这篇论文中，Leslie Lamport 提出了逻辑时钟的概念，这也成了第一个逻辑时钟算法 。\n逻辑时钟并不度量时间本身，仅区分事件发生的前后顺序，其本质就是定义了一种 happens-before 关系。\n也就是说, happen-before确定了\n只要不改变程序的执行结果（单线程程序和正确执行的多线程程序），编译器和处理器怎么进行重排序优化都行。 对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。 结合happen-before关系和上述的同步规则, 就可以解决线程的通信与同步\n如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前。 两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。 例如 int userNum = getUserNum(); // 1 int teacherNum = getTeacherNum(); // 2 int totalNum = userNum + teacherNum; // 3 虽然 1 happens-before 2，但对 1 和 2 进行重排序不会影响代码的执行结果，所以 JMM 是允许编译器和处理器执行这种重排序的。但 1 和 2 必须是在 3 执行之前，也就是说 1,2 happens-before 3 。\nhappen-before 的实质就是前一个操作是否需要对后一个操作可见也就是涉及到了两个操作共有的变量, 需要便符合happen-before 关系 这与是否为并发环境无关\n","categories":"Java基础能力","description":"Java 内存模型（Java Memory Model，JMM）定义了 Java 程序中的变量、线程如何和主存以及工作内存进行交互的规则","excerpt":"Java 内存模型（Java Memory Model，JMM）定义了 Java 程序中的变量、线程如何和主存以及工作内存进行交互的规则","ref":"/docs/basic/concurrent/jmm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","tags":["并发编程"],"title":"JMM内存模型"},{"body":"内容来源:\n沉默王二 GitHub 上开源的知识库《Java 进阶之路》 JavaGuide Geeksforgeeks 菜鸟教程 ","categories":"Java基础能力","description":"","excerpt":"内容来源:\n沉默王二 GitHub 上开源的知识库《Java 进阶之路》 JavaGuide Geeksforgeeks 菜鸟教程 ","ref":"/docs/basic/jvm/","tags":["JVM"],"title":"JVM"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/advanced/jwt/","tags":"","title":"JWT"},{"body":"什么是链表\r链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。\n链表可分为单向链表和双向链表。\n一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。\n单向链表\n双向链表\nDoubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null). LinkedList 是基于双向链表的数据结构, 实现队列和列表接口的所有方法, 允许存放任意类型元素\n基础使用\r以下情况使用 LinkedList :\n你需要通过循环迭代来访问列表中的某些元素。 需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。 public class LinkedList\u003cE\u003e extends AbstractSequentialList\u003cE\u003e implements List\u003cE\u003e, Deque\u003cE\u003e, Cloneable, Serializable 使用之前:\nLinkedList 类位于 java.util 包中，使用前需要引入它 链表实现了 Queue 接口, 可以作为队列使用 链表实现了 List 接口, 可进行列表的相关操作 链表添加标签 Cloneable 允许克隆 链表实现 Serializable 可以序列化 链表线程不安全, 依赖外部同步 新建实例\n// 引入 LinkedList 类 import java.util.LinkedList; public class RunoobTest { public static void main(String[] args) { LinkedList\u003cString\u003e sites = new LinkedList\u003cString\u003e(); sites.add(\"Google\"); sites.add(\"Runoob\"); sites.add(\"Taobao\"); sites.add(\"Weibo\"); System.out.println(sites); } } 开头添加元素\nsites.addFirst() 结尾添加元素\n注意 默认的 add() 方法就是在结尾添加\nsites.addLast() 开头删除元素\nsites.removedFirst() 结尾删除元素\nsites.removedLast() 获取元素\nsites.getFirst() sites.getLast() 获取链表长度\nsites.size() 进阶部分\r为什么需要链表?\r和链表定位类似的是 ArrayList 基于动态数组的列表\n相比之下链表有以下优点\n链表不定长, 内存无需连续 头尾插入快 链表大致分为三种\n“单向链表”，我只有一个后指针，指向下一个数据； “双向链表”，我有两个指针，后指针指向下一个数据，前指针指向上一个数据。 “二叉树”，把后指针去掉，换成左右指针。 LinkedList 解析\r链表的核心是 Node 这是一个内部静态类, 定义存储数据单位的结构\n/** * 链表中的节点类。 */ private static class Node\u003cE\u003e { E item; // 节点中存储的元素 Node\u003cE\u003e next; // 指向下一个节点的指针 Node\u003cE\u003e prev; // 指向上一个节点的指针 /** * 构造一个新的节点。 * * @param prev 前一个节点 * @param element 节点中要存储的元素 * @param next 后一个节点 */ Node(Node\u003cE\u003e prev, E element, Node\u003cE\u003e next) { this.item = element; // 存储元素 this.next = next; // 设置下一个节点 this.prev = prev; // 设置上一个节点 } } LinkedList 内部使用双向链表实现 添加节点\r/** * 将指定的元素添加到列表的尾部。 * * @param e 要添加到列表的元素 * @return 始终为 true（根据 Java 集合框架规范） */ public boolean add(E e) { linkLast(e); // 在列表的尾部添加元素 return true; // 添加元素成功，返回 true } //todo\n删除节点\rremove()：删除第一个节点 remove(int)：删除指定位置的节点 remove(Object)：删除指定元素的节点 removeFirst()：删除第一个节点 removeLast()：删除最后一个节点 /** * 删除指定位置上的元素。 * * @param index 要删除的元素的索引 * @return 从列表中删除的元素 * @throws IndexOutOfBoundsException 如果索引越界（index \u0026lt; 0 || index \u0026gt;= size()） */ public E remove(int index) { checkElementIndex(index); // 检查索引是否越界 return unlink(node(index)); // 删除指定位置的节点，并返回节点的元素 } /** * 获取链表中指定位置的节点。 * * @param index 节点的位置（从 0 开始） * @return 指定位置的节点 * @throws IndexOutOfBoundsException 如果索引超出范围（index \u003c 0 || index \u003e= size()） */ Node\u003cE\u003e node(int index) { if (index \u003c (size \u003e\u003e 1)) { // 如果索引在链表的前半部分 Node\u003cE\u003e x = first; for (int i = 0; i \u003c index; i++) // 从头节点开始向后遍历链表，直到找到指定位置的节点 x = x.next; return x; // 返回指定位置的节点 } else { // 如果索引在链表的后半部分 Node\u003cE\u003e x = last; for (int i = size - 1; i \u003e index; i--) // 从尾节点开始向前遍历链表，直到找到指定位置的节点 x = x.prev; return x; // 返回指定位置的节点 } } 内部调用的是 unlink() 方法\n大致思路是\n删除一共涉及三个节点, 前驱节点, 删除节点, 后驱节点 这是因为一旦节点被删除, 链表就断掉了, 需要重新连接前驱和后驱 拿到这三个节点, 首先进行特殊情况判断\n删除的是否为头结点 如果是, 就把后驱节点设置为头结点 如果不是, 前驱节点连接后驱节点, 删除节点的前驱置空 删除的是否为尾节点 如果是, 就把前驱节点设置为尾节点 如果不是, 后驱节点连接前驱节点, 完成双向链接, 删除节点的后驱置空 /** * 从链表中删除指定节点。 * * @param x 要删除的节点 * @return 从链表中删除的节点的元素 */ E unlink(Node\u003cE\u003e x) { final E element = x.item; // 获取要删除节点的元素 final Node\u003cE\u003e next = x.next; // 获取要删除节点的下一个节点 final Node\u003cE\u003e prev = x.prev; // 获取要删除节点的上一个节点 if (prev == null) { // 如果要删除节点是第一个节点 first = next; // 将链表的头节点设置为要删除节点的下一个节点 //在这种情况下，不能执行 prev.next = next，因为 prev 是 null，会导致空指针异常 } else { prev.next = next; // 将要删除节点的上一个节点指向要删除节点的下一个节点 x.prev = null; // 将要删除节点的上一个节点设置为空 } if (next == null) { // 如果要删除节点是最后一个节点 last = prev; // 将链表的尾节点设置为要删除节点的上一个节点 //在这种情况下，不能执行 next.prev = prev，因为 next 是 null，会导致空指针异常 } else { next.prev = prev; // 将要删除节点的下一个节点指向要删除节点的上一个节点 x.next = null; // 将要删除节点的下一个节点设置为空 } x.item = null; // 将要删除节点的元素设置为空 size--; // 减少链表的元素个数 return element; // 返回被删除节点的元素 } remove(Object) 内部也调用了 unlink 方法，只不过在此之前要先找到元素所在的节点：\n/** * 从链表中删除指定元素。 * * @param o 要从链表中删除的元素 * @return 如果链表包含指定元素，则返回 true；否则返回 false */ public boolean remove(Object o) { if (o == null) { // 如果要删除的元素为 null for (Node\u003cE\u003e x = first; x != null; x = x.next) { // 遍历链表 if (x.item == null) { // 如果节点的元素为 null unlink(x); // 删除节点 return true; // 返回 true 表示删除成功 } } } else { // 如果要删除的元素不为 null for (Node\u003cE\u003e x = first; x != null; x = x.next) { // 遍历链表 if (o.equals(x.item)) { // 如果节点的元素等于要删除的元素 unlink(x); // 删除节点 return true; // 返回 true 表示删除成功 } } } return false; // 如果链表中不包含要删除的元素，则返回 false 表示删除失败 } ","categories":"Java基础能力","description":"`LinkedList` 是基于双向链表的数据结构, 实现队列和列表接口的所有方法, 允许存放任意类型元素","excerpt":"`LinkedList` 是基于双向链表的数据结构, 实现队列和列表接口的所有方法, 允许存放任意类型元素","ref":"/docs/basic/container/linkedlist/","tags":["链表","List"],"title":"LinkedList"},{"body":"内容来源:\n沉默王二 GitHub 上开源的知识库《Java 进阶之路》 ","categories":"Java基础能力","description":"关系性数据库, 程序员的入门教程","excerpt":"关系性数据库, 程序员的入门教程","ref":"/docs/basic/mysql/","tags":["MySQL"],"title":"MySQL"},{"body":"请说说 MySQL 的内联、左联、右联的区别。\r内联就是返回两张表都匹配的记录, 只返回两张表都存在的记录 左联, 返回左表所有记录, 不管右表是否有相匹配的记录,如果没有结果集中右表就填NULL 右联, 返回右表所有记录, 不管左表有没有匹配的记录\n订单表, 订单顾客映射表, 可以通过订单ID关联\n内联\nSELECT LEFT(a.title, 20) AS articleTitle, LEFT(c.content, 20) AS CommentContent FROM order a INNER JOIN ORDERCONSUMER c ON a.id = c.order_id LIMIT 2; 左联\nSELECT LEFT(a.title, 20) AS ArticleTitle, LEFT(c.content, 20) AS CommentContent FROM order a LEFT JOIN ORDERCONSUMER c ON a.id = c.article_id LIMIT 2; 右联\nSELECT LEFT(a.title, 20) AS ArticleTitle, LEFT(c.content, 20) AS CommentContent FROM comment c RIGHT JOIN article a ON a.id = c.article_id LIMIT 2; MySQL 第 3-10 条记录怎么查？\r使用 LIMIT 关键字, 结合第一个偏移量, 第二个行数\nSELECT * FROM table_name LIMIT 2, 8; mysql的数据引擎有哪些, 区别\r多种数据引擎, 常见的有 MyISAM, InnoDB, MEMORY 等 //todo\n查询优化、联合索引、覆盖索引\r","categories":"面试","description":"MySQL面试","excerpt":"MySQL面试","ref":"/interview/mysql/","tags":["MySQL"],"title":"MySQL"},{"body":"字符集\r计算机的世界里，它是只认识 0 和 1 的, 那汉字怎么办? 英文怎么办?\n我们在屏幕上看到的英文、汉字等字符是二进制数转换之后的结果\n通俗的说，按照何种规则将字符存储在计算机中，如’a’用什么表示，称为\"编码\"；反之，将存储在计算机中的二进制数解析显示出来，称为\"解码\",如果使用了错误的解码规则，则导致’a’解析成’b’或者乱码。\nASCII字符集\u0026编码\rASCII(American Standard Code for Information Interchange，美国信息交换标准代码)\n是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语\nASCII的最大缺点是只能显示26个基本拉丁字母、阿拉伯数目字和英式标点符号，因此只能用于显示现代美国英语\n已经淘汰\nGBXXXX字符集\u0026编码\r计算机发明之处及后面很长一段时间，只用应用于美国及西方一些发达国家，ASCII能够很好满足用户的需求。\n但是当天朝也有了计算机之后，为了显示中文，必须设计一套编码规则用于将汉字转换为计算机可以接受的数字系统的字符集。\n什么都有, 基本东亚文字全了\nGBK是对GB2312-80的扩展, 收录了繁体\nUnicode字符集\u0026UTF编码\r你说的对, 但是每个国家有自己的编码\n那网络聊天怎么办? 编码不同根本无法识别\n为了解决这个问题，一个伟大的创想产生了——Unicode。Unicode编码系统为表达任意语言的任意字符而设计。 被几种语言共用的字符通常使用相同的数字来编码, 不存在二义性。不再需要记录\"模式\"了\nMySQL的UTF-8最多支持三个字节\nUTF-8mb4支持四个字节\n比较规则\r","categories":"Java基础能力","description":"当我们创建数据库或者表的时候，就要指定字符集和比较规则。\r\r 不指定则MySQL 默认。","excerpt":"当我们创建数据库或者表的时候，就要指定字符集和比较规则。\r\r 不指定则MySQL 默认。","ref":"/docs/basic/mysql/mysql%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/","tags":["MySQL"],"title":"MySQL字符集和比较规则"},{"body":"十分钟快速上手MySQL\n创建数据库\rcreate database 数据库名; 提示:\n上下箭头可以切换之前执行的指令 记得加分号 切换数据库\ruse 数据库名; 删除数据库\r提示: 这个指令一般不用😂\ndrop database 数据库名; 了解 表\nJava交互MySQL\r上述都是命令行操作\n如何在Java程序对数据库进行操作?\n驱动 和显卡驱动, 网卡驱动类似, Java程序想要对MySQL做操作时也需要这样的桥梁\nMySQL Connector/J\nclasspath 也就是 src/main/resources 目录\n将下载的 .jar 包放到项目 classpath 下\n在IDE中写一个类连接到服务器\nclass DatabaseCreator { private static final String URL = \"jdbc:mysql://localhost:3306/?useSSL=false\u0026serverTimezone=UTC\"; private static final String USER = \"root\"; private static final String PASSWORD = \"Codingmore123\"; private static final String DATABASE_NAME = \"pai_coding\"; public static void main(String[] args) { try (Connection conn = DriverManager.getConnection(URL, USER, PASSWORD); Statement stmt = conn.createStatement()) { if (!databaseExists(conn, DATABASE_NAME)) { stmt.executeUpdate(\"CREATE DATABASE IF NOT EXISTS \" + DATABASE_NAME); System.out.println(\"数据库创建成功\"); } else { System.out.println(\"数据库已经存在\"); } } catch (SQLException e) { e.printStackTrace(); } } private static boolean databaseExists(Connection conn, String dbName) throws SQLException { ResultSet resultSet = conn.getMetaData().getCatalogs(); while (resultSet.next()) { if (dbName.equals(resultSet.getString(1))) { return true; } } return false; } } DriverManager.getConnection(URL, USER, PASSWORD)：通过 JDBC 建立到 MySQL 服务器的连接。\n初学者不需要完全明白这些代码\n","categories":"Java基础能力","description":"十分钟快速上手MySQL","excerpt":"十分钟快速上手MySQL","ref":"/docs/basic/mysql/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/","tags":["MySQL"],"title":"MySQL数据库操作"},{"body":"在日常的开发工作中，查询语句也是最常用的，因为表在一开始设计的时候已经确定了，后期很少去修改表结构，也就意味着插入数据的方式也是确定的\n但数据的展示方式却千奇百怪，用户端和 admin 管理端可能需要各种各样的数据，那 MySQL 就要提供最接近需求的数据，这样可以节省 Java 程序对数据的转换处理，也就相应提升了程序的性能。\nSELECT 语句可以灵活组织不同表的数据, 提供最接近需求的组合\n提示: 接下来的操作默认是单库操作 也就是说需要先选中某个数据库, 快去选择吧\n查询单个字段\r记录 我们把表中的每一行叫做一个“记录”，每一个记录包含这行中的所有信息，就像在通讯录数据库中某个人全部的信息，但记录在数据库中并没有专门的记录名，常常用它所在的行数表示这是第几个记录。\n字段 字段是比记录更小的单位，字段集合组成记录，每个字段描述文献的某一特征，即数据项，并有唯一的供计算机识别的字段标识符。\nSELECT 字段名 FROM 表名; 别名\r查出来的字段名字太长, 先更换名字 可以使用 AS 关键字，格式如下所示\nSELECT 字段名 AS 别名 FROM 表名; 这通常会在多表进行联合查询或者 Java 程序端和 MySQL 表字段不一致时使用。\n比如说，Java 程序端的字段名是 articleTitle，那我们就可以使用别名来解决这个问题。\nSELECT title AS articleTitle FROM article; 查询多个字段\r有时候我们需要同时拿到多个字段\nSELECT 字段1, 字段2, 字段3 FROM 表名; 查询所有字段\r了解 通配符\nSELECT * FROM 表名; 查询结果去重\r有可能多个记录会有相同的字段值, 这很正常 懒得一个个分辨可以去重 使用 DISTINCT 关键字进行查询\nSELECT DISTINCT 字段名 FROM 表名; 查询结果排序\r当结果集中需要排序时，可以使用 ORDER BY 关键字进行查询，格式如下所示：\nSELECT 字段名 FROM 表名 ORDER BY 字段名 [ASC|DESC]; 查询结果限制条数\r我们只想要其中的1条或多条, 从哪里开始找, 查找几行结束\nSELECT 字段名 FROM 表名 LIMIT 开始行,行数; 开始行也叫偏移量（OFFSET），默认是 0，可以缺省。\n了解: MySQL条件查询\n统计\r返回记录数\nSELECT COUNT(ProductID) FROM Products; 注意 此方法会忽略NULL记录!\nCOUNT(1)\nCOUNT(*)\ncount(1) 是计算所有记录数，1 被视作一个常数值，在每一行都存在，因此与 count(*) 基本相同。\nmysql的数据引擎有哪些?\r区别是什么?\n","categories":"Java基础能力","description":"在日常的开发工作中，查询语句也是最常用的","excerpt":"在日常的开发工作中，查询语句也是最常用的","ref":"/docs/basic/mysql/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2/","tags":["MySQL"],"title":"MySQL数据库查询"},{"body":"表是由不同数据类型的列组成的，然后填充了一行一行的数据。当我们要创建表的时候，就要根据业务需求，选择合适的数据类型。\n整数类型\r类型名称 存储空间 范围 tinyint 1 字节 -128 到 127 或者 0 到 255 int 4 字节 -2147483648 到 2147483647 或者 0 到 4294967295 bigint 8 字节 -9223372036854775808 到 9223372036854775807 或者 0 到 18446744073709551615 其实还有个 2 字节的 smallint 但是不常用\n设计表时\n对于状态\\类型字段使用 tinyint 记录id, 主键id等使用 bigint 其他用int 符号?\r这里注意, MySQL是存在有/无符号整型之分的, Java默认有符号\n当涉及到负数表示时, 为了兼容, Java中必须使用Long 型\n因为Java的int范围和MySQL不同分别是-2147483648 到 2147483647, 和 0 到 4294967295(无符号)\n所以在设计表时, 整数的符号也要考虑\n像自增 ID，肯定是无符号的，所以我们会在定义的时候将其设置为 unsigned\n显示宽度?\rCREATE TABLE `test` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `int10` int(10) NOT NULL, `int11` int(11) NOT NULL, `int` int NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 经常设计表的同学知道, int(10) 和 int(11) 指的是显示宽度的不同, 这里不涉及精度的问题, 多余的位用0填充\n就是视觉规定而已\n了解 ALEX 的博客写的很好\n","categories":"Java基础能力","description":"当我们要创建表的时候，就要根据业务需求，选择合适的数据类型。","excerpt":"当我们要创建表的时候，就要根据业务需求，选择合适的数据类型。","ref":"/docs/basic/mysql/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","tags":["MySQL"],"title":"MySQL数据类型"},{"body":"SELECT 查询没有查询条件。比如只返回姓名为xx的人, 年龄为xx的人等条件\n要知道，真实的业务场景中，数量会非常大，有些甚至会有几百万、几千万条数据，如果不带上查询条件，一次性把全部数据查出来是不太现实的。\n所以，我们通常要求在执行 SELECT 查询时，都要带上查询条件。那这一节，我们就来学习一些简单的 WHERE 条件查询。\n查询操作符\r操作符 示例 描述 = user_id = 1 等于 != 或 \u003c\u003e user_id != 1 或 user_id \u003c\u003e 1 不等于 \u003e user_id \u003e 1 大于 \u003c user_id \u003c 1 小于 \u003e= user_id \u003e= 1 大于等于 \u003c= user_id \u003c= 1 小于等于 示例: 查找id大于1000的文章\nSELECT title, user_id, create_time FROM article WHERE user_id \u003e 1000; 区间查询\r利用一个 \u003e= 和一个 \u003c=，配合 AND 关键字，就可以实现区间查询\nSELECT 字段名 FROM 表 WHERE user_id \u003e= 1000 AND user_id \u003c= 2000; 查询上下界id为1000 到 2000 的文章\n其实就是规定上下界 所以可以用 BETWEEN 代替\nSELECT title, user_id, create_time FROM article WHERE user_id BETWEEN 1000 AND 2000; 取反也可以, 加上 NOT 就行\nSELECT title, user_id, create_time FROM article WHERE user_id NOT BETWEEN 1000 AND 2000; 感觉比Python简单\n枚举查询\r当区间为1, 其实就是枚举, 这就不需要指定上下界了 我们可以直接指定数值 用 IN\n查询 user_id 是 1、2、3 的文章\nSELECT title, user_id, create_time FROM article WHERE user_id IN (1, 2, 3); 当然可以取反. 此略\n逻辑操作符\r除了数据操作符外还可以进行逻辑判断\n其实上文的 AND 就是一个\nAND 操作符用于组合多个查询条件，只有当所有的条件都满足时，才会返回结果\nSELECT title, user_id, create_time FROM article WHERE user_id != 1 AND title = 'something'; OR与其类似\n可以使用() 指定优先级\nSELECT title, user_id, create_time FROM article WHERE user_id != 1 AND (title = '聊聊分库分表' OR short_title != ''); in\nin查询相当于多个or条件的叠加，这个比较好理解，比如下面的查询：\nselect * from user where user_id in (1, 2, 3); exists\nselect * from user where exists (select * from user where user_id = 0); 这两个都是条件嵌套\n","categories":"Java基础能力","description":"真实的业务场景中，数量会非常大，有些甚至会有几百万、几千万条数据，如果不带上查询条件，一次性把全部数据查出来是不太现实的。","excerpt":"真实的业务场景中，数量会非常大，有些甚至会有几百万、几千万条数据，如果不带上查询条件，一次性把全部数据查出来是不太现实的。","ref":"/docs/basic/mysql/mysql%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/","tags":["MySQL"],"title":"MySQL条件查询"},{"body":"索引介绍\r我们知道一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，所以查询语句的优化显然是重中之重。\n**索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。通过存储指向数据行的指针，可以快速定位和访问表中的特定数据。\n开始之前, 我们直观的体会下索引\n如果要查询 mysql 单词, 我们就需要字符匹配, 首先是 m, y 之后是 s,q l 在接近上万条的记录中我们需要把整个表过一遍, 天哪 因此索引的目的就是为了缩小搜索范围来获取想要的数据结果 很容易想到将表分段, 通过确定某个分段的方式来获取数据\n了解: 数据结构-树\n索引的类型\r主键索引:\r数据表的主键列使用的就是主键索引。\n一张数据表只能有一个主键, 并且不能重复, 不能为NULL\nINNODB中, 引擎在没有显示指定主键的情况下, 会优先判断检查是否有唯一索引且没有NULL的字段, 如果有就选择该字段为默认的主键, 否则引擎自动创建一个自增主键\n","categories":"Java基础能力","description":"除了对于准备面试来说非常重要之外，善用索引对 SQL 的性能提升非常明显，是一个性价比较高的 SQL 优化手段。","excerpt":"除了对于准备面试来说非常重要之外，善用索引对 SQL 的性能提升非常明显，是一个性价比较高的 SQL 优化手段。","ref":"/docs/basic/mysql/mysql%E7%B4%A2%E5%BC%95/","tags":["MySQL"],"title":"MySQL索引"},{"body":"有了数据库以后，我们就可以在数据库中对表进行增删改查了\nMySQL是关系型数据库, 这个名词通俗来说就是把世界上的一切物体都实体化, 通过属性之间的关系管理数据\n实体化的结果叫做表, 数据库中以表为组织单位存储数据\n查表\r首先指定数据库\n查看当前数据库中的所有表，可以使用 show tables\n不首先指定数据库的话\nshow tables from 数据库名;\n提示: 这是查看表名的操作, 跟表结构没关系\n建表\rcreate table 表名( 列名1 数据类型1, 列名2 数据类型2, ... 列名n 数据类型n ); 了解: MySQL数据类型\n这里可能会遇到问题\n指示表已经存在了, 这时只能删掉以前的表 为了避免这种情况，我们可以在建表的时候，先判断表是否存在，如果不存在，再创建表，语法如下：\ncreate table if not exists 表名( 列名1 数据类型1, 列名2 数据类型2, ... 列名n 数据类型n ); 注释\r是的, 表也有注释, 在上百张表的情况下, 注释就很重要了\ncreate table 表名( 列名1 数据类型1 comment '注释1', 列名2 数据类型2 comment '注释2', ... 列名n 数据类型n comment '注释n' ) comment '表注释'; 查看表结构\rdesc 表名; describe 表名; explain 表名; show columns from 表名; show fields from 表名; 上述指令效果完全一样\n改表\r这需要一些数据库底层原理基础知识才能操作, 此处略过\n了解 MySQL数据库简单查询 MySQL字符集和比较规则\n","categories":"Java基础能力","description":"有了数据库以后，我们就可以在数据库中对表进行增删改查了","excerpt":"有了数据库以后，我们就可以在数据库中对表进行增删改查了","ref":"/docs/basic/mysql/mysql%E8%A1%A8%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","tags":["MySQL"],"title":"MySQL表操作"},{"body":"在前几章节中，我们已经学会了如何在一张表中读取数据，这是相对简单的，但是在真正的应用中经常需要从多个数据表中读取数据。\n连接分为三种 内, 左, 右\n内连接\rINNER JOIN 返回两个表中满足连接条件的匹配行，以下是 INNER JOIN 语句的基本语法\nSELECT column1, column2, ... FROM table1 INNER JOIN table2 ON table1.column_name = table2.column_name; table1.column_name = table2.column_name 是连接条件，指定了两个表中用于匹配的列。 左连接\rLEFT JOIN 返回左表的所有行，并包括右表中匹配的行，如果右表中没有匹配的行，将返回 NULL 值，以下是 LEFT JOIN 语句的基本语法：\nSELECT column1, column2, ... FROM table1 LEFT JOIN table2 ON table1.column_name = table2.column_name; 返回左表的所有行, 如果右表没有匹配就为NULL\n右连接\r不常使用, 因为可以用左连接交换表顺序达到相同效果\n","categories":"Java基础能力","description":"在前几章节中，我们已经学会了如何在一张表中读取数据，这是相对简单的，但是在真正的应用中经常需要从多个数据表中读取数据。","excerpt":"在前几章节中，我们已经学会了如何在一张表中读取数据，这是相对简单的，但是在真正的应用中经常需要从多个数据表中读取数据。","ref":"/docs/basic/mysql/mysql%E8%BF%9E%E6%8E%A5/","tags":["MySQL"],"title":"MySQL连接"},{"body":"","categories":"Java进阶能力","description":"动态决策中心, 当然可以理解为分布式的配置中心","excerpt":"动态决策中心, 当然可以理解为分布式的配置中心","ref":"/docs/advanced/nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/","tags":["分布式","中间件"],"title":"Nacos配置中心"},{"body":"重入性\r重入性指当线程需要再次获取同一把锁时, 不会因为自身而造成死锁, 锁的本质是作用于代码块或方法，而不是线程的整个执行上下文。即使线程已经持有锁，进入新的同步方法或代码块时，仍然需要执行获取锁的操作，确保锁的计数正确。\n所以支持重入性应该解决下列问题\n由于获得多次相同的锁, 需要计数以释放相同次数 相同线程再次获取锁应当直接成功, 防止死锁 为什么需要ReentrantLock\rJava语言直接提供了synchronized关键字用于加锁，但这种锁一是很重，二是获取时必须一直等待，没有额外的尝试机制。\nif (lock.tryLock(1, TimeUnit.SECONDS)) { try { ... } finally { lock.unlock(); } } java.util.concurrent.locks包提供的ReentrantLock用于替代synchronized加锁\n尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，tryLock()返回false，程序就可以做一些额外处理，而不是无限等待下去。\n所以，使用ReentrantLock比直接使用synchronized更安全，线程在tryLock()失败的时候不会导致死锁。\nReentrantLock使用\rpublic class Counter { //和关键字不同, 需要获得一个重入锁对象 private final Lock lock = new ReentrantLock(); private int count; public void add(int n) { //代码块加锁 lock.lock(); try { count += n; } finally { //在finally中解锁 lock.unlock(); } } } ","categories":"Java基础能力","description":"java.util.concurrent.locks包提供的ReentrantLock用于替代synchronized加锁","excerpt":"java.util.concurrent.locks包提供的ReentrantLock用于替代synchronized加锁","ref":"/docs/basic/concurrent/reentrantlock%E9%87%8D%E5%85%A5%E9%94%81/","tags":["并发编程"],"title":"ReentrantLock重入锁"},{"body":" 了解: WebSocket\n学习过 websocekt 后, 我们知道通过建立长连接可以实现 服务器和浏览器的双向推送 通过浏览器协调, 可以实现端对端的通信 webServer 初始化一个 Session 池作为核心容器, 当 webServer 在分布式中作为服务注入时, 其他服务也要调用消息怎么办?\n可以让其他服务作为消费者, 让服务生产消息, 但是webserver 一旦负责消息通讯和消息生产职责就不再单一, 需要解耦\n长连接传递的消息是即时的, 一旦连接断开消息就会丢失, 我们需要一个方法持久化消息\n长连接会阻塞服务线程, 建立连接后双方不得不占用一个线程持续的监听, 需要把监听的任务解耦出去. 一旦并发消息过多, 服务器可能会崩溃\n综上, 我们有了消息队列\n异步通信 场景描述：当系统中的应用程序需要异步通信时，可以使用消息中间件来实现。\n示例：在一个电商系统中，订单系统下单后需要给库存系统发送异步消息，以减少系统之间的耦合，避免同步调用导致的性能问题或响应延迟。\n优势：\n减少耦合：系统可以在不等待响应的情况下继续进行其他操作。 提高系统性能：减少了同步阻塞，提高了响应速度。 应用解耦 场景描述：当应用程序需要进行松耦合的通信时，可以使用消息中间件来实现。\n示例：在微服务架构中，不同服务之间可以通过消息中间件进行通信，避免直接调用服务导致的依赖关系过强。\n优势：\n降低耦合度：服务之间通过消息中间件进行通信，不需要直接调用，提高系统的灵活性。 增强可维护性：服务之间的更新和维护不影响其他服务。 消息排队 场景描述：当系统中需要处理大量的消息时，可以使用消息中间件来实现消息排队，确保消息的顺序和可靠性。\n示例：在金融行业中，需要处理大量的交易消息，消息中间件可以实现消息排队，确保每笔交易都得到正确处理。\n优势：\n保证消息顺序：确保按顺序处理每条消息。 消息可靠性：即使出现系统故障，未处理的消息仍然可以从队列中恢复。 负载均衡 场景描述：当系统需要处理大量的请求时，可以使用消息中间件来实现负载均衡。\n示例：在电商系统中，订单系统下单请求可以通过消息中间件发送到多个库存系统中，从而实现负载均衡。\n优势：\n分担负载：通过将消息分发到多个消费者，实现负载均衡，避免单点压力。 提高系统吞吐量：通过多节点并发处理提高系统处理能力。 系统削峰填谷 场景描述：当系统中出现高峰期时，可以使用消息中间件来平滑处理请求。\n示例：在电商系统中，双十一等促销活动可能会导致系统请求量急剧增加，消息中间件可以通过缓存请求，避免系统崩溃。\n优势：\n平滑流量：在高峰期通过消息队列缓存请求，避免系统过载。 提高系统稳定性：避免高并发请求导致的性能瓶颈或服务崩溃。 使用 RocketMQ\r并发环境下的消息队列用阿里提供的 RocketMQ 合适\nserver: port: ${sp.publish} spring: application: name: ${sn.publish} cloud: stream: rocketmq: binder: name-server: ${rocket-mq.name-server} bindings: output: producer: group: socketGroup sync: true bindings: output: destination: test-topic content-type: application/json #开启MQ的日志 logging: level: com: alibaba: cloud: stream: binder: rocketmq: DEBUG 项目依赖\n\u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-stream-rocketmq\u003c/artifactId\u003e \u003c/dependency\u003e 写 Swagger 配置, 不同于 webSocket mq作为异步消息组件可以用C-S模型, 也就是请求-响应模型, 我们从 swagger测试请求响应\n/** * \u003cp\u003e * 描述：Swagger配置 * \u003c/p\u003e * @author hamhuo * @version 1.0.0 */@Configuration @EnableSwagger2WebMvc public class SwaggerConfig { @Bean Docket rpApi() { return SwaggerCore.defaultDocketBuilder(\"消息推送\", \"com.zeroone.star.mq.controller\", \"publish\"); } } 消息发布组件 RmqPublish\n/** * \u003cp\u003e * 描述：消息发布组件 * \u003c/p\u003e * @author hamhuo * @version 1.0.0 */@Component public class RmqPublish { @Resource Source source; public void publish(SampleNotifyDTO dto) { source.output().send(MessageBuilder.withPayload(dto).build()); } } 这里通知DTO封装的是 websocket 的客户端id 和消息\n","categories":"Java进阶能力","description":"MQ的一种, 高并发常用","excerpt":"MQ的一种, 高并发常用","ref":"/docs/advanced/rocktmq/rocketmq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/","tags":["分布式","中间件"],"title":"RocketMQ"},{"body":"Servlet 是整个JavaWeb的核心\n当请求传入服务器后, 服务器会交给一个Servlet 处理, 该 Servlet 可以根据请求生成动态的内容\n查询数据库， 处理表单数据， 返回动态生成的 HTML 页面， 或者返回 JSON 数据供前端使用等。 之后 Servlet 会生成响应, 比如 HTML 或者 Json返回浏览器\n感性认识: Servlet 像是一个组件, 其中Java服务器使用的 Servlet 负责生成动态内容(请求处理), 其他 Servlet 负责处理静态资源, 错误页面等\n举个例子：\n如果你访问一个静态页面（如 index.html），Tomcat 会将这个静态页面直接返回给你。这就跟后端服务器没关系了, 直接在 Tomcat 中的某一个 Servlet 就能完成\n如果你访问一个动态页面（如使用 Spring MVC 的控制器来处理请求），Tomcat 会将请求交给 DispatcherServlet，然后 DispatcherServlet 会找到相应的 Controller，Controller 会生成一些数据，交给视图解析器，将模板与数据结合，最后生成一个完整的 HTML 页面。\n","categories":"Java基础能力","description":"Servlet 容器（也常称为 Servlet 容器或 Web 容器）是一个软件系统，它负责管理和处理 Web 应用程序中的 Servlet。","excerpt":"Servlet 容器（也常称为 Servlet 容器或 Web 容器）是一个软件系统，它负责管理和处理 Web …","ref":"/docs/basic/javaweb/servlet/","tags":["JavaWeb"],"title":"Servlet"},{"body":"","categories":"Java进阶能力","description":"MVC 也就是 Model-View-Controller, 这种模式用于应用程序的分层开发","excerpt":"MVC 也就是 Model-View-Controller, 这种模式用于应用程序的分层开发","ref":"/docs/advanced/springmvc/","tags":["Spring"],"title":"SpringMVC"},{"body":" 在 Java 中，关键字 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作) synchronized 的另外一个重要的作用，synchronized 可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到\nsynchronized 关键字最主要有以下 3 种应用方式：\n同步方法，为当前对象加锁，进入同步代码前要获得当前对象的锁； public class AccountingSync implements Runnable { //共享资源(临界资源) static int i = 0; // synchronized 同步方法 public synchronized void increase() { i ++; } @Override public void run() { for(int j=0;j\u003c1000000;j++){ increase(); } } public static void main(String args[]) throws InterruptedException { AccountingSync instance = new AccountingSync(); Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(\"static, i output:\" + i); } } 同步静态方法，为当前类加锁，进入同步代码前要获得当前类的锁； public class AccountingSyncClass implements Runnable { static int i = 0; /** * 同步静态方法,锁是当前class对象，也就是 * AccountingSyncClass类对应的class对象 */ public static synchronized void increase() { i++; } // 非静态,访问时锁不一样不会发生互斥 public synchronized void increase4Obj() { i++; } @Override public void run() { for(int j=0;j\u003c1000000;j++){ increase(); } } public static void main(String[] args) throws InterruptedException { //new新实例 Thread t1=new Thread(new AccountingSyncClass()); //new新实例 Thread t2=new Thread(new AccountingSyncClass()); //启动线程 t1.start();t2.start(); t1.join();t2.join(); System.out.println(i); } } /** * 输出结果: * 2000000 */ 同步代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 public class AccountingSync2 implements Runnable { static AccountingSync2 instance = new AccountingSync2(); // 饿汉单例模式 static int i=0; @Override public void run() { //省略其他耗时操作.... //使用同步代码块对变量i进行同步操作,锁对象为instance synchronized(instance){ for(int j=0;j\u003c1000000;j++){ i++; } } } public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(instance); Thread t2=new Thread(instance); t1.start();t2.start(); t1.join();t2.join(); System.out.println(i); } } 这里的锁指的是 Java 内置的隐式锁 monitor 也是 synchronized 封装好的实现 每个对象都有一个对象锁，不同的对象，他们的锁不会互相影响。\nsynchronized 与 happens before\n[[JMM内存模型]]\n","categories":"Java基础能力","description":"关键字 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)，同时我们还应该注意到 synchronized 的另外一个重要的作用，synchronized 可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代 volatile 功能）。","excerpt":"关键字 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操 …","ref":"/docs/basic/concurrent/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/","tags":["并发编程"],"title":"synchronized关键字"},{"body":" 前置 线程池\n是 Java 中提供的一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离，用于解决多线程中共享对象的线程安全问题。\n使用:\n创建 ThreadLocal对象\n//创建一个ThreadLocal变量 public static ThreadLocal\u003cString\u003e localVariable = new ThreadLocal\u003c\u003e(); 设置值\n//设置ThreadLocal变量的值 localVariable.set(\"0001\"); 获取值\n//获取ThreadLocal变量的值 String value = localVariable.get(); 优点\n线程隔离 实现了变量的独占, 使变量不需要同步处理\n数据传递方便 ThreadLocal 常用于在跨方法、跨类时传递上下文数据（如用户信息等），而不需要在方法间传递参数。\nThreadLocalMap\rThreadLocalMap, 一个key-value数据形式结构，也是ThreadLocal的核心。\nMap内部维护了一个Entry数组, 真正的数据存储在 Entry中, map的key是每个线程中ThreadLocal对象的哈希, value是隔离变量\n/** * 初始容量 */ private static final int INITIAL_CAPACITY = 16; /** * ThreadLocalMap数据真正存储在table中 */ private Entry[] table; /** * ThreadLocalMap条数 */ private int size = 0; /** * 达到这个大小，则扩容 */ private int threshold; // 默认为0 为了保证Entry[] 数组散步均匀, 哈希算法如下\n把对应的 key 映射到 table 数组的相应下标，ThreadLocalMap 用的是哈希取余法，取出 key 的 threadLocalHashCode，然后和 table 数组长度减一\u0026运算（相当于取余）。\nint i = key.threadLocalHashCode \u0026 (table.length - 1); 这里的hashcode由魔术数生成 每创建一个 ThreadLocal 对象，它就会新增0x61c88647，这个值很特殊，它是斐波那契数 也叫 黄金分割数。hash增量为 这个数字，带来的好处就是 hash 分布非常均匀。\nInheritableThreadLocal()\r父子线程是无法传输数据的, 但是通过InheritableThreadLocal实例就可以在子线程拿到值\npublic class InheritableThreadLocalTest { public static void main(String[] args) { final ThreadLocal threadLocal = new InheritableThreadLocal(); // 主线程 threadLocal.set(\"父线程\"); //子线程 Thread t = new Thread() { @Override public void run() { super.run(); System.out.println(\"子线程 ，\" + threadLocal.get()); } }; t.start(); } } 原理:\n在Thread中有一个变量\nThreadLocal.ThreadLocalMap inheritableThreadLocals = null; if (inheritThreadLocals \u0026\u0026 parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); 在 Thread.init 的时候，如果父线程的inheritableThreadLocals不为空，就把它赋给当前线程（子线程）的inheritableThreadLocals 。\n","categories":"Java基础能力","description":"ThreadLocal 是Java中 lang 包下的一个类，是用来解决多线程下共享变量并发问题的，所谓共享变量即同一个变量在不同线程下赋予不同值, 而ThreadLocal会在不同线程中维护共享变量的独立副本","excerpt":"ThreadLocal 是Java中 lang 包下的一个类，是用来解决多线程下共享变量并发问题的，所谓共享变量即同一个变量在不同线程下赋予 …","ref":"/docs/basic/concurrent/threadlocal/","tags":["并发编程"],"title":"ThreadLocal"},{"body":"TransmittableThreadLocal (TTL) 是增强版的 ThreadLocal\n前置: ThreadLocal, 拦截器\n实现TTL\r流程图如下\n前置: Gateway网关\n上半部分业务为用户请求登录并返回Token 该业务从MVC剥离, 设置在网关进行\n我们主要关注下半部分, 用户携带 Token 后如何在服务层获取用户信息\n整体流程为:\n用户登录请求：\n用户通过提交用户名和密码进行登录，经过网关的认证，认证服务（如 Auth）验证用户身份并生成 token。 登录请求返回 token 给用户，用户保存 token。 后续请求携带 Token 登录：\n用户在后续请求中携带该 token，这个 token 用于证明用户的身份。 Nginx 负载均衡：\n请求首先被发送到 Nginx，Nginx 会根据负载均衡策略将请求转发到具体的 网关（Gateway）。 网关鉴权：\n网关负责根据请求中的 token 进行 鉴权，验证该 token 是否有效。如果验证通过，网关会继续转发请求；如果验证失败，则拒绝请求或重定向至登录页面。 拦截器将用户信息放入 TTL：\n在请求经过网关后，网关会调用拦截器（如 HeaderInterceptor）。拦截器会提取请求中的用户信息（如 token 解密后的用户信息），然后将这些信息存放到 TTL（Thread-Local）中。 TTL 是一种线程局部存储机制，用于在当前线程内传递数据，确保在同一请求的生命周期内，后续的服务（如 ProjectService 等）能够访问到这些用户信息。 后续服务从 TTL 获取用户信息：\n后续的服务（如 ProjectService）可以通过访问当前线程的 TTL 中的数据来获取用户信息，而无需每次都从请求中提取或解析 token。 我们所关注的 TTL 在拦截器里实现\n新建 HeaderInterceptor.java\npublic class HeaderInterceptor implements AsyncHandlerInterceptor 该拦截器实现了拦截器接口, 该业务在请求执行之前执行拦截业务逻辑, 所以重写 preHandle 在请求执行完毕后需要删除用户信息, 所以重写 afterCompletion\npublic class HeaderInterceptor implements AsyncHandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { } 首先是 preHandle\npublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //不是控制器方法不拦截 if (!(handler instanceof HandlerMethod)) { return true; } //自定义holder 用来设置信息 SecurityContextHolder.setUserId(ServletUtils.getHeader(request, SecurityConstants.DETAILS_USER_ID)); SecurityContextHolder.setUserName(ServletUtils.getHeader(request, SecurityConstants.DETAILS_USERNAME)); SecurityContextHolder.setUserKey(ServletUtils.getHeader(request, SecurityConstants.USER_KEY)); //根据Token创建用户 String token = SecurityUtils.getToken(); if (StringUtils.isNotEmpty(token)) { LoginUser loginUser = AuthUtil.getLoginUser(token); if (StringUtils.isNotNull(loginUser)) { AuthUtil.verifyLoginUserExpire(loginUser); SecurityContextHolder.set(SecurityConstants.LOGIN_USER, loginUser); } } else { // 首页免登场景展示 // 检查请求路径是否匹配特定路径 String requestURI = request.getRequestURI(); if (isExemptedPath(requestURI)) { // 创建一个默认的 LoginUser 对象 LoginUser defaultLoginUser = createDefaultLoginUser(); SecurityContextHolder.set(SecurityConstants.LOGIN_USER, defaultLoginUser); } } return true; } 这里使用 TTL的就是 设置信息的工具类\npublic class SecurityContextHolder{ //TTL private static final TransmittableThreadLocal\u003cMap\u003cString, Object\u003e\u003e THREAD_LOCAL = new TransmittableThreadLocal\u003c\u003e(); //设置方法, 在线程Map中存储私有信息 public static void set(String key, Object value) { Map\u003cString, Object\u003e map = getLocalMap(); map.put(key, value == null ? StringUtils.EMPTY : value); } //这里只就一个例子, 存储固定的用户名前缀和用户名的方法 public static void setUserName(String username) { set(SecurityConstants.DETAILS_USERNAME, username); } } 最后添加其他方法\nstatic { // 在这里添加所有需要免登录默认展示首页的的路径 EXEMPTED_PATHS.add(\"/system/user/getInfo\"); EXEMPTED_PATHS.add(\"/project/statistics\"); EXEMPTED_PATHS.add(\"/project/doing\"); EXEMPTED_PATHS.add(\"/project/queryMyTaskList\"); EXEMPTED_PATHS.add(\"/project/select\"); EXEMPTED_PATHS.add(\"/system/menu/getRouters\"); } // 需要免登录的路径集合 private static final Set\u003cString\u003e EXEMPTED_PATHS = new HashSet\u003c\u003e(); // 判断请求路径是否匹配特定路径, 也就是免密白名单 private boolean isExemptedPath(String requestURI) { // 你可以根据需要调整特定路径的匹配逻辑 return EXEMPTED_PATHS.stream().anyMatch(requestURI::startsWith); } // 创建一个默认的 LoginUser 对象 private LoginUser createDefaultLoginUser() { LoginUser defaultLoginUser = new LoginUser(); defaultLoginUser.setUserId(173L); // 设置默认的用户ID defaultLoginUser.setUsername(Constants.DEMO_ACCOUNT); // 设置默认的用户名 SysUser demoSysUser = new SysUser(); demoSysUser.setUserId(173L); demoSysUser.setUserName(Constants.DEMO_ACCOUNT); demoSysUser.setDeptId(100L); demoSysUser.setStatus(\"0\"); defaultLoginUser.setUser(demoSysUser); // 设置其他必要的默认属性 return defaultLoginUser; } //结束后清理用户信息, 防止线程复用导致内存泄露 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { SecurityContextHolder.remove(); } ","categories":"Java进阶能力","description":"基于 TransmittableThreadLocal (TTL) 自定义请求头拦截器，将Header 数据封装到线程变量中方便获取，减少用户信息数据库查询次数，同时验证当前用户有效期自动刷新有效期。","excerpt":"基于 TransmittableThreadLocal (TTL) 自定义请求头拦截器，将Header 数据封装到线程变量中方便获取，减少用 …","ref":"/docs/advanced/transmittablethreadlocalttl/","tags":["并发编程","分布式"],"title":"TTL"},{"body":"什么是 volatile\r为什么要使用 volatile\r[[线程安全问题]]\n","categories":"Java基础能力","description":"volatile 可以保证可见性，但不保证原子性：\r\r当写一个 volatile 变量时，JMM 会把该线程在本地内存中的变量强制刷新到主内存中去；\r这个写操作会导致其他线程中的 volatile 变量缓存无效。","excerpt":"volatile 可以保证可见性，但不保证原子性：\r\r当写一个 volatile 变量时，JMM 会把该线程在本地内存中的变量强制刷新到主内 …","ref":"/docs/basic/concurrent/volatile%E5%85%B3%E9%94%AE%E5%AD%97/","tags":["并发编程"],"title":"volatile关键字"},{"body":"如果需要定期给浏览器推送数据，例如股票行情，或者不定期给浏览器推送数据，例如在线聊天，基于HTTP协议实现这类需求，只能依靠浏览器的JavaScript定时轮询，效率很低且实时性不高。\n2009年出现的新技术Websocket 允许建立浏览器客户端和服务端之间的双向连接, 并且发送轻量级的数据模型, 服务端可以在需要时直接向客户端推送消息\n不同于传统的Http ,Websocket 允许建立通路, 可以直接发送信息而不需像HTTP一样创建连接上下文, 原理如下\n在建立TCP连接后, 附带几个请求头\nGET /chat HTTP/1.1 Host: www.example.com Upgrade: websocket Connection: Upgrade 此后连接升级为长连接\nHTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade 收到成功响应后表示WebSocket“握手”成功，这样，代表WebSocket的这个TCP连接将不会被服务器关闭，而是一直保持，服务器可随时向浏览器推送消息，浏览器也可随时向服务器推送消息。双方推送的消息既可以是文本消息，也可以是二进制消息，一般来说，绝大部分应用程序会推送基于JSON的文本消息。\n使用 Websocket\r开始前阅读 架构说明\n建立新模块 sample-ws\n\u003c!-- ws --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-websocket\u003c/artifactId\u003e \u003c/dependency\u003e 启动类\n/** * 描述：程序启动入口 * * @author hamhuo * @version 1.0.0 */@SpringBootApplication @EnableBinding(Sink.class) @EnableDiscoveryClient public class WsApplication { public static void main(String[] args) { SpringApplication.run(WsApplication.class, args); } } 实现服务端和浏览器的双向通信, 我们要写一个服务器\n@Component @ServerEndpoint(\"/chat\") public class ChatServer { /** * 保存连接对象, 连接池, 放用户session和key */ private static final ConcurrentHashMap\u003cString, Session\u003e SESSION_POOL = new ConcurrentHashMap\u003c\u003e(); @OnOpen public void onOpen(Session session) @OnMessage public String onMessage(String text, Session session) @OnClose public void onClose(Session session) @OnError public void onError(Session session, Throwable throwable) } 解释一下\n首先组件注解加上, Spring 会自动装载为组件\n关于 @ServerEndpoint WebSocket 是一种基于 TCP 的协议，它是持久化连接，通信过程中不会像 HTTP 请求那样每次都经过请求-响应的流程，因此不能直接通过传统的 Spring MVC 控制器方法来处理。\n@ServerEndpoint 是 WebSocket 规范中的一种标注方式，用来标识一个 WebSocket 服务器端点。当客户端连接到这个端点时，会自动调用这个类中的相应方法。\n我们只需要知道服务器与 /server 绑定即可\n我们在server中定义了四个方法, 启动时调用, 消息时调用, 关闭时调用, 错误时调用\n我们创建一个链接池, 存放浏览器和服务器的长连接\n这个端点注解依赖一个配置类\n我们在 ws.config 下新建一个配置类 ,这是写死的, 不用理解\n/** * @program: demo * @description: 服务端点配置 * @author: hamhuo **/ @Configuration @EnableWebSocket public class WebSocketConfig { @Bean public ServerEndpointExporter serverEndpoint() { return new ServerEndpointExporter(); } } 当浏览器首先试图建立与服务器的连接, 这里调用 @OnOpen 注解方法\n@OnOpen public void onOpen(Session session) throws IOException { //判断客户端对象是否存在 //排除重复的连接对象 if (SESSION_POOL.containsKey(session.getQueryString())) { CloseReason reason = new CloseReason(CloseReason.CloseCodes.CANNOT_ACCEPT, \"ID冲突，连接拒绝\"); session.getUserProperties().put(\"reason\", reason); session.close(); return; } //将客户端记录到Map中 SESSION_POOL.put(session.getQueryString(), session); System.out.println(\"客户端（\" + session.getQueryString() + \"）：开启连接\"); } 解释一下, 浏览器会传入一个客户端ID, 服务器根据ID来提供服务\n每个ID标识了长连接, 服务器根据ID提供服务\n传入连接后判断是否重复, 从连接池拿session里的key, 如果重复就拒绝连接 没有重复, 将Session保存到连接池(Map)里 控制套打印日志, 这里可以用slf4j 注意: 这里的Session 指的是长连接, 和 HTTP Session 不是一个东西\n之后长连接建立, 可以双向监听信息, 一旦服务器或者浏览器有信息了就调用 @OnMessage\n@OnMessage public String onMessage(String text, Session session) throws IOException { //解析消息 =\u003e ID::消息内容 String[] msgArr = text.split(\"::\", 2); //群发消息 ID=all表示群发 if (\"all\".equalsIgnoreCase(msgArr[0])) { for (Session one : SESSION_POOL.values()) { //排除自己 if (session == one) { continue; } //发送消息 one.getBasicRemote().sendText(msgArr[1]); } } //指定发送人, 不是all的情况 else { Session target = SESSION_POOL.get(msgArr[0]); if (target != null) { target.getBasicRemote().sendText(msgArr[1]); } } return session.getQueryString() + \":消息发送成功\"; } 消息发送的方式有两种, 点对点和群发\n点对点就找出目标Session, 服务器向Session写信息发送就行 群发就需要遍历连接池的每一个Session, 全部写信息\n当然, 前提是排除发送者的Session\n关闭连接, 也就是浏览器离线需要执行线程池移除线程的操作, 调用 @OnClose 方法 这里注意, webSocket并没有强制关闭连接的能力, 这是通知远程连接自主关闭, 服务器只负责监视是否关闭\n@OnClose public void onClose(Session session) { //处理拒绝连接session关闭对象, 不从池子里移除 Object obj = session.getUserProperties().get(\"reason\"); if (obj instanceof CloseReason) { CloseReason reason = (CloseReason) obj; if (reason.getCloseCode() == CloseReason.CloseCodes.CANNOT_ACCEPT) { System.out.println(\"拒绝客户端（\" + session.getQueryString() + \"）：关闭连接\"); return; } } //将session对象从map中移除,正常关闭 SESSION_POOL.remove(session.getQueryString()); System.out.println(\"客户端（\" + session.getQueryString() + \"）：关闭连接\"); } 这是比较简单的应用不再考虑连接复用的问题\n接下来写浏览器页面\n这里我们略过了~\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e聊天室客户端\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eChat Client\u003c/h1\u003e \u003cdiv\u003e \u003cinput id=\"clientId\" placeholder=\"输入ID\" value=\"1\"\u003e \u003cinput onclick=\"init()\" value=\"连接服务器\" type=\"button\"\u003e\u003cbr\u003e\u003cbr\u003e \u003cinput id=\"receiverId\" placeholder=\"输入接收人ID\" value=\"all\"\u003e\u003cbr\u003e\u003cbr\u003e \u003ctextarea id=\"message\" style=\"margin: 0; height: 197px; width: 362px;\" placeholder=\"发送消息内容\"\u003e\u003c/textarea\u003e\u003cbr\u003e \u003cinput onclick=\"send()\" value=\"发送消息\" type=\"button\"\u003e \u003cinput onclick=\"closeConnect()\" value=\"关闭连接\" type=\"button\"\u003e \u003c/div\u003e \u003cdiv id=\"output\"\u003e\u003c/div\u003e \u003cscript type=\"text/javascript\" language=\"JavaScript\"\u003e //屏幕回显输出方法 function writeToScreen(message) { let pre = document.createElement(\"p\"); pre.style.wordWrap = \"break-word\"; pre.innerHTML = message; document.getElementById(\"output\").appendChild(pre); } //初始化websocket let echo_websocket; function init() { let clientId = document.getElementById(\"clientId\").value; /* 这里端口是写死的 */ let wsUri = \"ws://localhost:10800/chat?\" + clientId; writeToScreen(\"连接到\" + wsUri); //1.创建WebSocket客户端对象 echo_websocket = new WebSocket(wsUri); //2.开门握手完成回调 echo_websocket.onopen = function (evt) { console.log(evt); writeToScreen(\"连接打开成功 !\"); }; //3.监听服务端的消息 echo_websocket.onmessage = function (evt) { writeToScreen(\"接收服务端消息:\u003cbr\u003e \" + evt.data); }; //4.如果连接中断 echo_websocket.onerror = function (evt) { writeToScreen('\u003cspan style=\"color: red;\"\u003eERROR:'+evt.data+'\u003c/span\u003e'); //关闭连接 closeConnect(); }; //5.注册close事件 echo_websocket.onclose = function(evt){ writeToScreen('\u003cspan style=\"color: green;\"\u003eINFO：关闭连接\u003c/span\u003e '); if(evt.reason){ writeToScreen (`\u003cspan style=\"color: red;\"\u003e错误信息：${evt.reason}\u003c/span\u003e `); } } } //6.向服务发送消息 function send() { let message = document.getElementById(\"message\").value; let receiver = document.getElementById(\"receiverId\").value; echo_websocket.send(receiver + \"::\" + message); writeToScreen(\"发送消息: \" + message); } //7.如果不需要通讯，那么关闭连接 function closeConnect() { echo_websocket.close(); } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 我们需要解释下构建/发送信息的代码\n//6.向服务发送消息 function send() { let message = document.getElementById(\"message\").value; let receiver = document.getElementById(\"receiverId\").value; echo_websocket.send(receiver + \"::\" + message); writeToScreen(\"发送消息: \" + message); } 这里拿到表单组件, 取值后通过 :: 拼接为消息, 链接符之前为id, 之后为消息\n其中初始化的 echo_websocket 组件是dom库提供的 echo_websocket = new WebSocket(wsUri); , 除了IE其他浏览器都支持\n在前端打开三个浏览器页面, 作为三个客户端\n注意id要不同\n后台运行服务器, 就可以开始监听了\n","categories":"Java进阶能力","description":"HTTP只能单向向服务器请求, 如果要实现服务器通知, 就必须由客户端轮询, 压力非常大. 并且HTTP会携带无效信息, 延迟很高\n因此出现了WebSocket","excerpt":"HTTP只能单向向服务器请求, 如果要实现服务器通知, 就必须由客户端轮询, 压力非常大. 并且HTTP会携带无效信息, 延迟很高\n因此出现 …","ref":"/docs/advanced/websocket/","tags":["JavaWeb"],"title":"WebSocket"},{"body":" 引用: go语言大佬, go语言设计与原理作者 [面向信仰编程 - draveness](https://draveness.me/mysql-innodb/\n在关系型数据库中，事务的重要性不言而喻，只要对数据库稍有了解的人都知道事务具有 ACID 四个基本属性，\n而我们不知道的可能就是数据库是如何实现这四个属性的；在这篇文章中，我们将对事务的实现进行分析，尝试理解数据库是如何实现事务的，当然我们也会在文章中简单对 MySQL 中对 ACID 的实现进行简单的介绍。\n原子性, 一致性, 隔离性, 持久性 ACID\n原子性\r事务就是一系列的操作，要么全部都执行，要都不执行，这其实就是对事务原子性的刻画\n如果事务不具备原子性，那么就没办法保证同一个事务中的所有操作都被执行或者未被执行了，整个数据库系统就既不可用也不可信。\n数据库的事务提交也是多线程并发的, 适用并发编程\n持久性\r数据被写入到数据库中，那么数据一定能够被安全存储在磁盘上, 这就是持久性\n可能会奇怪, 除非硬盘挂掉, 为什么会存在持久性问题呢\n其实持久性并非问题, 而是一种原则\n一旦事务被提交，那么数据一定会被写入到数据库中并持久存储起来。 也就是当数据被写到硬盘后, 不允许撤销!\n当事务已经被提交之后，就无法再次回滚了，唯一能够撤回已经提交的事务的方式就是创建一个相反的事务对原操作进行『补偿』，这也是事务持久性的体现之一。\n隔离性\r数据库的事务之间没有隔离性, 就会发生级联回滚的问题, 造成性能上的巨大损失\n如果所有的事务的执行顺序都是线性的，那么对于事务的管理容易得多，但是允许事务的并行执行却能能够提升吞吐量和资源利用率，并且可以减少每个事务的等待时间。\n一致性\r分为两种一致性\nACID 和 CAP\n其中ACID定义为, 如果事务原子性的一个一致的数据库中独立运行, 那么执行之后数据库的状态是一定的, 在事务的执行的前后以及过程中不会违背对数据完整性的约束, 所有对数据库写入的操作都应该是合法的，并不能产生不合法的数据状态。\nCAP则是通常的一致性, 其实是说分布式系统中的各个节点中对于同一数据的拷贝有着相同的值, 也就是存储可见性\n","categories":"Java基础能力","description":"在关系型数据库中，事务的重要性不言而喻，只要对数据库稍有了解的人都知道事务具有 ACID 四个基本属性","excerpt":"在关系型数据库中，事务的重要性不言而喻，只要对数据库稍有了解的人都知道事务具有 ACID 四个基本属性","ref":"/docs/basic/mysql/%E4%BA%8B%E5%8A%A1/","tags":["MySQL"],"title":"事务"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/advanced/reactor%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%BA%93/","tags":"","title":"响应式编程Reactor库"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/advanced/%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%9C%8D%E5%8A%A1/","tags":"","title":"声明式服务"},{"body":"为什么要实现多线程?\r[!前置] 线程与进程\n进程使得操作系统可以并发的执行任务 但是在一段时间内单个进程只能执行一个任务 进程内的子任务只能逐个按顺序执行, 效率还有提升空间\n因此提出线程概念, 使得一个线程可以执行一个子任务使得进程内部也可实现并发, 提高效率\n[!NOTE] 多线程的优势\n进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信很容易。\n进程是重量级的，而线程是轻量级的，多线程方式的系统开销更小。\nJava中创建线程的三种方式\n继承 Thread 类\r重写 run 方法\npublic class MyThread extends Thread { @Override public void run() { for (int i = 0; i \u003c 100; i++) { System.out.println(getName() + \":打了\" + i + \"个小兵\"); } } } 主函数启动线程\n//创建MyThread对象 MyThread t1=new MyThread(); MyThread t2=new MyThread(); MyThread t3=new MyThread(); //设置线程的名字 t1.setName(\"鲁班\"); t2.setName(\"刘备\"); t3.setName(\"亚瑟\"); //启动线程 t1.start(); t2.start(); t3.start(); 实现 Runnable 接口\r创建任务类实现 Runnable 接口\npublic class MyRunnable implements Runnable { @Override public void run() { for (int i = 0; i \u003c 10; i++) { try {//sleep会发生异常要显式处理 Thread.sleep(20);//暂停20毫秒 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"打了:\" + i + \"个小兵\"); } } } 主函数启动线程\n//创建MyRunnable类 MyRunnable mr = new MyRunnable(); //创建Thread类的有参构造,并设置线程名 Thread t1 = new Thread(mr, \"张飞\"); Thread t2 = new Thread(mr, \"貂蝉\"); Thread t3 = new Thread(mr, \"吕布\"); //启动线程 t1.start(); t2.start(); t3.start(); 实现 Callable\u003c\u003e 接口\r[!NOTE] 相较于 Runnable 接口 callable\u003c\u003e 可以获取线程的执行结果, 使用 FutureTask 类存储 了解 [[获取线程执行结果]]\n重写 call\u003c\u003e 方法\npublic class CallerTask implements Callable\u003cString\u003e { public String call() throws Exception { return \"Hello,i am running!\"; } } 主函数启动线程\n//创建异步任务 FutureTask\u003cString\u003e task=new FutureTask\u003cString\u003e(new CallerTask()); //启动线程 new Thread(task).start(); try { //等待执行完成，并获取返回结果 String result=task.get(); System.out.println(result); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } 了解: 线程生命周期\n","categories":"Java基础能力","description":"并发编程入口","excerpt":"并发编程入口","ref":"/docs/basic/concurrent/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/","tags":["并发编程"],"title":"多线程入门"},{"body":"在计算机执行时，几乎每一条指令都涉及对存储器的访问，存储器的速度必须非常快，能与处理机的速度相匹配，否则会明显地影响到处理机的运行。\n存储层次至少应具有三级：\n最高层为CPU寄存器，中间为主存，最底层是辅存。\n其中寄存器和主存也被称为 可执行存储器\n可执行存储器\n是通过访问方式区分的\n可执行存储器 使用一条load或store指令对可执行存储器进行访问。\n对辅存的访问则需要通过I/O设备实现。\n主存储器\n主存储器 主存储器简称内存或主存，\n是计算机系统中的主要部件，\n用于保存进程运行时的程序和数据，也称可执行存储器\n寄存器\n寄存器具有与处理机相同的速度，\n故对寄存器的访问速度最快，完全能与CPU协调工作，\n但价格却十分昂贵，因此容量不可能做得很大。\n[高速缓存](CPU Cache 高速缓存)\n高速缓存是介于寄存器和存储器之间的存储器，\n主要用于备份主存中较常用的数据，\n以减少处理机对主存储器的访问次数，\n这样可大幅度地提高程序执行速度。\n磁盘缓存\n目前磁盘的I/O速度远低于对主存的访问速度，\n为了缓和两者之间在速度上的不匹配，而设置了磁盘缓存，主要用于暂时存放频繁使用的一部分磁盘数据和信息， 以减少访问磁盘的次数。\n","categories":"通用能力","description":"在计算机执行时，几乎每一条指令都涉及对存储器的访问，存储器的速度必须非常快，能与处理机的速度相匹配，否则会明显地影响到处理机的运行。","excerpt":"在计算机执行时，几乎每一条指令都涉及对存储器的访问，存储器的速度必须非常快，能与处理机的速度相匹配，否则会明显地影响到处理机的运行。","ref":"/docs/general/os/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/","tags":["操作系统"],"title":"存储器的层次结构"},{"body":"","categories":"Java基础能力","description":"定义一个用于创建对象的接口，让子类决定实例化哪一个类。","excerpt":"定义一个用于创建对象的接口，让子类决定实例化哪一个类。","ref":"/docs/basic/designpatterns/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/","tags":["设计模式"],"title":"工厂方法"},{"body":"","categories":"","description":"Low level reference docs for your project.","excerpt":"Low level reference docs for your project.","ref":"/docs/general/os/","tags":"","title":"操作系统"},{"body":"并发\rOS能够提高系统资源利用率的原因\n并发是指多个任务在同一时间段内被处理，但并不意味着它们必须是同时发生的。实际上，处理器可能会在同一时刻只能处理一个任务，但操作系统通过切换任务的方式让多个任务在短时间间隔内“交替”执行。\n并发的关键特点是：在同一时间段内，多个任务会被交替执行，这种交替执行给人感觉是同时进行的。操作系统调度器负责任务切换。 共享\r在操作系统中，共享资源需要控制不同进程或线程的访问，常见的控制方式有 互斥 和 同时。\n共享资源是指多个进程或线程可以访问同一块内存或设备资源。例如，多个进程同时访问打印机、磁带机等共享设备。 操作系统中的共享通常是通过 锁机制（如互斥锁、读写锁等）来避免资源竞争问题，确保资源访问的有序性。 1. 互斥\r互斥是指在某一时间，只能允许一个进程或线程访问共享资源，防止并发执行时的资源冲突。\n例如，打印机是共享资源，但同一时刻只能由一个进程打印，其他进程需等待。 操作系统通过 互斥锁（Mutex） 来保证同一时间内只有一个进程（或线程）能访问资源。 2. 同时\r同时是指多个进程或线程在时间上交替执行共享资源的访问请求，而非在同一时刻访问。 例如，某个设备在微观上并不是完全同时被多个进程访问，而是交替执行。\n虚拟\r操作系统通过软件技术为应用程序和用户提供的一种抽象和隔离机制，使得多个程序可以在相同的硬件资源上独立运行，并且每个程序认为它独占系统资源，实际上是操作系统通过合理调度和资源分配来共享这些资源。\n时分复用（Time Division Multiplexing, TDM）\r时分复用是指通过时间片轮转的方式将处理器时间分配给多个用户或任务。每个用户在指定的时间段内占用资源，其他用户则需等待空闲时间。\n例子：操作系统通过时间片轮转的方式将 CPU 时间分配给各个进程，保证每个进程都有机会执行。 空分复用（Frequency Division Multiplexing, FDM）\r空分复用通过将频带划分成多个较小的频带来为不同的通信用户提供服务，每个用户在一个独立的频带内通信。\n例子：在无线通信中，多个通信设备通过不同的频率带宽进行通讯。每个设备占用一个特定频段。 异步\r在多道程序并发的环境下，每个程序何时执行、何时暂停 都是未知的，即他们以不可预知的速度向前推进，\n操作系统 应当保证程序执行结果的可再现性。\n执行顺序\n同步\r同步是指任务的执行是按顺序进行的，一个任务完成后，另一个任务才能开始执行。\n例子：多个进程依次在 CPU 上执行，前一个任务完成后，后一个任务才能开始。 异步\r异步是指任务的执行不必按顺序进行，多个任务可以并行执行，任务之间的执行顺序不受限制。每个任务执行时不会阻塞其他任务的执行。\n例子：在事件驱动的程序中，任务的执行顺序可能不固定，可以由事件触发机制来决定。 ","categories":"通用能力","description":"操作系统有四大基本特性","excerpt":"操作系统有四大基本特性","ref":"/docs/general/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/","tags":["操作系统"],"title":"操作系统基本特性"},{"body":"数据库的三大范式，它是数据库设计中最基本的三个规范，那么，三大范式是什么？在实际开发中，我们一定要严格遵守三大范式吗？\n第一范式\r确保每列原子性 也就是字段的值是原子的, 不可再分割\n第二范式\r确保表中的每列和主键相关\n第二范式在第一范式的基础上, 消除表的部分依赖\n即非主键字段必须完全依赖于主键，而不是仅依赖于主键的一部分。\n这里和订单id(主键) 有关的只有数量和商品ID\n拆成两张表\n第三范式\r确保每列都与主键列直接相关, 而不是间接相关\n在第二范式的基础上, 消除表的传递依赖\n所有非主键字段必须直接依赖于主键，而不是通过其他非主键字段间接依赖。\n在这个表中，部门名称依赖于部门ID，而部门ID依赖于主键员工ID，形成了传递依赖，违反了3NF。\n","categories":"Java基础能力","description":"数据库的三大范式，它是数据库设计中最基本的三个规范","excerpt":"数据库的三大范式，它是数据库设计中最基本的三个规范","ref":"/docs/basic/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/","tags":["MySQL"],"title":"数据库设计规范"},{"body":"","categories":"日志","description":"海阔知识库, 心怀希望. 人在迷途","excerpt":"海阔知识库, 心怀希望. 人在迷途","ref":"/dairy/","tags":["日志"],"title":"日志"},{"body":"","categories":"算法","description":"","excerpt":"","ref":"/leetcode/tree/","tags":"","title":"树"},{"body":" 模板方法的核心在于定义一个“骨架”。\npublic abstract class Worker { protected String name; public Worker(String name) { this.name = name; } /** * 记录一天的工作 */ public final void workOneDay() { System.out.println(\"-----------------work start ---------------\"); enterCompany(); computerOn(); work(); computerOff(); exitCompany(); System.out.println(\"-----------------work end ---------------\"); } /** * 打代码 */ public abstract void work(); /** * 关闭电脑 */ private void computerOff() { System.out.println(name + \"关闭电脑\"); } /** * 打开电脑 */ private void computerOn() { System.out.println(name + \"打开电脑\"); } /** * 进入公司 */ public void enterCompany() { System.out.println(name + \"进入公司\"); } /** * 离开公司 */ public void exitCompany() { System.out.println(name + \"离开公司\"); } } 其中大部分方法都实现了(演示方便, 有返回值就行) 唯独打代码没实现, 那么这个方法延迟到子类实现, 我们看下孩子们是如何实现的 劳大:\npublic class ITWorker extends Worker { public ITWorker(String name) { super(name); } @Override public void work() { System.out.println(name + \"孩子们快跑, 我在finally返回了\"); } } 皮衣黄\npublic class HRWorker extends Worker { public HRWorker(String name) { super(name); } @Override public void work() { System.out.println(name + \"孩子们快跑, deepseek跳过了CUDA\"); } } 马圣\npublic class QAWorker extends Worker { public QAWorker(String name) { super(name); } @Override public void work() { System.out.println(name + \"孩子们快跑, DOGE要开人啦\"); } } 这样所有子类只需完成小部分逻辑即可实现功能\n![[content/en/docs/Basic/Concurrent/Pasted image 20250203230102.png]]\n钩子\r[!NOTE] 钩子的由来：\n“钩子” 这个名字形象地表达了方法在模板方法模式中的角色：它就像一个钩子，可以被子类“挂”上去（重写），也可以“留空”。 子类重写钩子方法，就相当于“挂”上去了，它能改变或增加一些行为；如果不重写钩子方法，就相当于“没挂”——这时模板方法会使用父类提供的默认实现。 可以当成开关理解 父类可以留几个钩子 比如是否打印时间\npublic boolean isNeedPrintDate() { return false; } /** * 离开公司 */ public void exitCompany() { if (isNeedPrintDate()) { System.out.print(new Date().toLocaleString()+\"--\u003e\"); } System.out.println(name + \"离开公司\"); } 子类重写钩子, 就可以选择算法分支了, 也就是是否打印时间\n@Override public boolean isNeedPrintDate() { return true; } 总结: 其实模板方法就是把一类操作提取出统一的逻辑 将不同的参数, 细节等延迟到子类实现\n[!引用] https://blog.csdn.net/lmj623565791/article/details/26276093\n","categories":"Java基础能力","description":"模板类定义了实现功能的步骤, 但是具体实现需要子类提供. 这使得一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。","excerpt":"模板类定义了实现功能的步骤, 但是具体实现需要子类提供. 这使得一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些 …","ref":"/docs/basic/designpatterns/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/","tags":["设计模式"],"title":"模板方法"},{"body":"题意:\r难度:\r示例:\r解析:\r","categories":"算法","description":"","excerpt":"题意:\r难度:\r示例:\r解析:\r","ref":"/leetcode/matrix/","tags":"","title":"矩阵"},{"body":"进程 说简单点就是我们在电脑上启动的一个个应用。它是操作系统分配资源的最小单位。\n线程 是进程的子任务，是 CPU 调度和分派的基本单位，实现了进程内部的并发。\n线程与进程\r线程，是进程的子任务，是进程中的独立执行单元。多个线程可以共享同一个进程的资源，如内存；每个线程都有自己独立的栈和寄存器。\n并发环境下, 多线程存在下述问题\n线程之间如何确保执行顺序,实现线程之间的协调与合作? 线程通信 线程之间如何确保对临界资源修改不会冲突? 线程同步? 线程通信\rInter-thread communication in Java is a mechanism in which a thread is paused running in its critical section and another thread is allowed to enter (or lock) in the same critical section to be executed.\n线程间通信 是一种机制，使得线程能够在执行时进行协作，通常用于解决某些线程需要等待其他线程完成任务的情况。它主要涉及线程之间的等待和通知机制，而不是同一临界区内的互斥访问。\n线程同步\rSynchronization is crucial for ensuring that multiple threads operate safely on shared resources. Without *Synchronization, data inconsistency or corruption can occur when multiple threads try to access and modify shared variables simultaneously. In Java, it is a mechanism that ensures that only one thread can access a resource at any given time\n线程同步的重点是 保证线程安全，特别是在多个线程访问共享资源时。同步机制通过确保某个共享资源在同一时刻只能被一个线程访问来防止数据不一致或冲突。Java 中的 synchronized 关键字和 ReentrantLock 都是同步机制的实现，确保线程在访问共享资源时不会发生并发冲突。\n解决上述问题的方式有两种\n共享内存 消息传递 Java 使用共享内存的并发模型实现线程同步与通信, 这个模型称之为 JMM JMM 决定了一个线程对共享变量的写入何时对另外一个线程可见。\n引用: Geekfork\n","categories":"Java基础能力","description":"线程，是进程的子任务，是 CPU 调度和分派的基本单位，实现了进程内部的并发。","excerpt":"线程，是进程的子任务，是 CPU 调度和分派的基本单位，实现了进程内部的并发。","ref":"/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/","tags":["并发编程","操作系统"],"title":"线程"},{"body":" 前置 线程与进程\n线程安全是指, 在多线程环境下, 多个线程对共享资源进行并发访问和操作时可能出现的问题\n常见的线程安全问题\r可见性问题\r确保一个线程对共享变量的修改可以立即被其他线程看到。 数据竞争 当多个线程同时访问和修改共享变量时, 没有适当的同步机制来保护数据一致性, 会导致不可预测的结果\nvolatile 关键字可以保证了变量的修改对所有线程立即可见，并防止编译器优化导致的可见性问题。\n原子性问题\r确保当某个线程修改共享变量时，没有其他线程可以同时修改这个变量，即这个操作是不可分割的。 如果操作的原子性被破坏, 就会导致只有部分操作成功使得结果无法预测\n原子性可以通过互斥锁（如 synchronized）或原子操作（如 AtomicInteger 类中的方法）来保证。\n活跃性问题\r资源竞争 多个线程争夺有限的资源, 没有适当的同步机制会导致资源分配问题\n死锁 两个或多个线程同时占用对方的资源且不释放, 这种情况下，线程将永久阻塞，导致程序无法继续执行 饥饿 当某个线程长时间无法得到资源导致该进程无法继续执行, 会发生饥饿现象 引用: https://blog.csdn.net/a772304419/article/details/130979664 https://blog.csdn.net/qq_49217297/article/details/124546726\n","categories":"Java基础能力","description":"线程安全问题涉及数据竞争、资源竞争、竞态条件、死锁和饥饿等，常见于多线程并发访问共享资源时。","excerpt":"线程安全问题涉及数据竞争、资源竞争、竞态条件、死锁和饥饿等，常见于多线程并发访问共享资源时。","ref":"/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/","tags":["并发编程"],"title":"线程安全问题"},{"body":"什么是线程池\r线程池(ThreadPool) 是一种基于池化思想管理线程的工具\n线程池解决的问题是, 在任意时刻下, 确定系统应该投入多少资源, 解决多少任务\n不将线程统一管理可能会出现以下问题\n频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。 系统无法合理管理内部的资源分布，会降低系统的稳定性。 为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。\n线程池内部维护了许多线程, 当有新任务时就会分配一个空闲线程执行 当所有线程都有任务时, 新的任务要么放到阻塞队列里面要么增加线程\n使用线程池\r用法:\n// 创建固定大小的线程池: ExecutorService executor = Executors.newFixedThreadPool(3); // 提交任务: executor.submit(task1); executor.submit(task2); executor.submit(task3); executor.submit(task4); executor.submit(task5); 上述代码创建了大小为3的线程池, 并提交了5个任务\nExecutorService该接口要求实现工厂方法, 返回如下类型的线程池\nFixedThreadPool：线程数固定的线程池； CachedThreadPool：线程数根据任务动态调整的线程池； ScheduledThreadPool: 定时执行线程池 SingleThreadExecutor：仅单线程执行的线程池。 线程池原理解析\rJava的线程池核心实现为 ThreadPoolExecutor\n顶级接口 Excutor 提供了一种思想, 将任务提交与任务执行解耦 用户只需提供 Runnable 对像, 将任务提交到执行器中, 剩余的线程调配和任务执行由执行器完成\nExecutorService接口增加了一些能力： （1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。\n线程池构造类 ThreadPoolExecutor 通过传入参数实现线程池的构造 如下是成员变量, ![[content/en/docs/Basic/Concurrent/Pasted image 20250203123133.png]] 参数解释\ncorePoolSize：线程池中用来工作的核心线程数量。 maximumPoolSize：最大线程数，线程池允许创建的最大线程数, 可以理解为非核心线程 + 核心线程数 workQueue：任务队列，是一个阻塞队列，当线程数达到核心线程数后，会将任务存储在阻塞队列中。 threadFactory ：线程池内部创建线程所用的工厂。 handler：拒绝策略；当队列已满并且线程数量达到最大线程数量时，会调用该方法处理任务 线程池使用前记得初始化\n线程池的默认策略是构造完成后不创建线程, 也就是说刚创建好的线程池是没有线程的, 只有传入的 BlockingQueue 也就是[[阻塞队列]] 和其他参数 ![[content/en/docs/Basic/Concurrent/Pasted image 20250203123400.png]] 使用线程池之后 当调用任务执行方法 execute() 时启动执行流程 线程执行任务流程如下\n核心线程数未满：直接创建新线程执行任务（不会进队列）。 核心线程数已满，队列未满：任务进入阻塞队列等待空闲线程执行。 核心线程数已满，队列已满： 如果当前线程池线程数未达到最大线程数，创建非核心线程执行任务。 否则，执行拒绝策略。 队列未满, 创建核心线程\n![[content/en/docs/Basic/Concurrent/Pasted image 20250203123742.png]] 队列已满, 创建非核心线程![[content/en/docs/Basic/Concurrent/Pasted image 20250203124516.png]]\n所以，就算队列中已经塞满了任务，新创建的线程还是会优先处理提交的任务，而不是从队列中获取已有的任务执行，从这可以看出，先提交的任务不一定先执行。\n当上述流程无法完成时, 会使用拒绝策略抛出异常 JDK 自带的 RejectedExecutionHandler 实现有 4 种\nAbortPolicy：丢弃任务，抛出运行时异常 CallerRunsPolicy：由提交任务的线程来执行任务 DiscardPolicy：丢弃这个任务，但是不抛异常 DiscardOldestPolicy：从队列中剔除最先进入队列的任务，然后再次提交任务 任务执行方法 excute() 源码如下\npublic void execute(Runnable command) { // 首先检查提交的任务是否为null，是的话则抛出NullPointerException。 if (command == null) throw new NullPointerException(); // 获取线程池的当前状态（ctl是一个AtomicInteger，其中包含了线程池状态和工作线程数） int c = ctl.get(); // 1. 检查当前运行的工作线程数是否少于核心线程数（corePoolSize） if (workerCountOf(c) \u003c corePoolSize) { // 如果少于核心线程数，尝试添加一个新的工作线程来执行提交的任务 // addWorker方法会检查线程池状态和工作线程数，并决定是否真的添加新线程 if (addWorker(command, true)) return; // 重新获取线程池的状态，因为在尝试添加线程的过程中线程池的状态可能已经发生变化 c = ctl.get(); } // 2. 尝试将任务添加到任务队列中 if (isRunning(c) \u0026\u0026 workQueue.offer(command)) { int recheck = ctl.get(); // 双重检查线程池的状态 if (! isRunning(recheck) \u0026\u0026 remove(command)) // 如果线程池已经停止，从队列中移除任务 reject(command); // 如果线程池正在运行，但是工作线程数为0，尝试添加一个新的工作线程 else if (workerCountOf(recheck) == 0) addWorker(null, false); } // 3. 如果任务队列满了，尝试添加一个新的非核心工作线程来执行任务 else if (!addWorker(command, false)) // 如果无法添加新的工作线程（可能因为线程池已经停止或者达到最大线程数限制），则拒绝任务 reject(command); } ","categories":"Java基础能力","description":"池化技术的核心思想就是实现资源的复用，避免资源的重复创建和销毁带来的性能开销。","excerpt":"池化技术的核心思想就是实现资源的复用，避免资源的重复创建和销毁带来的性能开销。","ref":"/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0/","tags":["并发编程"],"title":"线程池"},{"body":"Java的线程分为两类, 用户线程和守护线程\n线程调度就是线程不同状态间的转换\n在操作系统中，线程被视为轻量级的进程，所以线程状态其实和进程状态是一致的。\nJava线程有如下状态\n// Thread.State 源码 public enum State { NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED; } NEW\r处于 NEW 状态的线程是刚创建 Thread 而尚未启动。这里的尚未启动指的是还没调用 Thread 实例的start()方法。\nprivate void testStateNew() { Thread thread = new Thread(() -\u003e {}); System.out.println(thread.getState()); // 输出 NEW } RUNNABLE\r当前线程正在运行中。处于 RUNNABLE 状态的线程在 Java 虚拟机中运行，也有可能在等待 CPU 分配非IO资源。\nJava 线程的RUNNABLE状态其实包括了操作系统线程的ready和running两个状态。\nBLOCK\r阻塞状态。处于 BLOCKED 状态的线程正等待锁（锁会在后面细讲）的释放以进入同步区。\nWAITING\r等待状态。处于等待状态的线程变成 RUNNABLE 状态需要其他线程唤醒。\nObject.wait()：使当前线程处于等待状态直到另一个线程唤醒它 Thread.join()：等待线程执行完毕，底层调用的是 Object 的 wait 方法,等待期间可以通过Object.notify()/notifyAll()/Locksupport.unpark()唤醒 LockSupport.park()：除非获得调用许可，否则禁用当前线程进行线程调度 TIMED_WAITING\r超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。\n调用如下方法会使线程进入超时等待状态：\nThread.sleep(long millis)：使当前线程睡眠指定时间\nObject.wait(long timeout)：线程休眠指定时间，等待期间可以通过Object.notify()/notifyAll()/Locksupport.unpark()唤醒\nThread.join(long millis)：等待当前线程最多执行 millis 毫秒，如果 millis 为 0，则会一直执行\nLockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间\nLockSupport.parkUntil(long deadline)：同上，也是禁止线程进行调度指定时间；\nTERMINATED\r终止状态\n调度方法\r等待与通知\rObject.wait() 调用wait()方法前线程必须持有对象的锁。 线程调用wait()方法时，会释放当前的锁，直到有其他线程调用notify()/notifyAll()方法唤醒等待锁的线程。\n需要注意的是，其他线程调用notify()方法只会唤醒单个等待锁的线程，如有有多个线程都在等待这个锁的话不一定会唤醒到之前调用wait()方法的线程。\n同样，调用notifyAll()方法唤醒所有等待锁的线程之后，也不一定会马上把时间片分给刚才放弃锁的那个线程，具体要看系统的调度。\nObject.wait(long)/Object.wait(long, int) wait(long)方法使线程进入 TIMED_WAITING 状态。这里的wait(long)方法与无参方法 wait()相同的地方是，都可以通过其他线程调用notify()或notifyAll()方法来唤醒。\n不同的地方是，有参方法wait(long)就算其他线程不来唤醒它，经过指定时间 long 之后它会自动唤醒，拥有去争夺锁的资格。\nThread.join() 调用join()方法，会一直等待这个线程执行完毕（转换为 TERMINATED 状态）。\n休眠\rThread.sleep(long) 使当前线程睡眠指定时间。需要注意这里的“睡眠”只是暂时使线程停止执行，并不会释放锁。时间到后，线程会重新进入 RUNNABLE 状态。\n让出执行权\ryield()：Thread 类中的静态方法，当一个线程调用 yield 方法时，实际是在暗示线程调度器，当前线程请求让出自己的 CPU，但是线程调度器可能会“装看不见”忽略这个暗示。\n中断\r中断（Interrupt）一个线程意味着在该线程完成任务之前停止其正在进行的一切，有效地中止其当前的操作。线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序。\n那么，我们究竟应该如何停止线程呢？\n1、任务中一般都会有循环结构，只要用一个标记控制住循环，就可以结束任务。 2、如果线程处于了冻结状态，无法读取标记，此时可以使用interrupt()方法将线程从冻结状态强制恢复到运行状态中来，让线程具备CPU的执行资格。 Thread.interrupt(long)\n作用是中断阻塞的线程。将会设置线程中断为true，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。 线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为true）。 该方法只是改变中断状态，不会中断一个正在运行的线程。\n因为该方法并不执行中断, 只是指示线程中断因此用户需要监视线程的执行结果来判断下一步操作 比如抛出interruptedException的方法, 监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常, 从而指示阻塞线程退出阻塞\n引用: 博客园\n","categories":"Java基础能力","description":"操作系统中的线程状态转换","excerpt":"操作系统中的线程状态转换","ref":"/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","tags":["并发编程","操作系统"],"title":"线程生命周期"},{"body":"线程通信\n是一种机制，使得线程能够在执行时进行协作，通常用于解决某些线程需要等待其他线程完成任务的情况。它主要涉及线程之间的等待和通知机制，而不是同一临界区内的互斥访问。\n线程之间传递信息有多种方式， 比如说使用共享对象、wait() 和 notify() 方法、Exchanger 和 CompletableFuture\n使用共享对象\r多个线程同时访问和修改同一个对象, 从而实现信息传递\n比如 volatile synchronized\n","categories":"Java基础能力","description":"线程之间传递信息有多种方式，比如说使用共享对象、wait() 和 notify() 方法、Exchanger 和 CompletableFuture。","excerpt":"线程之间传递信息有多种方式，比如说使用共享对象、wait() 和 notify() 方法、Exchanger …","ref":"/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/","tags":["并发编程"],"title":"线程通信"},{"body":"在并发编程中，锁是一种常用的保证线程安全的方法。\nJava 中常用的锁主要有两类，一种是关键字 synchronized ，被称为 Java 内置锁或监视器锁。\n另一种就是在 J2SE 1.5版本之后的 java.util.concurrent包（下称j.u.c包）中的各类同步器\n包括 ReentrantLock（可重入锁），ReentrantReadWriteLock（可重入读写锁），Semaphore（信号量），CountDownLatch 等\n这些同步器都是基于 AbstractQueuedSynchronizer（下称 AQS）这个简单的框架来构建的\nAQS 类的核心数据结构是一种名为 Craig, Landin, and Hagersten locks（下称 CLH 锁）的变体。\nCLH锁是自旋锁的一种改良\n自旋锁\r自旋锁是互斥锁的一种实现, 用于保证线程间正确互斥\n获取锁时，线程会对一个原子变量循环执行 compareAndSet 方法，直到该方法返回成功时即为成功获取锁\ncompareAndSet 方法底层由[[CAS(compare-and-swap)]]实现\n![[content/en/docs/Basic/Concurrent/Pasted image 20250203201648.png]]\n自旋锁减少了线程上下文开销, 减缓了频繁的线程挂起操作\n但是该锁有很严重的缺点\n饥饿问题, 竞争激烈下, 可能有线程一直得不到锁 性能问题, 长时间自旋并且由于锁状态变更需要修改状态变量, 导致CPU的高速缓存在线程间频繁同步, 很消耗CPU ![[content/en/docs/Basic/Concurrent/Pasted image 20250203202833.png]] CLH锁\rvolatile关键字\n这是对自旋锁的改进版本 主要针对上述两个缺点做了改进\n饥饿问题, 将线程组织为队列, 先来先服务, 防止饥饿问题 去中心化, 不在使用单独的锁状态变量, 而是在每个线程内维护一个状态变量, 后继线程监视前继线程的状态即可 CLH 锁数据结构很简单，类似一个链表队列，所有请求获取锁的线程会排列在链表队列中，自旋访问队列中前一个节点的状态。 ![[content/en/docs/Basic/Concurrent/Pasted image 20250203203420.png]]\nCLH 锁初始化时会 Tail 会指向一个状态为 false 的空节点，如图1所示。\n当 Thread 1（下称 T1）请求获取锁时，Tail 节点指向 T1 对应的节点，同时返回空节点。T1 检查到上一个节点状态为 false，就成功获取到锁，可以执行相应的逻辑了，如图2所示。\n当 Thread 2（下称 T2）请求获取锁时，Tail 节点指向 T2 对应的节点，同时返回 T1 对应的节点。T2检查到上一个节点状态为 True，无法获取到锁，于是开始轮询上一个节点的状态，如图3所示。\n当 T1 释放锁时，会将状态变量置为 False，如图4所示。\nT2 轮询到检查到上一个节点状态变为 False，则获取锁成功，如图5所示。\nJava 源码\n![[content/en/docs/Basic/Concurrent/Pasted image 20250203203732.png]]\n了解 ThreadLocal\n利用 ThreadLocal 在独立线程内存维护node, node中只存储了该线程锁状态\n为什么锁要加 volatile 注意, 虽然锁状态只由宿主线程读取写入, 是单线程操作没必要保证可见性, 但是作为互斥锁需要保证 happen-before 规则成立, 这就意味着一个监视器锁的解锁发生在该监视器锁的后续锁定之前, 因此为了防止无法预测的重排序导致锁的状态在读取完成前被修改, 使用[[volatile关键字]]禁止重排序\n为什么作为链表, node中不存储后继指针 很简单, 因为不需要, 作为先来先服务的队列, 没必要在乎后续节点的状态 只要前一个节点释放锁, 就立刻获取即可\nCLH 锁作为自旋锁的改进，有以下几个优点：\n性能优异，获取和释放锁开销小。释放锁的开销因为不需要使用 CAS 指令而降低了。\n公平锁。先入队的线程会先得到锁。\n实现简单，易于理解。\n当然，它也有两个缺点：第一是因为有自旋操作，当锁持有时间长时会带来较大的 CPU 开销。第二是基本的 CLH 锁功能单一，不改造不能支持复杂的功能。\n[!引用] Quner技术沙龙 https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg\n","categories":"Java基础能力","description":"AQS 类的核心数据结构是一种名为 `Craig, Landin, and Hagersten locks`（下称 CLH 锁）的变体。","excerpt":"AQS 类的核心数据结构是一种名为 `Craig, Landin, and Hagersten locks`（下称 CLH 锁）的变体。","ref":"/docs/basic/concurrent/%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8Eclh%E9%94%81/","tags":["并发编程"],"title":"自旋锁与CLH锁"},{"body":" Java 1.5 提供了 Callable、Future、FutureTask，它们可以在任务执行完后得到执行结果, 可以实现业务之间的并发执行与返回\n在[[多线程入门]] 我们讲述了创建线程实现任务并发的 3 种方式， 直接继承 Thread 实现 Runnable 接口 实现 Callable\u003c\u003e 接口\n前 2 种方式都有一个缺陷：在执行完任务之后无法获取执行结果。这对需要前置任务返回值的线程来说很重要\nJava 1.5 提供了 Callable、Future、FutureTask，它们可以在任务执行完后得到执行结果\nCallable\u003c\u003e\rcallable 源码如下\npublic interface Callable\u003cV\u003e { V call() throws Exception; } 可以看到 call() 方法返回值为泛型 V\n而 Callable\u003c\u003e 允许返回值的一个任务\nRunnable 接口代表一个可以由线程执行的任务, 实现 Runnable 而不是 callable 主要是线程池的兼容性考虑\nFuture 异步计算结果接口\rFuture 表示异步计算的结果，提供了用于检查计算是否完成、等待计算完成、以及检索计算结果的方法。\nFuture 接口的设计目标是允许任务在一个线程中执行，并且可以返回执行结果或抛出异常\npublic interface Future\u003cV\u003e { boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; } 取消任务； 判断任务是否被取消; get()：等待任务完成，获取执行结果，如果任务取消会抛出异常 get(long timeout, TimeUnit unit)：指定等待任务完成的时间，等待超时会抛出异常 注意, get() 方法会阻塞主进程, 一直阻塞到定时结束或者线程返回\nFuture 也属于同步器的一种 因为类内部定义了线程的控制方法, 同步线程之间的状态 Future 的同步机制主要体现在它的 get() 方法：\n如果任务已完成，get() 立即返回结果。 如果任务尚未完成，get() 会将调用线程挂起，直到任务完成并且结果可用，才会唤醒线程并返回结果。 isDone()：判断任务是否完成 isCancelled()：判断任务是否被取消 cancel(boolean mayInterruptIfRunning)：尝试取消此任务的执行，如果任务已经完成、已经取消或由于其他原因无法取消，则此尝试将失败 参数 mayInterruptIfRunning 表示是否允许取消正在执行却没有执行完毕的任务\nFutureTask 异步计算接口实现类\rFutureTask\u003cT\u003e 是 Future 的一个实现类，同时也是 Runnable，可以直接用线程启动。\npublic class FutureTask\u003cV\u003e implements RunnableFuture\u003cV\u003e public interface RunnableFuture\u003cV\u003e extends Runnable, Future\u003cV\u003e { void run(); } FutureTask 本身是对异步任务的封装，是 Future 的实现类, 实际的线程控制和结果计算是由其完成的\nFutureTask 通过 run() 方法实现了 Callable 的任务执行逻辑，因此兼容了 Callable 的行为, 但其本身是 Runnable 的任务\n使用例子\nimport java.util.concurrent.*; public class FutureExample { public static void main(String[] args) throws Exception { // 创建一个固定大小为3的线程池 ExecutorService executorService = Executors.newFixedThreadPool(3); // 创建一个 Callable 数组，用于存储 5 个任务 Callable\u003cInteger\u003e[] tasks = new Callable[5]; for (int i = 0; i \u003c tasks.length; i++) { final int index = i; tasks[i] = () -\u003e { // 模拟任务执行时间，每个任务休眠 index+1 秒 TimeUnit.SECONDS.sleep(index + 1); // 任务返回 (index + 1) * 100 return (index + 1) * 100; }; } // 使用 Future 数组存储任务的执行结果 Future\u003cInteger\u003e[] futures = new Future[tasks.length]; for (int i = 0; i \u003c tasks.length; i++) { // 提交 Callable 任务到线程池，并返回 Future 对象 futures[i] = executorService.submit(tasks[i]); } // 获取任务的执行结果 for (int i = 0; i \u003c futures.length; i++) { // 调用 get() 方法，会阻塞直到任务完成 System.out.println(\"Result of task \" + (i + 1) + \": \" + futures[i].get()); } // 关闭线程池，释放资源 executorService.shutdown(); } } 了解 executorService.submit()\n上述代码定义了一系列 callable 任务, 包装为FutureTask便于线程池使用, 调用 执行器 创建了线程池服务并要求线程池服务执行提交的 FutureTask\nFuture\u003cInteger\u003e[] futures = new Future[tasks.length] 这里是泛型 实际绑定的是 FutureTask\nCompleteableFuture 任务编排实现类\rA Future that may be explicitly completed (setting its value and status), and may be used as a CompletionStage, supporting dependent functions and actions that trigger upon its completion.\nFuture 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合以及 使用Future获得异步执行结果时，要么调用阻塞方法get()，要么轮询看isDone()是否为true，这两种方法都不是很好，因为主线程也会被迫等待。\n从Java 8开始引入了CompletableFuture，它针对Future做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。\n如何使用\r创建一个CompletableFuture是通过CompletableFuture.supplyAsync()实现的，它需要一个实现了Supplier接口的对象：\npublic interface Supplier\u003cT\u003e { T get(); } 紧接着，CompletableFuture已经被提交给默认的线程池执行了，我们需要定义的是CompletableFuture完成时和异常时需要回调的实例。完成时，CompletableFuture会调用Consumer对象：\npublic interface Consumer\u003cT\u003e { void accept(T t); } 异常时，CompletableFuture会调用Function对象：\npublic interface Function\u003cT, R\u003e { R apply(T t); } 示例:\n/** * @program: alog * @description: 实现类 * @author: hamhuo **/public class Future { public static void main(String[] args) throws InterruptedException { //创建异步执行的耗时任务, 获取一段文字 CompletableFuture\u003cString\u003e task = CompletableFuture.supplyAsync(new fetchString()); //这时已经开始执行了 //如果执行成功执行回调 task.thenAccept((response) -\u003e { System.out.println(response + \" human\"); }); //如果失败执行回调 task.exceptionally((e) -\u003e { e.printStackTrace(); return null; }); //保证线程池正确关闭, 让主线程在任务完成后等一会 task.join(); } static class fetchString implements Supplier\u003cString\u003e { @Override public String get() { String message = \"hello from star\"; try{ Thread.sleep(2000); message = \"re:: correct\"; } catch (InterruptedException e) { Thread.currentThread().interrupt(); } if (message.equals(\"hello from star\")) { throw new RuntimeException(\"Earth\"); } return message; } } } thenAcccept() 不会阻塞线程, 是非阻塞的回调方法, 需要主线程手动等待完成\n引用: https://liaoxuefeng.com/books/java/threading/completable-future/index.html https://javaguide.cn/java/concurrent/completablefuture-intro.html#future-%E4%BB%8B%E7%BB%8D\n","categories":"Java基础能力","description":"实际项目中，一个接口可能需要同时获取多种不同的数据，然后再汇总返回，如果是串行（按顺序依次执行每个任务）执行的话，接口的响应速度会非常慢。考虑到这些任务之间有大部分都是 无前后顺序关联 的，可以 并行执行 ，就比如说调用获取商品详情的时候，可以同时调用获取物流信息。通过并行执行多个任务的方式，接口的响应速度会得到大幅优化。","excerpt":"实际项目中，一个接口可能需要同时获取多种不同的数据，然后再汇总返回，如果是串行（按顺序依次执行每个任务）执行的话，接口的响应速度会非常慢。考 …","ref":"/docs/basic/concurrent/%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C/","tags":["并发编程"],"title":"获取线程执行结果"},{"body":" 临界资源\n一次只允许一个进程使用，多个进程同时使用就会造成系统混乱的资源\n诸进程间应采取互斥方式，实现对这种资源的共享。\n源如打印机、 磁带机、共享变量等\n临界区\n无论是硬件临界资源\n还是软件临界资源\n多个进程必须互斥的对它进行访问\n在每个进程中访问临界资源的这段代码称之为临界区\n临界区的作用\r保护共享资源 通过互斥访问机制，任意时刻只有一个线程修改和访问共享数据\n从而保护资源一致性，完整性\n防止竞态条件 多个线程同时访问共享资源时\n由于执行顺序的不确定导致结果不可预测\n临界区通过确保同一时间只有一个线程运行，避免竞态发生\n提高程序稳定性 如果不能采取有效的措施，对多个进程的运行进行妥善的管理，\n必然会因为这些进程对系统资源的无序争夺给系统造成混乱。\n致使每次处理的结果存在着不确定性，即显现出其不可再现性。\n有多个进程需要同时修改某一数据，系统必须控制， 一次仅允许一个进程完成读数据，并修改数据两件事以后，才允许别的进程对同一数据的读和修改操作。\n","categories":"通用能力","description":"无论是硬件临界资源还是软件临界资源多个进程必须互斥的对它进行访问在每个进程中访问临界资源的**代码**称之为临界区","excerpt":"无论是硬件临界资源还是软件临界资源多个进程必须互斥的对它进行访问在每个进程中访问临界资源的**代码**称之为临界区","ref":"/docs/general/os/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/","tags":["操作系统"],"title":"进程同步"},{"body":"进程的状态与转换\r多个进程在并发执行时共享系统资源，\n致使它们在 运行过程中呈现间断性的运行规律，\n所以进程在其生命周期内可能具有多种状态。\n基本状态\r就绪(Ready)状态\n执行(Running)状态\n阻塞(Block)状态\n创建与终止状态\r创建状态\n进程正在被创建\n创建工作尚未完成，进程不能被调度运行\n终止状态\n进程从系统消失\n两个步骤：\n首先，是等待操作系统 进行善后处理，\n最后将其PCB清零，并将PCB空间返还系统。\n这里注意。就绪到运行获得处理机前需要获得其他所有资源\nExam.\n进程描述中正确的\nA. 进程获得CPU是通过调度得到的\nB. 进程申请CPU未获满足时，其状态变为阻塞\nB 进程申请CPU未获满足仍为就绪，只有申请IO或资源失败才是阻塞\n","categories":"通用能力","description":" 多个进程在并发执行时共享系统资源，致使它们在 运行过程中呈现间断性的运行规律，所以进程在其生命周期内可能具有多种状态。","excerpt":" 多个进程在并发执行时共享系统资源，致使它们在 运行过程中呈现间断性的运行规律，所以进程在其生命周期内可能具有多种状态。","ref":"/docs/general/os/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2/","tags":["操作系统"],"title":"进程的状态与转换"},{"body":"JDK 中提供了一些并发编程中常用的通信工具类以供我们开发者使用\n类 作用 Semaphore 限制线程的数量 Exchanger 两个线程交换数据 CountDownLatch 线程等待直到计数器减为 0 时开始工作 CyclicBarrier 作用跟 CountDownLatch 类似，但是可以重复使用 Phaser 增强的 CyclicBarrier CountDownLatch\r一个减法计数器, 基于信号量\nclass CountTest{ public static void main(String[] args) throws InterruptedException { //设置一个尺寸为10的信号量 //总数是10，必须要执行任务的时候，再使用 CountDownLatch countDownLatch = new CountDownLatch(10); for(int i=0; i\u003c10; i++) { new Thread(()-\u003e{ System.out.println(Thread.currentThread().getName()+\" Go out\"); countDownLatch.countDown(); //数量减1 },String.valueOf(i)).start(); } countDownLatch.await(); //等待计数器归零，再向下执行 System.out.println(\"Hello world!\"); } } 两个方法\ncountDown() 调用后计数减一 await() 使线程挂起 Exchanger\rA synchronization point at which threads can pair and swap elements within pairs. Each thread presents some object on entry to the exchange method, matches with a partner thread, and receives its partner’s object on return. An Exchanger may be viewed as a bidirectional form of a SynchronousQueue. Exchangers may be useful in applications such as genetic algorithms and pipeline designs.\n此类提供对外的操作是同步的； 用于成对出现的线程之间交换数据； 可以视作双向的同步队列； 可应用于基因算法、流水线设计等场景。 class FillAndEmpty { Exchanger\u003cDataBuffer\u003e exchanger = new Exchanger\u003cDataBuffer\u003e(); DataBuffer initialEmptyBuffer = ... DataBuffer initialFullBuffer = ... class FillingLoop implements Runnable { public void run() { //初始化缓存 DataBuffer currentBuffer = initialEmptyBuffer; try { while (currentBuffer != null) { addToBuffer(currentBuffer); if (currentBuffer.isFull()) //如果缓存满, 需要交换, 在这里等 currentBuffer = exchanger.exchange(currentBuffer); } } catch (InterruptedException ex) { ... handle ... } } } class EmptyingLoop implements Runnable { public void run() { DataBuffer currentBuffer = initialFullBuffer; try { while (currentBuffer != null) { takeFromBuffer(currentBuffer); if (currentBuffer.isEmpty()) //如果缓存空, 需要交换, 在这里等 currentBuffer = exchanger.exchange(currentBuffer); } } catch (InterruptedException ex) { ... handle ...} } } void start() { new Thread(new FillingLoop()).start(); new Thread(new EmptyingLoop()).start(); } } 当一个线程调用 exchange 方法后，会处于阻塞状态，只有当另一个线程也调用了 exchange 方法，它才会继续执行。\n内部使用 CAS 检查, 使用park/unpark 做状态转换\n","categories":"Java基础能力","description":"JDK 中提供了一些并发编程中常用的通信工具类以供我们开发者使用。\r\r它们都在 JUC 包下。先总体概括一下都有哪些工具类，它们有什么作用，然后再分别介绍它们的主要使用方法和原理。","excerpt":"JDK 中提供了一些并发编程中常用的通信工具类以供我们开发者使用。\r\r它们都在 JUC 包下。先总体概括一下都有哪些工具类，它们有什么作用， …","ref":"/docs/basic/concurrent/%E9%80%9A%E4%BF%A1%E5%B7%A5%E5%85%B7%E7%B1%BB/","tags":["并发编程"],"title":"通信工具类"},{"body":" In software, a wildcard character is a kind of placeholder represented by a single character, such as an asterisk (*), which can be interpreted as a number of literal characters or an empty string. It is often used in file searches so the full name need not be typed.\n简单来说, 使用通配符来进行模糊查询\n% 通配符\r% 通配符用于匹配任意长度的字符串，包括零长度，在查询文章标题、用户名等此类字段时，会非常有用。\n* 通配符\r代表匹配所有值\n? 参数占位符\r插值表达式传参使用\n","categories":"Java基础能力","description":"In software, a wildcard character is a kind of placeholder represented by a single character, such as an asterisk (*), which can be interpreted as a number of literal characters or an empty string. It is often used in file searches so the full name need not be typed.","excerpt":"In software, a wildcard character is a kind of placeholder represented …","ref":"/docs/basic/%E9%80%9A%E9%85%8D%E7%AC%A6/","tags":["通配符","字符串"],"title":"通配符"},{"body":"","categories":"算法","description":"","excerpt":"","ref":"/leetcode/linkedlist/","tags":"","title":"链表"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dairy/2%E6%9C%8821%E6%97%A5/","tags":"","title":""},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/basic/concurrent/cascompare-and-swap/","tags":"","title":""},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/basic/concurrent/condition%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9D%A1%E4%BB%B6/","tags":"","title":""},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92/","tags":"","title":""},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/basic/concurrent/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/","tags":"","title":""},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/basic/container/heap/","tags":"","title":""},{"body":" 力扣题目解析 题目涉及到的解法以标签的形式注解\n但请注意, 解法不唯一, 所有解析只提供一种解法, 以期抛转引玉 举一反三, 与君共勉 ","categories":"","description":"","excerpt":" 力扣题目解析 题目涉及到的解法以标签的形式注解\n但请注意, 解法不唯一, 所有解析只提供一种解法, 以期抛转引玉 举一反三, 与君共勉 ","ref":"/leetcode/","tags":"","title":"LeetCode"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":" 力扣题目解析 题目涉及到的解法以标签的形式注解\n但请注意, 解法不唯一, 所有解析只提供一种解法, 以期抛转引玉 举一反三, 与君共勉 ","categories":"","description":"","excerpt":" 力扣题目解析 题目涉及到的解法以标签的形式注解\n但请注意, 解法不唯一, 所有解析只提供一种解法, 以期抛转引玉 举一反三, 与君共勉 ","ref":"/docs/","tags":"","title":"Documents"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/docker/","tags":"","title":"Docker"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/gc/","tags":"","title":"GC"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/internet/","tags":"","title":"Internet"},{"body":"","categories":"","description":"","excerpt":"","ref":"/interview/","tags":"","title":"Interview"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/javaweb/","tags":"","title":"JavaWeb"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/java%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B/","tags":"","title":"Java基础能力"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","tags":"","title":"Java数据类型"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/java%E8%BF%9B%E9%98%B6%E8%83%BD%E5%8A%9B/","tags":"","title":"Java进阶能力"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/jvm/","tags":"","title":"JVM"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/list/","tags":"","title":"List"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/mysql/","tags":"","title":"MySQL"},{"body":"","categories":"","description":"","excerpt":"","ref":"/search/","tags":"","title":"Search Results"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/spring/","tags":"","title":"Spring"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/","tags":"","title":"中间件"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F/","tags":"","title":"分布式"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%88%86%E6%B2%BB/","tags":"","title":"分治"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/","tags":"","title":"双指针"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/","tags":"","title":"字符串"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","tags":"","title":"并发编程"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","tags":"","title":"操作系统"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E6%97%A5%E5%BF%97/","tags":"","title":"日志"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E6%97%A5%E5%BF%97/","tags":"","title":"日志"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E6%A0%91/","tags":"","title":"树"},{"body":"","categories":"","description":"","excerpt":"","ref":"/","tags":"","title":"海阔知识库"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E7%9F%A9%E9%98%B5/","tags":"","title":"矩阵"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E7%AE%97%E6%B3%95/","tags":"","title":"算法"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","tags":"","title":"设计模式"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E9%80%92%E5%BD%92/","tags":"","title":"递归"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E9%80%9A%E7%94%A8%E8%83%BD%E5%8A%9B/","tags":"","title":"通用能力"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E9%80%9A%E9%85%8D%E7%AC%A6/","tags":"","title":"通配符"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E9%93%BE%E8%A1%A8/","tags":"","title":"链表"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E9%9D%A2%E8%AF%95/","tags":"","title":"面试"}]