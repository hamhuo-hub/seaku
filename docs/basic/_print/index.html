<!doctype html>
<html itemscope itemtype="http://schema.org/WebPage" lang="en" class="no-js">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="canonical" type="text/html" href="http://localhost:1313/docs/basic/">
<link rel="alternate" type="application/rss&#43;xml" href="http://localhost:1313/docs/basic/index.xml">
<meta name="robots" content="noindex, nofollow">


<link rel="shortcut icon" href="/favicons/favicon.ico" >
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/favicons/android-36x36.png" sizes="36x36">
<link rel="icon" type="image/png" href="/favicons/android-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="/favicons/android-72x72.png" sizes="72x72">
<link rel="icon" type="image/png" href="/favicons/android-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicons/android-144x144.png" sizes="144x144">
<link rel="icon" type="image/png" href="/favicons/android-192x192.png" sizes="192x192">

<title>Java基础能力 | 海阔集</title>
<meta name="description" content="内容来源:
沉默王二 GitHub 上开源的知识库《Java 进阶之路》 rabbitMQ">
<meta property="og:url" content="http://localhost:1313/docs/basic/">
  <meta property="og:site_name" content="海阔集">
  <meta property="og:title" content="Java基础能力">
  <meta property="og:description" content="内容来源:
沉默王二 GitHub 上开源的知识库《Java 进阶之路》 rabbitMQ">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="website">

  <meta itemprop="name" content="Java基础能力">
  <meta itemprop="description" content="内容来源:
沉默王二 GitHub 上开源的知识库《Java 进阶之路》 rabbitMQ">
  <meta itemprop="dateModified" content="2025-02-11T00:25:32+08:00">
  <meta itemprop="wordCount" content="6">
  <meta itemprop="keywords" content="并发编程,MySQL,Docker">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Java基础能力">
  <meta name="twitter:description" content="内容来源:
沉默王二 GitHub 上开源的知识库《Java 进阶之路》 rabbitMQ">
<link href="/scss/main.css" rel="stylesheet">
<script
  src="https://code.jquery.com/jquery-3.7.1.min.js"
  integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g=="
  crossorigin="anonymous"></script>
<script defer
  src="https://unpkg.com/lunr@2.3.9/lunr.min.js"
  integrity="sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli"
  crossorigin="anonymous"></script>

  </head>
  <body class="td-section">
    <header>
      <nav class="td-navbar js-navbar-scroll" data-bs-theme="dark">
<div class="container-fluid flex-column flex-md-row">
  <a class="navbar-brand" href="/"><span class="navbar-brand__logo navbar-logo"><svg width="800" height="800" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M23.3 8.40007 21.82 6.40008C21.7248 6.27314 21.6008 6.17066 21.4583 6.10111 21.3157 6.03156 21.1586 5.99693 21 6.00008H11.2C11.0555 6.00007 10.9128 6.03135 10.7816 6.09177 10.6504 6.15219 10.5339 6.24031 10.44 6.35007L8.71998 8.35008C8.57227 8.53401 8.49435 8.76424 8.49998 9.00008V16.2901C8.50262 18.0317 9.19567 19.7013 10.4272 20.9328c1.2316 1.2316 2.9011 1.9246 4.6428 1.9273h1.86C18.6716 22.8574 20.3412 22.1644 21.5728 20.9328c1.2315-1.2315 1.9245-2.9011 1.9272-4.6427V9.00008C23.5 8.7837 23.4298 8.57317 23.3 8.40007z" fill="#ffcc80"/><path d="M29.78 28.38l-4-5C25.664 23.2321 25.5086 23.1198 25.3318 23.0562 25.1549 22.9925 24.9637 22.98 24.78 23.02L16 25 7.21999 23C7.03632 22.96 6.84507 22.9725 6.6682 23.0362 6.49133 23.0998 6.33598 23.2121 6.21999 23.36l-4 5C2.10392 28.5064 2.03116 28.6823 2.00995 28.8679 1.98874 29.0534 2.01993 29.2413 2.09999 29.41 2.17815 29.5839 2.3044 29.7319 2.46385 29.8364 2.62331 29.9409 2.80933 29.9977 2.99999 30H29C29.1885 29.9995 29.373 29.9457 29.5322 29.8448 29.6914 29.744 29.8189 29.6002 29.9 29.43 29.98 29.2613 30.0112 29.0734 29.99 28.8879 29.9688 28.7023 29.8961 28.5264 29.78 28.38z" fill="#01579b"/><path d="M29.29 6.00003l-13-4C16.0999 1.95002 15.9001 1.95002 15.71 2.00003l-13 4c-.21258.06419-.39774.19732-.5263.37838C2.05515 6.55947 1.99052 6.77817 2 7.00003 1.9917 7.22447 2.0592 7.44518 2.19163 7.62659c.13242.1814.32207.31295.53837.37344L15.73 11.6C15.906 11.6534 16.094 11.6534 16.27 11.6l13-3.59997C29.4863 7.93954 29.6759 7.80799 29.8084 7.62659 29.9408 7.44518 30.0083 7.22447 30 7.00003 30.0095 6.77817 29.9448 6.55947 29.8163 6.37841 29.6877 6.19735 29.5026 6.06422 29.29 6.00003z" fill="#01579b"/><path d="M11.22 6C11.0756 5.99999 10.9328 6.03127 10.8016 6.09169 10.6704 6.15211 10.5539 6.24023 10.46 6.35l-1.72 2C8.58509 8.53114 8.49998 8.76166 8.5 9v7.29C8.50264 18.0317 9.19569 19.7012 10.4272 20.9328c1.2316 1.2315 2.9011 1.9246 4.6428 1.9272H16V6H11.22z" fill="#ffe0b2"/><path d="M7.21999 23C7.03632 22.96 6.84507 22.9725 6.6682 23.0362 6.49133 23.0998 6.33598 23.2121 6.21999 23.36l-4 5C2.10392 28.5064 2.03116 28.6823 2.00995 28.8679 1.98874 29.0534 2.01993 29.2413 2.09999 29.41 2.17815 29.5839 2.3044 29.7319 2.46385 29.8364 2.62331 29.9409 2.80933 29.9977 2.99999 30H16V25L7.21999 23z" fill="#0277bd"/><path d="M15.71 2.00002l-13 4C2.49742 6.06422 2.31226 6.19734 2.1837 6.3784c-.12855.18107-.19318.39977-.1837.62162C1.9917 7.22447 2.0592 7.44518 2.19163 7.62658 2.32405 7.80799 2.5137 7.93954 2.73 8.00002L15.73 11.6C15.8194 11.6146 15.9106 11.6146 16 11.6V2.00002C15.9039 1.98469 15.8061 1.98469 15.71 2.00002z" fill="#0277bd"/><path d="M2.73 8.00003l5.77 1.56V16.29C8.50264 18.0317 9.19569 19.7013 10.4272 20.9328c1.2316 1.2315 2.9011 1.9246 4.6428 1.9272h1.86C18.6717 22.8574 20.3412 22.1643 21.5728 20.9328c1.2315-1.2315 1.9246-2.9011 1.9272-4.6428V9.56003l5.77-1.56C29.4863 7.93954 29.6759 7.80799 29.8084 7.62659 29.9408 7.44518 30.0083 7.22447 30 7.00003 30.0095 6.77817 29.9448 6.55947 29.8163 6.37841 29.6877 6.19735 29.5026 6.06422 29.29 6.00003l-13-4C16.0999 1.95002 15.9001 1.95002 15.71 2.00003l-13 4c-.21258.06419-.39774.19732-.5263.37838C2.05515 6.55947 1.99052 6.77817 2 7.00003 1.9917 7.22447 2.0592 7.44518 2.19163 7.62659c.13242.1814.32207.31295.53837.37344zM21.5 16.29C21.4974 17.5013 21.015 18.6621 20.1586 19.5186 19.3021 20.3751 18.1412 20.8574 16.93 20.86H15.07C13.8588 20.8574 12.6979 20.3751 11.8414 19.5186 10.985 18.6621 10.5026 17.5013 10.5 16.29V10.11l5.23 1.45C15.906 11.6134 16.094 11.6134 16.27 11.56l5.23-1.45v6.18zM16 4.05003l9.44 2.95-9.44 2.56-9.44-2.56 9.44-2.95z" fill="#263238"/><path d="M25.78 23.38C25.664 23.2321 25.5086 23.1198 25.3318 23.0562 25.1549 22.9925 24.9637 22.98 24.78 23.02L16 25 7.21999 23C7.03632 22.96 6.84507 22.9725 6.6682 23.0362 6.49133 23.0998 6.33598 23.2121 6.21999 23.36l-4 5C2.10392 28.5064 2.03116 28.6823 2.00995 28.8679 1.98874 29.0534 2.01993 29.2413 2.09999 29.41 2.17815 29.5839 2.3044 29.7319 2.46385 29.8364 2.62331 29.9409 2.80933 29.9977 2.99999 30H29C29.1885 29.9995 29.373 29.9457 29.5322 29.8448 29.6914 29.744 29.8189 29.6002 29.9 29.43 29.98 29.2613 30.0112 29.0734 29.99 28.8879 29.9688 28.7023 29.8961 28.5264 29.78 28.38l-4-5zM5.07999 28l2.31-2.89L15.78 27C15.9251 27.0299 16.0748 27.0299 16.22 27l8.39-1.87L26.92 28H5.07999z" fill="#263238"/></svg></span><span class="navbar-brand__name">海阔集</span></a>
  <div class="td-navbar-nav-scroll ms-md-auto" id="main_navbar">
    <ul class="navbar-nav">
      <li class="nav-item">
        <a class="nav-link" href="/leetcode/"><span>Alog</span></a>
      </li>
      <li class="nav-item">
        <a class="nav-link active" href="/docs/"><span>Doc</span></a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="/interview/"><span>Interview</span></a>
      </li>
      <li class="td-light-dark-menu nav-item dropdown">
        <svg xmlns="http://www.w3.org/2000/svg" class="d-none">
  <symbol id="check2" viewBox="0 0 16 16">
    <path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"/>
  </symbol>
  <symbol id="circle-half" viewBox="0 0 16 16">
    <path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"/>
  </symbol>
  <symbol id="moon-stars-fill" viewBox="0 0 16 16">
    <path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/>
    <path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"/>
  </symbol>
  <symbol id="sun-fill" viewBox="0 0 16 16">
    <path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>
  </symbol>
</svg>

<button class="btn btn-link nav-link dropdown-toggle d-flex align-items-center"
        id="bd-theme"
        type="button"
        aria-expanded="false"
        data-bs-toggle="dropdown"
        data-bs-display="static"
        aria-label="Toggle theme (auto)">
  <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg>
</button>
<ul class="dropdown-menu dropdown-menu-end" aria-labelledby="bd-theme-text">
  <li>
    <button type="button" class="dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
      <svg class="bi me-2 opacity-50"><use href="#sun-fill"></use></svg>
      Light
      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg>
    </button>
  </li>
  <li>
    <button type="button" class="dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
      <svg class="bi me-2 opacity-50"><use href="#moon-stars-fill"></use></svg>
      Dark
      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg>
    </button>
  </li>
  <li>
    <button type="button" class="dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
      <svg class="bi me-2 opacity-50"><use href="#circle-half"></use></svg>
      Auto
      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg>
    </button>
  </li>
</ul>

      </li>
      </ul>
  </div>
  <div class="d-none d-lg-block">
    <div class="td-search td-search--offline">
  <div class="td-search__icon"></div>
  <input
    type="search"
    class="td-search__input form-control"
    placeholder="Search this site…"
    aria-label="Search this site…"
    autocomplete="off"
    
    data-offline-search-index-json-src="/offline-search-index.json"
    data-offline-search-base-href="/"
    data-offline-search-max-results="10"
  >
</div>
  </div>
</div>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <main class="col-12 col-md-9 col-xl-8 ps-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
This is the multi-page printable view of this section.
<a href="#" onclick="print();return false;">Click here to print</a>.
</p><p>
<a href="/docs/basic/">Return to the regular view of this page</a>.
</p>
</div>



<h1 class="title">Java基础能力</h1>





    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-8a5e3c37ac5f53190e7e35bc3c848b2e">Docker</a></li>


    
    <ul>
        
  
  
  
  

  

    </ul>
    
  
    
    
	
<li>2: <a href="#pg-dea2a95dcba0dd36aacc2278dd11980c">Java并发编程</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>2.1: <a href="#pg-fe114ad990b2a300ad2a6dafcb10682a">AQS</a></li>


    
  
    
    
	
<li>2.2: <a href="#pg-9c0e1807d41464a916022b9559a1749d">JMM内存模型</a></li>


    
  
    
    
	
<li>2.3: <a href="#pg-1f9fd30b05b061ba7093b80b98078894">ReentrantLock重入锁</a></li>


    
  
    
    
	
<li>2.4: <a href="#pg-1e490e506623fa0b06824a180f822aad">synchronized关键字</a></li>


    
  
    
    
	
<li>2.5: <a href="#pg-81976703554d30e4d0a1ddbd1d6055b1">ThreadLocal</a></li>


    
  
    
    
	
<li>2.6: <a href="#pg-8c7a9a4b1c4339f056825f6e89e26d39">volatile关键字</a></li>


    
  
    
    
	
<li>2.7: <a href="#pg-1e3be358e2f744df6d4d87e2255be4ac">多线程入门</a></li>


    
  
    
    
	
<li>2.8: <a href="#pg-39ecca64f8ebd31d21ffdc061978beef">线程</a></li>


    
  
    
    
	
<li>2.9: <a href="#pg-102bfdf29b786bceaca7b6b0ae2231f3">线程安全问题</a></li>


    
  
    
    
	
<li>2.10: <a href="#pg-351a895f640e6e5b71c131358ebdad6d">线程池</a></li>


    
  
    
    
	
<li>2.11: <a href="#pg-ea7b52e09c3e940dc03d793d2fc4b6a1">线程生命周期</a></li>


    
  
    
    
	
<li>2.12: <a href="#pg-49dc4004f4087cdd8b87e117f3bd63ce">线程通信</a></li>


    
  
    
    
	
<li>2.13: <a href="#pg-8d4d929881d72feb82a7b32632a1f7ab">自旋锁与CLH锁</a></li>


    
  
    
    
	
<li>2.14: <a href="#pg-b1e03d0071485913d948160ef5df36b9">获取线程执行结果</a></li>


    
  
    
    
	
<li>2.15: <a href="#pg-1c1b1847caa2841a66eb981677a626fd">通信工具类</a></li>


    
  
    
    
	
<li>2.16: <a href="#pg-796c9ebe903c9d7316b36e64bf412389"></a></li>


    
  
    
    
	
<li>2.17: <a href="#pg-6fcba84597d7e94e37305c484c79e11a"></a></li>


    
  
    
    
	
<li>2.18: <a href="#pg-b75dc17122f7fa6015c2c9c6f785bfb9"></a></li>


    
  
    
    
	
<li>2.19: <a href="#pg-3289dc0cf77ebdd3067bf799eab51ff2"></a></li>


    
  
    
    
	
<li>2.20: <a href="#pg-0d0829b705f81a8c8a6adb4575b07ebf"></a></li>


    
  

    </ul>
    
  
    
    
	
<li>3: <a href="#pg-0faba675a466ec9ffd5f0701d9db5314">Java集合框架</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>3.1: <a href="#pg-c01a54606858a092e8d1f35c7e73f3ce">LinkedList</a></li>


    
  
    
    
	
<li>3.2: <a href="#pg-826ec4829c43a4d0a4b133ee3b1e9fde"></a></li>


    
  

    </ul>
    
  
    
    
	
<li>4: <a href="#pg-015ab6060789604cfb2a274bcd5125f6">JVM</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>4.1: <a href="#pg-fd676f9ad424bbf69b4af55a1c55d98b">Java的四种引用</a></li>


    
  

    </ul>
    
  
    
    
	
<li>5: <a href="#pg-06ecac212db9f5d9be3e85ff8516e084">MySQL</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>5.1: <a href="#pg-e03b3b407ae2c157a75929111db4a065">MySQL字符集和比较规则</a></li>


    
  
    
    
	
<li>5.2: <a href="#pg-fadb4161cda4eb7aee82d35d77a64105">MySQL数据库操作</a></li>


    
  
    
    
	
<li>5.3: <a href="#pg-ba3f3c8094c6e9acf93aa7c53ef12f2f">MySQL数据库查询</a></li>


    
  
    
    
	
<li>5.4: <a href="#pg-5c7eb05872462e8972765a1ac361bc03">MySQL数据类型</a></li>


    
  
    
    
	
<li>5.5: <a href="#pg-d18d448ea26b2380832c20eaee109e3b">MySQL条件查询</a></li>


    
  
    
    
	
<li>5.6: <a href="#pg-48d22b2363579601962c96e1f427026c">MySQL表操作</a></li>


    
  
    
    
	
<li>5.7: <a href="#pg-aec71f889e3edd1c2c139a8adbb7b003">事务</a></li>


    
  

    </ul>
    
  
    
    
	
<li>6: <a href="#pg-00b1f54870739c9642ff5be20f722ae9">通配符</a></li>


    
  

    </ul>


<div class="content">
      <p>内容来源:</p>
<ul>
<li>沉默王二 GitHub 上开源的知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">Java 进阶之路</a>》</li>
<li><a href="https://www.rabbitmq.com/tutorials">rabbitMQ</a></li>
</ul>

</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-8a5e3c37ac5f53190e7e35bc3c848b2e">1 - Docker</h1>
    <div class="lead">应用运行容器, 傻瓜式安装程序环境, 还不怕中病毒</div>
	<p>内容来源:</p>
<ul>
<li>沉默王二 GitHub 上开源的知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">Java 进阶之路</a>》</li>
</ul>

</div>



    
      
  
  
  
  

  
  

  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-dea2a95dcba0dd36aacc2278dd11980c">2 - Java并发编程</h1>
    
	<p>内容来源:</p>
<ul>
<li>沉默王二 GitHub 上开源的知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">Java 进阶之路</a>》</li>
<li><a href="https://javaguide.cn/java/concurrent/">JavaGuide</a></li>
<li><a href="https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg">CLH锁 - Quner技术沙龙</a></li>
<li>操作系统 - 西电出版</li>
</ul>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-fe114ad990b2a300ad2a6dafcb10682a">2.1 - AQS</h1>
    <div class="lead"><strong>AQS</strong>是<code>AbstractQueuedSynchronizer</code>的简称，即<code>抽象的队列同步器</code></div>
	<p><strong>AQS</strong>是<code>AbstractQueuedSynchronizer</code>的简称，即<code>抽象的队列同步器</code></p>
<ul>
<li>抽象：抽象类，只实现一些主要逻辑，有些方法由子类实现；</li>
<li>队列：使用先进先出（FIFO）的队列存储数据；</li>
<li>同步：实现了同步的功能。</li>
</ul>
<h4 id="为什么需要-aqs">为什么需要 <code>AQS</code><a class="td-heading-self-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81-aqs" aria-label="Heading self-link"></a></h4>
<p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的同步器
简单的说,  存储并管理线程同步的模板</p>
<p>具体的同步器（如 <code>ReentrantLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code>, <a href="/docs/basic/concurrent/%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C/">FutureTask</a>等）是通过继承 <code>AQS</code> 并实现一些抽象方法来实现资源的具体获取和释放行为的。</p>
<h4 id="aqs的作用是什么"><code>AQS</code>的作用是什么?<a class="td-heading-self-link" href="#aqs%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88" aria-label="Heading self-link"></a></h4>
<blockquote>
<p>了解
<a href="/docs/basic/concurrent/%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8Eclh%E9%94%81/">自旋锁与CLH锁</a></p></blockquote>
<p><code>AQS</code> 是一个 <strong>抽象类</strong>，它为具体的同步器提供了一个通用的执行框架。
它定义了如何获取和释放共享资源的基本流程，但并没有实现具体的逻辑。</p>
<p><code>AQS</code> 提供了同步器所需要的 <strong>框架和基础设施</strong>，比如：</p>
<ol>
<li>如何在多个线程间协调资源的竞争。</li>
<li>如何管理线程的队列（阻塞队列）以等待资源。</li>
</ol>
<blockquote>
<p>其中AQS 的核心数据结构是基于<a href="/docs/basic/concurrent/%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8Eclh%E9%94%81/">CLH 锁</a>改进的, 详情下述</p></blockquote>
<ol start="3">
<li>线程的挂起与唤醒等机制。</li>
</ol>
<h4 id="aqs的数据结构">AQS的数据结构<a class="td-heading-self-link" href="#aqs%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="Heading self-link"></a></h4>
<p>既然是控制线程, 那么数据结构应对并发相应的优化
AQS的核心数据结构是基于 CLH队列锁改进的
<img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/Pasted%20image%2020250203211340.png" alt="Pasted image 20250203211340.png">
CLH队列锁有如下缺点</p>
<ol>
<li>仍然基于自旋, 长时间自旋下CPU占用高</li>
<li>功能单一, 不能挂起, 不能共享读, 只支持独占等
针对以上缺点, AQS进行改造</li>
<li>AQS 将自旋操作改为阻塞线程操作。</li>
<li>AQS 对 CLH 锁进行改造和扩展, 扩展每个节点的状态、显式的维护前驱节点和后继节点</li>
</ol>
<p>AQS 内部使用了一个<a href="/docs/basic/concurrent/volatile%E5%85%B3%E9%94%AE%E5%AD%97/">volatile关键字</a> 的变量 <code>state</code> 来作为线程的状态标识。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">volatile</span> <span style="color:#e78284">int</span> waitStatus;
</span></span></code></pre></div><p>该变量有如下状态, AQS提供原子读写
![[content/en/docs/Basic/Concurrent/Pasted image 20250203210552.png]]</p>
<ul>
<li>CANCELLED：表示当前节点（对应的线程）已被取消。当等待超时或被中断，会触发进入为此状态，进入该状态后节点状态不再变化；</li>
<li>SIGNAL：后面节点等待当前节点唤醒；</li>
<li>CONDITION：当前线程阻塞在Condition，如果其他线程调用了Condition的signal方法，这个节点将从等待队列转移到同步队列队尾，等待获取同步锁；</li>
</ul>
<blockquote>
<p>了解<a href="/docs/basic/concurrent/condition%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9D%A1%E4%BB%B6/">Condition等待通知条件</a></p></blockquote>
<ul>
<li>PROPAGATE：共享模式，前置节点唤醒后面节点后，唤醒操作无条件传播下去；</li>
<li>0：中间状态，当前节点后面的节点已经唤醒，但是当前节点线程还没有执行完成。
状态多了不少, 但是AQS为了优化, 抛弃了自旋设计,这导致线程被阻塞时没办法获取前驱节点的状态
所以AQS显式维护前后节点, 在锁释放时主动通知后继线程解除阻塞
<img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/Pasted%20image%2020250203211000.png" alt="Pasted image 20250203211000.png"></li>
</ul>
<p><em>(T1 释放锁后主动唤醒 T2，使 T2 检测到锁已释放，获取锁成功。)</em></p>
<blockquote>
<p>在释放锁时，如果当前节点的后驱节点不可用时，将从利用队尾指针 Tail 从尾部遍历到直到找到当前节点正确的后驱节点。
这是因为双端队列的插入没有相应的原子操作, 因此后驱节点的设置并非作为原子性插入操作的一部分，而仅是在节点被插入后简单地赋值</p></blockquote>
<p>AQS还实现了共享读
资源有两种共享模式，或者说两种同步方式：</p>
<ul>
<li>
<p>独占模式（Exclusive）：资源是独占的，一次只能有一个线程获取。如 <a href="/docs/basic/concurrent/reentrantlock%E9%87%8D%E5%85%A5%E9%94%81/">ReentrantLock重入锁</a> <a href="/docs/basic/concurrent/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/">synchronized关键字</a></p>
</li>
<li>
<p>共享模式（Share）：同时可以被多个线程获取，具体的资源个数可以通过参数指定。如 <a href="/docs/basic/concurrent/%E9%80%9A%E4%BF%A1%E5%B7%A5%E5%85%B7%E7%B1%BB/">Semaphore/CountDownLatch</a></p>
</li>
</ul>
<p>这两种模式是在内部类 <code>Node</code> 中实现的</p>
<p>Node源码</p>
<blockquote>
<p>可以看到 node中的状态信息都是常量, 无法修改的</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">static</span> <span style="color:#e78284">final</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">Node</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 标记一个结点（对应的线程）在共享模式下等待</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> Node SHARED <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Node();
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 标记一个结点（对应的线程）在独占模式下等待</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> Node EXCLUSIVE <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ef9f76">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// waitStatus的值，表示该结点（对应的线程）已被取消</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> <span style="color:#e78284">int</span> CANCELLED <span style="color:#99d1db;font-weight:bold">=</span> 1;
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// waitStatus的值，表示后继结点（对应的线程）需要被唤醒</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> <span style="color:#e78284">int</span> SIGNAL <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#99d1db;font-weight:bold">-</span>1;
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// waitStatus的值，表示该结点（对应的线程）在等待某一条件</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> <span style="color:#e78284">int</span> CONDITION <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#99d1db;font-weight:bold">-</span>2;
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">/*waitStatus的值，表示有资源可用，新head结点需要继续唤醒后继结点（共享模式下，多线程并发释放资源，而head唤醒其后继结点后，需要把多出来的资源留给后面的结点；设置新的head结点时，会继续唤醒其后继结点）*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> <span style="color:#e78284">int</span> PROPAGATE <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#99d1db;font-weight:bold">-</span>3;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 等待状态，取值范围，-3，-2，-1，0，1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">volatile</span> <span style="color:#e78284">int</span> waitStatus;
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">volatile</span> Node prev; <span style="color:#737994;font-style:italic">// 前驱结点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">volatile</span> Node next; <span style="color:#737994;font-style:italic">// 后继结点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">volatile</span> Thread thread; <span style="color:#737994;font-style:italic">// 结点对应的线程</span>
</span></span><span style="display:flex;"><span>    Node nextWaiter; <span style="color:#737994;font-style:italic">// 等待队列里下一个等待条件的结点</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 判断共享模式的方法</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">final</span> <span style="color:#e78284">boolean</span> <span style="color:#8caaee">isShared</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> nextWaiter <span style="color:#99d1db;font-weight:bold">==</span> SHARED;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Node(Thread thread, Node mode) {     <span style="color:#737994;font-style:italic">// Used by addWaiter</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">this</span>.<span style="color:#8caaee">nextWaiter</span> <span style="color:#99d1db;font-weight:bold">=</span> mode;
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">this</span>.<span style="color:#8caaee">thread</span> <span style="color:#99d1db;font-weight:bold">=</span> thread;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 其它方法忽略，可以参考具体的源码</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// AQS里面的addWaiter私有方法</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">private</span> Node <span style="color:#8caaee">addWaiter</span>(Node mode) {
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 使用了Node的这个构造函数</span>
</span></span><span style="display:flex;"><span>    Node node <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Node(Thread.<span style="color:#8caaee">currentThread</span>(), mode);
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 其它代码省略</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="aqs源码解析">AQS源码解析<a class="td-heading-self-link" href="#aqs%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90" aria-label="Heading self-link"></a></h4>
<p>AQS 的设计是基于<a href="/docs/basic/concurrent/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">模板方法模式</a>的，它有一些方法必须要子类实现，它们主要有：</p>
<ul>
<li><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到 condition 才需要去实现它。</li>
<li><code>tryAcquire(int)</code>：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</li>
<li><code>tryRelease(int)</code>：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。</li>
<li><code>tryAcquireShared(int)</code>：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回 true，否则返回 false。</li>
</ul>
<blockquote>
<p>比较特殊的是, 这里的抽象方法并没有加 <code>abstract</code> 关键字
这是因为并非AQS的所有抽象方法都需要子类实现, 所以子类只重写需要的方法就行</p></blockquote>
<p>子类不是重点, 我们来看模板类, 也就是AQS的逻辑</p>
<h5 id="获取资源">获取资源<a class="td-heading-self-link" href="#%e8%8e%b7%e5%8f%96%e8%b5%84%e6%ba%90" aria-label="Heading self-link"></a></h5>
<p>获取资源的入口是 <code>acquire(int arg)</code>方法。arg 是要获取的资源个数，在独占模式下始终为 1。我们先来看看这个方法的逻辑：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">final</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">accquire</span>(<span style="color:#e78284">int</span> arg) {
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// tryAcquire 再次尝试获取锁资源，如果尝试成功，返回true，尝试失败返回false</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (<span style="color:#99d1db;font-weight:bold">!</span>tryAcquire(arg) <span style="color:#99d1db;font-weight:bold">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 走到这，代表获取锁资源失败，需要将当前线程封装成一个Node，追加到AQS的队列中</span>
</span></span><span style="display:flex;"><span>        acquireQueued(addWaiter(Node.<span style="color:#8caaee">EXCLUSIVE</span>), arg))
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 线程中断</span>
</span></span><span style="display:flex;"><span>        selfInterrupt();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>首先调用 <code>tryAcquire</code> 尝试去获取资源。如果获取资源失败，就通过 <code>addWaiter(Node.EXCLUSIVE)</code> 方法把这个线程插入到等待队列中。其中传入的参数代表要插入的 Node 是独占式的。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">private</span> Node <span style="color:#8caaee">addWaiter</span>(Node mode) {
</span></span><span style="display:flex;"><span> <span style="color:#737994;font-style:italic">//创建 Node 类，并且设置 thread 为当前线程，设置为排它锁</span>
</span></span><span style="display:flex;"><span> Node node <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Node(Thread.<span style="color:#8caaee">currentThread</span>(), mode);
</span></span><span style="display:flex;"><span> <span style="color:#737994;font-style:italic">// 获取 AQS 中队列的尾部节点</span>
</span></span><span style="display:flex;"><span> Node pred <span style="color:#99d1db;font-weight:bold">=</span> tail;
</span></span><span style="display:flex;"><span> <span style="color:#737994;font-style:italic">// 如果 tail == null，说明是空队列，</span>
</span></span><span style="display:flex;"><span> <span style="color:#737994;font-style:italic">// 不为 null，说明现在队列中有数据，</span>
</span></span><span style="display:flex;"><span> <span style="color:#ca9ee6">if</span> (pred <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#737994;font-style:italic">// 将当前节点的 prev 指向刚才的尾部节点，那么当前节点应该设置为尾部节点</span>
</span></span><span style="display:flex;"><span>  node.<span style="color:#8caaee">prev</span> <span style="color:#99d1db;font-weight:bold">=</span> pred;
</span></span><span style="display:flex;"><span>  <span style="color:#737994;font-style:italic">// CAS 将 tail 节点设置为当前节点</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ca9ee6">if</span> (compareAndSetTail(pred, node)) {
</span></span><span style="display:flex;"><span>   <span style="color:#737994;font-style:italic">// 将之前尾节点的 next 设置为当前节点</span>
</span></span><span style="display:flex;"><span>   pred.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> node;
</span></span><span style="display:flex;"><span>   <span style="color:#737994;font-style:italic">// 返回当前节点</span>
</span></span><span style="display:flex;"><span>   <span style="color:#ca9ee6">return</span> node;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> enq(node);
</span></span><span style="display:flex;"><span> <span style="color:#ca9ee6">return</span> node;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// 自旋CAS插入等待队列</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">private</span> Node <span style="color:#8caaee">enq</span>(<span style="color:#e78284">final</span> Node node) {
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">for</span> (;;) {
</span></span><span style="display:flex;"><span>        Node t <span style="color:#99d1db;font-weight:bold">=</span> tail;
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (t <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span>) { <span style="color:#737994;font-style:italic">// Must initialize</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (compareAndSetHead(<span style="color:#ca9ee6">new</span> Node()))
</span></span><span style="display:flex;"><span>                tail <span style="color:#99d1db;font-weight:bold">=</span> head;
</span></span><span style="display:flex;"><span>        } <span style="color:#ca9ee6">else</span> {
</span></span><span style="display:flex;"><span>            node.<span style="color:#8caaee">prev</span> <span style="color:#99d1db;font-weight:bold">=</span> t;
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (compareAndSetTail(t, node)) {
</span></span><span style="display:flex;"><span>                t.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> node;
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">return</span> t;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在队列的尾部插入新的 Node 节点，但是需要注意的是由于 AQS 中会存在多个线程同时争夺资源的情况，因此肯定会出现多个线程同时插入节点的操作，在这里是通过 CAS 自旋的方式保证了操作的线程安全性。</p>
<h5 id="释放资源">释放资源<a class="td-heading-self-link" href="#%e9%87%8a%e6%94%be%e8%b5%84%e6%ba%90" aria-label="Heading self-link"></a></h5>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">final</span> <span style="color:#e78284">boolean</span> <span style="color:#8caaee">release</span>(<span style="color:#e78284">int</span> arg) {
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (tryRelease(arg)) {
</span></span><span style="display:flex;"><span>        Node h <span style="color:#99d1db;font-weight:bold">=</span> head;
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (h <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">&amp;&amp;</span> h.<span style="color:#8caaee">waitStatus</span> <span style="color:#99d1db;font-weight:bold">!=</span> 0)
</span></span><span style="display:flex;"><span>            unparkSuccessor(h);
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">private</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">unparkSuccessor</span>(Node node) {
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 如果状态是负数，尝试把它设置为0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> ws <span style="color:#99d1db;font-weight:bold">=</span> node.<span style="color:#8caaee">waitStatus</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (ws <span style="color:#99d1db;font-weight:bold">&lt;</span> 0)
</span></span><span style="display:flex;"><span>        compareAndSetWaitStatus(node, ws, 0);
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 得到头结点的后继结点head.next</span>
</span></span><span style="display:flex;"><span>    Node s <span style="color:#99d1db;font-weight:bold">=</span> node.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 如果这个后继结点为空或者状态大于0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 通过前面的定义我们知道，大于0只有一种可能，就是这个结点已被取消（只有 Node.CANCELLED(=1) 这一种状态大于0）</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (s <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">||</span> s.<span style="color:#8caaee">waitStatus</span> <span style="color:#99d1db;font-weight:bold">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>        s <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ef9f76">null</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 从尾部开始倒着寻找第一个还未取消的节点（真正的后继者）</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (Node t <span style="color:#99d1db;font-weight:bold">=</span> tail; t <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">&amp;&amp;</span> t <span style="color:#99d1db;font-weight:bold">!=</span> node; t <span style="color:#99d1db;font-weight:bold">=</span> t.<span style="color:#8caaee">prev</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (t.<span style="color:#8caaee">waitStatus</span> <span style="color:#99d1db;font-weight:bold">&lt;=</span> 0)
</span></span><span style="display:flex;"><span>                s <span style="color:#99d1db;font-weight:bold">=</span> t;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 如果后继结点不为空，</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (s <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>)
</span></span><span style="display:flex;"><span>        LockSupport.<span style="color:#8caaee">unpark</span>(s.<span style="color:#8caaee">thread</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果<code>tryRelease(arg)</code>成功释放了锁，那么接下来会检查队列的头结点。如果头结点存在并且waitStatus不为0（这意味着有线程在等待），那么会调用<code>unparkSuccessor(Node h)</code>方法来唤醒等待的线程。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9c0e1807d41464a916022b9559a1749d">2.2 - JMM内存模型</h1>
    <div class="lead">Java 内存模型（Java Memory Model，JMM）定义了 Java 程序中的变量、线程如何和主存以及工作内存进行交互的规则</div>
	<p>Java 内存模型（Java Memory Model，JMM）定义了 Java 程序中的变量、线程如何和主存以及工作内存进行交互的规则, 可以理解为并发编程相关的一组规范</p>
<p>JMM在Java中主要解决<a href="/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/">线程同步与通信</a>问题, 涉及到内存可见性, 指令重排等问题</p>
<blockquote>
<p>Java 是最早尝试提供内存模型的编程语言。由于早期内存模型存在一些缺陷（比如非常容易削弱编译器的优化能力），从 Java5 开始，Java 开始使用新的内存模型</p></blockquote>
<blockquote>
<p>一般来说，编程语言也可以直接复用操作系统层面的内存模型。不过，不同的操作系统内存模型不同。如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了。
Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。</p></blockquote>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205095605661.png" alt="image.png"></p>
<p>红色区域称主内存, 是线程存放共享变量的区域</p>
<p>白色为本地内存</p>
<ul>
<li><strong>主内存</strong>：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量，还是局部变量，类信息、常量、静态变量都是放在主内存中。为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。</li>
<li><strong>本地内存</strong>：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的副本。每个线程只能操作自己本地内存中的变量，无法直接访问其他线程的本地内存。如果线程间需要通信，必须通过主内存来进行。本地内存是 JMM 抽象出来的一个概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</li>
</ul>
<h4 id="内存可见性问题">内存可见性问题<a class="td-heading-self-link" href="#%e5%86%85%e5%ad%98%e5%8f%af%e8%a7%81%e6%80%a7%e9%97%ae%e9%a2%98" aria-label="Heading self-link"></a></h4>
<p>和 <a href="CPU%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.md">CPU cache</a> 类似, 当多个线程同时读写共享变量时, 线程不存在同步机制会导致变量被覆写, 导致结果不可预见
<img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205100230451.png" alt="image.png"></p>
<p>如何解决内存可见性问题?</p>
<p>关于主内存与工作内存直接的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义来以下八种同步操作</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205100905174.png" alt="image.png">
初次之外还规定了很多同步规则,这不重要</p>
<h4 id="指令重排序问题">指令重排序问题<a class="td-heading-self-link" href="#%e6%8c%87%e4%bb%a4%e9%87%8d%e6%8e%92%e5%ba%8f%e9%97%ae%e9%a2%98" aria-label="Heading self-link"></a></h4>
<p>为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。</p>
<p><strong>什么是指令重排序？</strong> 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。<strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p>
<h4 id="happen-before-原则">happen-before 原则<a class="td-heading-self-link" href="#happen-before-%e5%8e%9f%e5%88%99" aria-label="Heading self-link"></a></h4>
<blockquote>
<p>happens-before 这个概念最早诞生于 Leslie Lamport 于 1978 年发表的论文<a href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf">《Time，Clocks and the Ordering of Events in a Distributed System》</a>。在这篇论文中，Leslie Lamport 提出了逻辑时钟的概念，这也成了第一个逻辑时钟算法 。</p></blockquote>
<p><strong>逻辑时钟并不度量时间本身，仅区分事件发生的前后顺序，其本质就是定义了一种 happens-before 关系。</strong></p>
<p>也就是说, happen-before确定了</p>
<ol>
<li>只要不改变程序的执行结果（单线程程序和正确执行的多线程程序），编译器和处理器怎么进行重排序优化都行。</li>
<li>对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。
<img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205101317644.png" alt="image.png"></li>
</ol>
<p>结合happen-before关系和上述的同步规则, 就可以解决线程的通信与同步</p>
<ul>
<li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前。</li>
<li>两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。
例如</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">int</span> userNum <span style="color:#99d1db;font-weight:bold">=</span> getUserNum();   <span style="color:#737994;font-style:italic">// 1</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> teacherNum <span style="color:#99d1db;font-weight:bold">=</span> getTeacherNum();   <span style="color:#737994;font-style:italic">// 2</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> totalNum <span style="color:#99d1db;font-weight:bold">=</span> userNum <span style="color:#99d1db;font-weight:bold">+</span> teacherNum;  <span style="color:#737994;font-style:italic">// 3</span>
</span></span></code></pre></div><p>虽然 1 happens-before 2，但对 1 和 2 进行重排序不会影响代码的执行结果，所以 JMM 是允许编译器和处理器执行这种重排序的。但 1 和 2 必须是在 3 执行之前，也就是说 1,2 happens-before 3 。</p>
<p>happen-before 的实质就是前一个操作是否需要对后一个操作可见也就是涉及到了两个操作共有的变量, 需要便符合happen-before 关系
这与是否为并发环境无关</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205101819135.png" alt="image.png"></p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1f9fd30b05b061ba7093b80b98078894">2.3 - ReentrantLock重入锁</h1>
    <div class="lead">java.util.concurrent.locks包提供的ReentrantLock用于替代synchronized加锁</div>
	<h4 id="重入性">重入性<a class="td-heading-self-link" href="#%e9%87%8d%e5%85%a5%e6%80%a7" aria-label="Heading self-link"></a></h4>
<p>重入性指当线程需要再次获取同一把锁时, 不会因为自身而造成死锁, 锁的本质是<strong>作用于代码块或方法</strong>，而不是线程的整个执行上下文。即使线程已经持有锁，进入新的同步方法或代码块时，仍然需要执行<strong>获取锁</strong>的操作，确保锁的计数正确。</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250209113038176.png" alt="image.png"></p>
<p>所以支持重入性应该解决下列问题</p>
<ul>
<li>由于获得多次相同的锁, 需要计数以释放相同次数</li>
<li>相同线程再次获取锁应当直接成功, 防止死锁</li>
</ul>
<h4 id="为什么需要reentrantlock">为什么需要<code>ReentrantLock</code><a class="td-heading-self-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81reentrantlock" aria-label="Heading self-link"></a></h4>
<p>Java语言直接提供了<code>synchronized</code>关键字用于加锁，但这种锁一是很重，二是获取时必须一直等待，没有额外的尝试机制。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#ca9ee6">if</span> (lock.<span style="color:#8caaee">tryLock</span>(1, TimeUnit.<span style="color:#8caaee">SECONDS</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">try</span> {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    } <span style="color:#ca9ee6">finally</span> {
</span></span><span style="display:flex;"><span>        lock.<span style="color:#8caaee">unlock</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>java.util.concurrent.locks</code>包提供的<code>ReentrantLock</code>用于替代<code>synchronized</code>加锁</p>
<p>尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，<code>tryLock()</code>返回<code>false</code>，程序就可以做一些额外处理，而不是无限等待下去。</p>
<p>所以，使用<code>ReentrantLock</code>比直接使用<code>synchronized</code>更安全，线程在<code>tryLock()</code>失败的时候不会导致死锁。</p>
<h1 id="reentrantlock使用">ReentrantLock使用<a class="td-heading-self-link" href="#reentrantlock%e4%bd%bf%e7%94%a8" aria-label="Heading self-link"></a></h1>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">Counter</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//和关键字不同, 需要获得一个重入锁对象</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> <span style="color:#e78284">final</span> Lock lock <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> ReentrantLock();
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> <span style="color:#e78284">int</span> count;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">add</span>(<span style="color:#e78284">int</span> n) {
</span></span><span style="display:flex;"><span>		<span style="color:#737994;font-style:italic">//代码块加锁</span>
</span></span><span style="display:flex;"><span>        lock.<span style="color:#8caaee">lock</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">try</span> {
</span></span><span style="display:flex;"><span>            count <span style="color:#99d1db;font-weight:bold">+=</span> n;
</span></span><span style="display:flex;"><span>        } <span style="color:#ca9ee6">finally</span> {
</span></span><span style="display:flex;"><span>	        <span style="color:#737994;font-style:italic">//在finally中解锁</span>
</span></span><span style="display:flex;"><span>            lock.<span style="color:#8caaee">unlock</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1e490e506623fa0b06824a180f822aad">2.4 - synchronized关键字</h1>
    <div class="lead">关键字 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)，同时我们还应该注意到 synchronized 的另外一个重要的作用，synchronized 可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代 volatile 功能）。</div>
	<blockquote>
<p>在 Java 中，关键字 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)
synchronized 的另外一个重要的作用，synchronized 可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到</p></blockquote>
<p>synchronized 关键字最主要有以下 3 种应用方式：</p>
<ul>
<li>同步方法，为当前对象加锁，进入同步代码前要获得当前对象的锁；</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">AccountingSync</span> <span style="color:#e78284">implements</span> Runnable {
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">//共享资源(临界资源)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> 0;
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// synchronized 同步方法</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">synchronized</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">increase</span>() {
</span></span><span style="display:flex;"><span>        i <span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#8caaee;font-weight:bold">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span>(<span style="color:#e78284">int</span> j<span style="color:#99d1db;font-weight:bold">=</span>0;j<span style="color:#99d1db;font-weight:bold">&lt;</span>1000000;j<span style="color:#99d1db;font-weight:bold">++</span>){
</span></span><span style="display:flex;"><span>            increase();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String args<span style="color:#99d1db;font-weight:bold">[]</span>) <span style="color:#e78284">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>        AccountingSync instance <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> AccountingSync();
</span></span><span style="display:flex;"><span>        Thread t1 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Thread(instance);
</span></span><span style="display:flex;"><span>        Thread t2 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Thread(instance);
</span></span><span style="display:flex;"><span>        t1.<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>        t2.<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>        t1.<span style="color:#8caaee">join</span>();
</span></span><span style="display:flex;"><span>        t2.<span style="color:#8caaee">join</span>();
</span></span><span style="display:flex;"><span>        System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(<span style="color:#a6d189">&#34;static, i output:&#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>同步静态方法，为当前类加锁，进入同步代码前要获得当前类的锁；</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">AccountingSyncClass</span> <span style="color:#e78284">implements</span> Runnable {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> 0;
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     * 同步静态方法,锁是当前class对象，也就是
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     * AccountingSyncClass类对应的class对象
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">synchronized</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">increase</span>() {
</span></span><span style="display:flex;"><span>        i<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 非静态,访问时锁不一样不会发生互斥</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">synchronized</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">increase4Obj</span>() {
</span></span><span style="display:flex;"><span>        i<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#8caaee;font-weight:bold">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span>(<span style="color:#e78284">int</span> j<span style="color:#99d1db;font-weight:bold">=</span>0;j<span style="color:#99d1db;font-weight:bold">&lt;</span>1000000;j<span style="color:#99d1db;font-weight:bold">++</span>){
</span></span><span style="display:flex;"><span>            increase();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) <span style="color:#e78284">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//new新实例</span>
</span></span><span style="display:flex;"><span>        Thread t1<span style="color:#99d1db;font-weight:bold">=</span><span style="color:#ca9ee6">new</span> Thread(<span style="color:#ca9ee6">new</span> AccountingSyncClass());
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//new新实例</span>
</span></span><span style="display:flex;"><span>        Thread t2<span style="color:#99d1db;font-weight:bold">=</span><span style="color:#ca9ee6">new</span> Thread(<span style="color:#ca9ee6">new</span> AccountingSyncClass());
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//启动线程</span>
</span></span><span style="display:flex;"><span>        t1.<span style="color:#8caaee">start</span>();t2.<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>        t1.<span style="color:#8caaee">join</span>();t2.<span style="color:#8caaee">join</span>();
</span></span><span style="display:flex;"><span>        System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * 输出结果:
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * 2000000
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span>
</span></span></code></pre></div><ul>
<li>同步代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">AccountingSync2</span> <span style="color:#e78284">implements</span> Runnable {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> AccountingSync2 instance <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> AccountingSync2(); <span style="color:#737994;font-style:italic">// 饿汉单例模式</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">int</span> i<span style="color:#99d1db;font-weight:bold">=</span>0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8caaee;font-weight:bold">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//省略其他耗时操作....</span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//使用同步代码块对变量i进行同步操作,锁对象为instance</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">synchronized</span>(instance){
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">for</span>(<span style="color:#e78284">int</span> j<span style="color:#99d1db;font-weight:bold">=</span>0;j<span style="color:#99d1db;font-weight:bold">&lt;</span>1000000;j<span style="color:#99d1db;font-weight:bold">++</span>){
</span></span><span style="display:flex;"><span>                i<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) <span style="color:#e78284">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>        Thread t1<span style="color:#99d1db;font-weight:bold">=</span><span style="color:#ca9ee6">new</span> Thread(instance);
</span></span><span style="display:flex;"><span>        Thread t2<span style="color:#99d1db;font-weight:bold">=</span><span style="color:#ca9ee6">new</span> Thread(instance);
</span></span><span style="display:flex;"><span>        t1.<span style="color:#8caaee">start</span>();t2.<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>        t1.<span style="color:#8caaee">join</span>();t2.<span style="color:#8caaee">join</span>();
</span></span><span style="display:flex;"><span>        System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>这里的锁指的是 Java 内置的隐式锁 monitor 也是 <code>synchronized</code> 封装好的实现
每个对象都有一个对象锁，不同的对象，他们的锁不会互相影响。</p></blockquote>
<p>synchronized 与 happens before</p>
<blockquote>
<p>[[JMM内存模型]]</p></blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-81976703554d30e4d0a1ddbd1d6055b1">2.5 - ThreadLocal</h1>
    
	<blockquote>
<p>前置
<a href="/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a></p></blockquote>
<p>是 Java 中提供的一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离，用于解决多线程中共享对象的线程安全问题。</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210182243836.png" alt="image.png"></p>
<p>使用:</p>
<p>创建 ThreadLocal对象</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//创建一个ThreadLocal变量</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">static</span> ThreadLocal<span style="color:#99d1db;font-weight:bold">&lt;</span>String<span style="color:#99d1db;font-weight:bold">&gt;</span> localVariable <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> ThreadLocal<span style="color:#99d1db;font-weight:bold">&lt;&gt;</span>();
</span></span></code></pre></div><p>设置值</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//设置ThreadLocal变量的值 localVariable.set(&#34;0001&#34;);</span>
</span></span></code></pre></div><p>获取值</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//获取ThreadLocal变量的值 String value = localVariable.get();</span>
</span></span></code></pre></div><p>优点</p>
<ol>
<li>
<p>线程隔离
实现了变量的独占, 使变量不需要同步处理</p>
</li>
<li>
<p>数据传递方便
ThreadLocal 常用于在跨方法、跨类时传递上下文数据（如用户信息等），而不需要在方法间传递参数。</p>
</li>
</ol>
<h4 id="threadlocalmap"><code>ThreadLocalMap</code><a class="td-heading-self-link" href="#threadlocalmap" aria-label="Heading self-link"></a></h4>
<p>ThreadLocalMap, 一个key-value数据形式结构，也是ThreadLocal的核心。</p>
<p>Map内部维护了一个Entry数组, 真正的数据存储在 Entry中, map的key是每个线程中ThreadLocal对象的哈希, value是隔离变量</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * 初始容量
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> <span style="color:#e78284">int</span> INITIAL_CAPACITY <span style="color:#99d1db;font-weight:bold">=</span> 16;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * ThreadLocalMap数据真正存储在table中
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">private</span> Entry<span style="color:#99d1db;font-weight:bold">[]</span> table;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * ThreadLocalMap条数
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">private</span> <span style="color:#e78284">int</span> size <span style="color:#99d1db;font-weight:bold">=</span> 0;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * 达到这个大小，则扩容
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">private</span> <span style="color:#e78284">int</span> threshold; <span style="color:#737994;font-style:italic">// 默认为0</span>
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210192010058.png" alt="image.png"></p>
<p>为了保证Entry[] 数组散步均匀, 哈希算法如下</p>
<p>把对应的 key 映射到 table 数组的相应下标，ThreadLocalMap 用的是哈希取余法，取出 key 的 threadLocalHashCode，然后和 table 数组长度减一&amp;运算（相当于取余）。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> key.<span style="color:#8caaee">threadLocalHashCode</span> <span style="color:#99d1db;font-weight:bold">&amp;</span> (table.<span style="color:#8caaee">length</span> <span style="color:#99d1db;font-weight:bold">-</span> 1);
</span></span></code></pre></div><p>这里的hashcode由魔术数生成
每创建一个 ThreadLocal 对象，它就会新增<code>0x61c88647</code>，这个值很特殊，它是<strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong>。<code>hash</code>增量为 这个数字，带来的好处就是 <code>hash</code> <strong>分布非常均匀</strong>。</p>
<h4 id="inheritablethreadlocal"><code>InheritableThreadLocal()</code><a class="td-heading-self-link" href="#inheritablethreadlocal" aria-label="Heading self-link"></a></h4>
<p>父子线程是无法传输数据的, 但是通过InheritableThreadLocal实例就可以在子线程拿到值</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">InheritableThreadLocalTest</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">final</span> ThreadLocal threadLocal <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> InheritableThreadLocal();
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 主线程</span>
</span></span><span style="display:flex;"><span>        threadLocal.<span style="color:#8caaee">set</span>(<span style="color:#a6d189">&#34;父线程&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//子线程</span>
</span></span><span style="display:flex;"><span>        Thread t <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Thread() {
</span></span><span style="display:flex;"><span>            <span style="color:#8caaee;font-weight:bold">@Override</span>
</span></span><span style="display:flex;"><span>            <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">run</span>() {
</span></span><span style="display:flex;"><span>                <span style="color:#e78284">super</span>.<span style="color:#8caaee">run</span>();
</span></span><span style="display:flex;"><span>                System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(<span style="color:#a6d189">&#34;子线程 ，&#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> threadLocal.<span style="color:#8caaee">get</span>());
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        t.<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>原理:</p>
<p>在Thread中有一个变量</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ThreadLocal.<span style="color:#8caaee">ThreadLocalMap</span> inheritableThreadLocals <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ef9f76">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">if</span> (inheritThreadLocals <span style="color:#99d1db;font-weight:bold">&amp;&amp;</span> parent.<span style="color:#8caaee">inheritableThreadLocals</span> <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">this</span>.<span style="color:#8caaee">inheritableThreadLocals</span> <span style="color:#99d1db;font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>        ThreadLocal.<span style="color:#8caaee">createInheritedMap</span>(parent.<span style="color:#8caaee">inheritableThreadLocals</span>);
</span></span></code></pre></div><p>在 Thread.init 的时候，如果父线程的<code>inheritableThreadLocals</code>不为空，就把它赋给当前线程（子线程）的<code>inheritableThreadLocals</code> 。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8c7a9a4b1c4339f056825f6e89e26d39">2.6 - volatile关键字</h1>
    <div class="lead">volatile 可以保证可见性，但不保证原子性：当写一个 volatile 变量时，JMM 会把该线程在本地内存中的变量强制刷新到主内存中去；这个写操作会导致其他线程中的 volatile 变量缓存无效。</div>
	<h4 id="什么是-volatile">什么是 <code>volatile</code><a class="td-heading-self-link" href="#%e4%bb%80%e4%b9%88%e6%98%af-volatile" aria-label="Heading self-link"></a></h4>
<h4 id="为什么要使用-volatile">为什么要使用 <code>volatile</code><a class="td-heading-self-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8-volatile" aria-label="Heading self-link"></a></h4>
<blockquote>
<p>[[线程安全问题]]</p></blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1e3be358e2f744df6d4d87e2255be4ac">2.7 - 多线程入门</h1>
    <div class="lead">并发编程入口</div>
	<h4 id="为什么要实现多线程">为什么要实现多线程?<a class="td-heading-self-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%ae%9e%e7%8e%b0%e5%a4%9a%e7%ba%bf%e7%a8%8b" aria-label="Heading self-link"></a></h4>
<blockquote>
<p>[!前置]
<a href="/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/">线程与进程</a></p></blockquote>
<p>进程使得操作系统可以<a href="/docs/general/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/">并发</a>的执行任务
但是在一段时间内单个进程只能执行一个任务
进程内的子任务只能逐个按顺序执行, 效率还有提升空间</p>
<p>因此提出线程概念, 使得一个线程可以执行一个子任务使得进程内部也可实现并发, 提高效率</p>
<blockquote>
<p>[!NOTE]
多线程的优势</p>
<ul>
<li>
<p>进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信很容易。</p>
</li>
<li>
<p>进程是重量级的，而线程是轻量级的，多线程方式的系统开销更小。</p>
</li>
</ul></blockquote>
<p>Java中创建线程的三种方式</p>
<h4 id="继承-thread-类">继承 <code>Thread</code> 类<a class="td-heading-self-link" href="#%e7%bb%a7%e6%89%bf-thread-%e7%b1%bb" aria-label="Heading self-link"></a></h4>
<p>重写 <code>run</code> 方法</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">MyThread</span> <span style="color:#e78284">extends</span> Thread {
</span></span><span style="display:flex;"><span>    <span style="color:#8caaee;font-weight:bold">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> 0; i <span style="color:#99d1db;font-weight:bold">&lt;</span> 100; i<span style="color:#99d1db;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(getName() <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;:打了&#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> i <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;个小兵&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>主函数启动线程</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//创建MyThread对象</span>
</span></span><span style="display:flex;"><span>MyThread t1<span style="color:#99d1db;font-weight:bold">=</span><span style="color:#ca9ee6">new</span> MyThread();
</span></span><span style="display:flex;"><span>MyThread t2<span style="color:#99d1db;font-weight:bold">=</span><span style="color:#ca9ee6">new</span> MyThread();
</span></span><span style="display:flex;"><span>MyThread t3<span style="color:#99d1db;font-weight:bold">=</span><span style="color:#ca9ee6">new</span> MyThread();
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//设置线程的名字</span>
</span></span><span style="display:flex;"><span>t1.<span style="color:#8caaee">setName</span>(<span style="color:#a6d189">&#34;鲁班&#34;</span>);
</span></span><span style="display:flex;"><span>t2.<span style="color:#8caaee">setName</span>(<span style="color:#a6d189">&#34;刘备&#34;</span>);
</span></span><span style="display:flex;"><span>t3.<span style="color:#8caaee">setName</span>(<span style="color:#a6d189">&#34;亚瑟&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//启动线程</span>
</span></span><span style="display:flex;"><span>t1.<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>t2.<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>t3.<span style="color:#8caaee">start</span>();
</span></span></code></pre></div><h4 id="实现-runnable-接口">实现 <code>Runnable</code> 接口<a class="td-heading-self-link" href="#%e5%ae%9e%e7%8e%b0-runnable-%e6%8e%a5%e5%8f%a3" aria-label="Heading self-link"></a></h4>
<p>创建任务类实现 <code>Runnable</code> 接口</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">MyRunnable</span> <span style="color:#e78284">implements</span> Runnable {
</span></span><span style="display:flex;"><span>    <span style="color:#8caaee;font-weight:bold">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> 0; i <span style="color:#99d1db;font-weight:bold">&lt;</span> 10; i<span style="color:#99d1db;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">try</span> {<span style="color:#737994;font-style:italic">//sleep会发生异常要显式处理</span>
</span></span><span style="display:flex;"><span>                Thread.<span style="color:#8caaee">sleep</span>(20);<span style="color:#737994;font-style:italic">//暂停20毫秒</span>
</span></span><span style="display:flex;"><span>            } <span style="color:#ca9ee6">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                e.<span style="color:#8caaee">printStackTrace</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(Thread.<span style="color:#8caaee">currentThread</span>().<span style="color:#8caaee">getName</span>() <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;打了:&#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> i <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;个小兵&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>主函数启动线程</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//创建MyRunnable类</span>
</span></span><span style="display:flex;"><span>MyRunnable mr <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> MyRunnable();
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//创建Thread类的有参构造,并设置线程名</span>
</span></span><span style="display:flex;"><span>Thread t1 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Thread(mr, <span style="color:#a6d189">&#34;张飞&#34;</span>);
</span></span><span style="display:flex;"><span>Thread t2 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Thread(mr, <span style="color:#a6d189">&#34;貂蝉&#34;</span>);
</span></span><span style="display:flex;"><span>Thread t3 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Thread(mr, <span style="color:#a6d189">&#34;吕布&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//启动线程</span>
</span></span><span style="display:flex;"><span>t1.<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>t2.<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>t3.<span style="color:#8caaee">start</span>();
</span></span></code></pre></div><h4 id="实现-callable-接口">实现 <code>Callable&lt;&gt;</code> 接口<a class="td-heading-self-link" href="#%e5%ae%9e%e7%8e%b0-callable-%e6%8e%a5%e5%8f%a3" aria-label="Heading self-link"></a></h4>
<blockquote>
<p>[!NOTE]
相较于 <code>Runnable</code> 接口
<code>callable&lt;&gt;</code> 可以获取线程的执行结果, 使用 <code>FutureTask</code> 类存储
了解 [[获取线程执行结果]]</p></blockquote>
<p>重写 <code>call&lt;&gt;</code> 方法</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">CallerTask</span> <span style="color:#e78284">implements</span> Callable<span style="color:#99d1db;font-weight:bold">&lt;</span>String<span style="color:#99d1db;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#e78284">public</span> String <span style="color:#8caaee">call</span>() <span style="color:#e78284">throws</span> Exception {
</span></span><span style="display:flex;"><span>       <span style="color:#ca9ee6">return</span> <span style="color:#a6d189">&#34;Hello,i am running!&#34;</span>;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>主函数启动线程</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//创建异步任务</span>
</span></span><span style="display:flex;"><span>        FutureTask<span style="color:#99d1db;font-weight:bold">&lt;</span>String<span style="color:#99d1db;font-weight:bold">&gt;</span> task<span style="color:#99d1db;font-weight:bold">=</span><span style="color:#ca9ee6">new</span> FutureTask<span style="color:#99d1db;font-weight:bold">&lt;</span>String<span style="color:#99d1db;font-weight:bold">&gt;</span>(<span style="color:#ca9ee6">new</span> CallerTask());
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//启动线程</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">new</span> Thread(task).<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">//等待执行完成，并获取返回结果</span>
</span></span><span style="display:flex;"><span>            String result<span style="color:#99d1db;font-weight:bold">=</span>task.<span style="color:#8caaee">get</span>();
</span></span><span style="display:flex;"><span>            System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(result);
</span></span><span style="display:flex;"><span>        } <span style="color:#ca9ee6">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>            e.<span style="color:#8caaee">printStackTrace</span>();
</span></span><span style="display:flex;"><span>        } <span style="color:#ca9ee6">catch</span> (ExecutionException e) {
</span></span><span style="display:flex;"><span>            e.<span style="color:#8caaee">printStackTrace</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>了解:
<a href="/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">线程生命周期</a></p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-39ecca64f8ebd31d21ffdc061978beef">2.8 - 线程</h1>
    <div class="lead">线程，是进程的子任务，是 CPU 调度和分派的基本单位，实现了进程内部的并发。</div>
	<p>进程
说简单点就是我们在电脑上启动的一个个应用。它是操作系统分配资源的最小单位。</p>
<p>线程
是进程的子任务，是 CPU 调度和分派的基本单位，实现了进程内部的并发。</p>
<h4 id="线程与进程">线程与进程<a class="td-heading-self-link" href="#%e7%ba%bf%e7%a8%8b%e4%b8%8e%e8%bf%9b%e7%a8%8b" aria-label="Heading self-link"></a></h4>
<p>线程，是进程的子任务，是进程中的独立执行单元。多个线程可以共享同一个进程的资源，如内存；每个线程都有自己独立的栈和寄存器。</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205083709918.png" alt="image.png"></p>
<p>并发环境下, 多线程存在下述问题</p>
<ol>
<li>线程之间如何确保执行顺序,实现线程之间的协调与合作? 线程通信</li>
<li>线程之间如何确保对临界资源修改不会冲突? 线程同步?</li>
</ol>
<h4 id="线程通信线程通信md"><a href="/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/">线程通信</a><a class="td-heading-self-link" href="#%e7%ba%bf%e7%a8%8b%e9%80%9a%e4%bf%a1%e7%ba%bf%e7%a8%8b%e9%80%9a%e4%bf%a1md" aria-label="Heading self-link"></a></h4>
<blockquote>
<p><em>Inter-thread communication in Java is a mechanism in which a thread is paused running in its critical section and another thread is allowed to enter (or lock) in the same critical section to be executed.</em></p>
<p><strong>线程间通信</strong>
是一种机制，使得线程能够在执行时进行协作，通常用于解决某些线程需要等待其他线程完成任务的情况。它主要涉及线程之间的等待和通知机制，而不是同一临界区内的互斥访问。</p></blockquote>
<h4 id="线程同步">线程同步<a class="td-heading-self-link" href="#%e7%ba%bf%e7%a8%8b%e5%90%8c%e6%ad%a5" aria-label="Heading self-link"></a></h4>
<blockquote>
<p><strong>Synchronization</strong> is crucial for ensuring that multiple threads operate safely on shared resources. Without *<strong>Synchronization</strong>, data inconsistency or corruption can occur when multiple threads try to access and modify shared variables simultaneously. In Java, it is a mechanism that ensures that only one thread can access a resource at any given time</p>
<p>线程同步的重点是 <strong>保证线程安全</strong>，特别是在多个线程访问共享资源时。同步机制通过确保某个共享资源在同一时刻只能被一个线程访问来防止数据不一致或冲突。Java 中的 <code>synchronized</code> 关键字和 <code>ReentrantLock</code> 都是同步机制的实现，确保线程在访问共享资源时不会发生并发冲突。</p></blockquote>
<p>解决上述问题的方式有两种</p>
<ol>
<li>共享内存</li>
<li>消息传递</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205093046393.png" alt="image.png"></p>
<p>Java 使用共享内存的并发模型实现线程同步与通信, 这个模型称之为 <a href="/docs/basic/concurrent/jmm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">JMM</a>
JMM 决定了一个线程对共享变量的写入何时对另外一个线程可见。</p>
<p>引用:
<a href="https://www.geeksforgeeks.org/inter-thread-communication-java/">Geekfork</a></p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-102bfdf29b786bceaca7b6b0ae2231f3">2.9 - 线程安全问题</h1>
    <div class="lead">线程安全问题涉及数据竞争、资源竞争、竞态条件、死锁和饥饿等，常见于多线程并发访问共享资源时。</div>
	<blockquote>
<p>前置
<a href="/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/">线程与进程</a></p></blockquote>
<p>线程安全是指, 在多线程环境下, 多个线程对共享资源进行并发访问和操作时可能出现的问题</p>
<h4 id="常见的线程安全问题">常见的线程安全问题<a class="td-heading-self-link" href="#%e5%b8%b8%e8%a7%81%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e9%97%ae%e9%a2%98" aria-label="Heading self-link"></a></h4>
<h5 id="可见性问题">可见性问题<a class="td-heading-self-link" href="#%e5%8f%af%e8%a7%81%e6%80%a7%e9%97%ae%e9%a2%98" aria-label="Heading self-link"></a></h5>
<p>确保一个线程对共享变量的修改可以立即被其他线程看到。
数据竞争
当多个线程同时访问和修改共享变量时,
没有适当的同步机制来保护数据一致性, 会导致不可预测的结果</p>
<p>volatile 关键字可以保证了变量的修改对所有线程立即可见，并防止编译器优化导致的可见性问题。</p>
<h5 id="原子性问题">原子性问题<a class="td-heading-self-link" href="#%e5%8e%9f%e5%ad%90%e6%80%a7%e9%97%ae%e9%a2%98" aria-label="Heading self-link"></a></h5>
<p>确保当某个线程修改共享变量时，没有其他线程可以同时修改这个变量，即这个操作是不可分割的。
如果操作的原子性被破坏, 就会导致只有部分操作成功使得结果无法预测</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205194927449.png" alt="image.png"></p>
<p>原子性可以通过互斥锁（如 synchronized）或原子操作（如 AtomicInteger 类中的方法）来保证。</p>
<h5 id="活跃性问题">活跃性问题<a class="td-heading-self-link" href="#%e6%b4%bb%e8%b7%83%e6%80%a7%e9%97%ae%e9%a2%98" aria-label="Heading self-link"></a></h5>
<p>资源竞争
多个线程争夺有限的资源, 没有适当的同步机制会导致资源分配问题</p>
<ul>
<li>死锁
两个或多个线程同时占用对方的资源且不释放, 这种情况下，线程将永久阻塞，导致程序无法继续执行</li>
<li>饥饿
当某个线程长时间无法得到资源导致该进程无法继续执行, 会发生饥饿现象</li>
</ul>
<blockquote>
<p>引用:
<a href="https://blog.csdn.net/a772304419/article/details/130979664">https://blog.csdn.net/a772304419/article/details/130979664</a>
<a href="https://blog.csdn.net/qq_49217297/article/details/124546726">https://blog.csdn.net/qq_49217297/article/details/124546726</a></p></blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-351a895f640e6e5b71c131358ebdad6d">2.10 - 线程池</h1>
    <div class="lead">池化技术的核心思想就是实现资源的复用，避免资源的重复创建和销毁带来的性能开销。</div>
	<h4 id="什么是线程池">什么是线程池<a class="td-heading-self-link" href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%bf%e7%a8%8b%e6%b1%a0" aria-label="Heading self-link"></a></h4>
<p>线程池(ThreadPool) 是一种基于池化思想管理线程的工具</p>
<p>线程池解决的问题是, 在任意时刻下, 确定系统应该投入多少资源, 解决多少任务</p>
<p>不将线程统一管理可能会出现以下问题</p>
<ol>
<li>频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li>
<li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li>
<li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li>
</ol>
<p>为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210102309459.png" alt="image.png"></p>
<p>线程池内部维护了许多线程, 当有新任务时就会分配一个空闲线程执行
当所有线程都有任务时, 新的任务要么放到阻塞队列里面要么增加线程</p>
<h4 id="使用线程池">使用线程池<a class="td-heading-self-link" href="#%e4%bd%bf%e7%94%a8%e7%ba%bf%e7%a8%8b%e6%b1%a0" aria-label="Heading self-link"></a></h4>
<p>用法:</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// 创建固定大小的线程池:</span>
</span></span><span style="display:flex;"><span>ExecutorService executor <span style="color:#99d1db;font-weight:bold">=</span> Executors.<span style="color:#8caaee">newFixedThreadPool</span>(3);
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// 提交任务:</span>
</span></span><span style="display:flex;"><span>executor.<span style="color:#8caaee">submit</span>(task1);
</span></span><span style="display:flex;"><span>executor.<span style="color:#8caaee">submit</span>(task2);
</span></span><span style="display:flex;"><span>executor.<span style="color:#8caaee">submit</span>(task3);
</span></span><span style="display:flex;"><span>executor.<span style="color:#8caaee">submit</span>(task4);
</span></span><span style="display:flex;"><span>executor.<span style="color:#8caaee">submit</span>(task5);
</span></span></code></pre></div><p>上述代码创建了大小为3的线程池, 并提交了5个任务</p>
<p><code>ExecutorService</code>该接口要求实现工厂方法, 返回如下类型的线程池</p>
<ul>
<li>FixedThreadPool：线程数固定的线程池；</li>
<li>CachedThreadPool：线程数根据任务动态调整的线程池；</li>
<li>ScheduledThreadPool:  定时执行线程池</li>
<li>SingleThreadExecutor：仅单线程执行的线程池。</li>
</ul>
<h4 id="线程池原理解析">线程池原理解析<a class="td-heading-self-link" href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e5%8e%9f%e7%90%86%e8%a7%a3%e6%9e%90" aria-label="Heading self-link"></a></h4>
<p>Java的线程池核心实现为 <code>ThreadPoolExecutor</code></p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210180713994.png" alt="image.png"></p>
<p>顶级接口 <code>Excutor</code> 提供了一种思想, 将任务提交与任务执行解耦
用户只需提供 <code>Runnable</code> 对像, 将任务提交到执行器中, 剩余的线程调配和任务执行由执行器完成</p>
<p>ExecutorService接口增加了一些能力：
（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。</p>
<p>线程池构造类 <code>ThreadPoolExecutor</code>
通过传入参数实现线程池的构造
如下是成员变量,
![[content/en/docs/Basic/Concurrent/Pasted image 20250203123133.png]]
参数解释</p>
<ul>
<li><code>corePoolSize</code>：线程池中用来工作的核心线程数量。</li>
<li><code>maximumPoolSize</code>：最大线程数，线程池允许创建的最大线程数, 可以理解为非核心线程 + 核心线程数</li>
<li><code>workQueue</code>：任务队列，是一个阻塞队列，当线程数达到核心线程数后，会将任务存储在阻塞队列中。</li>
<li><code>threadFactory</code> ：线程池内部创建线程所用的工厂。</li>
<li><code>handler</code>：拒绝策略；当队列已满并且线程数量达到最大线程数量时，会调用该方法处理任务</li>
</ul>
<blockquote>
<p>线程池使用前记得初始化</p></blockquote>
<p>线程池的默认策略是构造完成后不创建线程, 也就是说刚创建好的线程池是没有线程的, 只有传入的 <code>BlockingQueue</code> 也就是[[阻塞队列]] 和其他参数
![[content/en/docs/Basic/Concurrent/Pasted image 20250203123400.png]]
使用线程池之后
当调用任务执行方法 <code>execute()</code> 时启动执行流程
线程执行任务流程如下</p>
<ul>
<li><strong>核心线程数未满</strong>：直接创建新线程执行任务（<strong>不会进队列</strong>）。</li>
<li><strong>核心线程数已满</strong>，<strong>队列未满</strong>：任务进入阻塞队列等待空闲线程执行。</li>
<li><strong>核心线程数已满</strong>，<strong>队列已满</strong>：
<ul>
<li><strong>如果当前线程池线程数未达到最大线程数</strong>，创建非核心线程执行任务。</li>
<li><strong>否则，执行拒绝策略</strong>。</li>
</ul>
</li>
</ul>
<p>队列未满, 创建核心线程</p>
<p>![[content/en/docs/Basic/Concurrent/Pasted image 20250203123742.png]]
队列已满, 创建非核心线程![[content/en/docs/Basic/Concurrent/Pasted image 20250203124516.png]]</p>
<blockquote>
<p>所以，就算队列中已经塞满了任务，新创建的线程还是会优先处理提交的任务，而不是从队列中获取已有的任务执行，<strong>从这可以看出，先提交的任务不一定先执行</strong>。</p></blockquote>
<p>当上述流程无法完成时, 会使用拒绝策略抛出异常
JDK 自带的 <code>RejectedExecutionHandler</code> 实现有 4 种</p>
<ul>
<li>AbortPolicy：丢弃任务，抛出运行时异常</li>
<li>CallerRunsPolicy：由提交任务的线程来执行任务</li>
<li>DiscardPolicy：丢弃这个任务，但是不抛异常</li>
<li>DiscardOldestPolicy：从队列中剔除最先进入队列的任务，然后再次提交任务</li>
</ul>
<p>任务执行方法 <code>excute()</code>
源码如下</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">execute</span>(Runnable command) {
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 首先检查提交的任务是否为null，是的话则抛出NullPointerException。</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (command <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">throw</span> <span style="color:#ca9ee6">new</span> NullPointerException();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 获取线程池的当前状态（ctl是一个AtomicInteger，其中包含了线程池状态和工作线程数）</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> c <span style="color:#99d1db;font-weight:bold">=</span> ctl.<span style="color:#8caaee">get</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 1. 检查当前运行的工作线程数是否少于核心线程数（corePoolSize）</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (workerCountOf(c) <span style="color:#99d1db;font-weight:bold">&lt;</span> corePoolSize) {
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 如果少于核心线程数，尝试添加一个新的工作线程来执行提交的任务</span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// addWorker方法会检查线程池状态和工作线程数，并决定是否真的添加新线程</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (addWorker(command, <span style="color:#ef9f76">true</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">return</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 重新获取线程池的状态，因为在尝试添加线程的过程中线程池的状态可能已经发生变化</span>
</span></span><span style="display:flex;"><span>        c <span style="color:#99d1db;font-weight:bold">=</span> ctl.<span style="color:#8caaee">get</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 2. 尝试将任务添加到任务队列中</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (isRunning(c) <span style="color:#99d1db;font-weight:bold">&amp;&amp;</span> workQueue.<span style="color:#8caaee">offer</span>(command)) {
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">int</span> recheck <span style="color:#99d1db;font-weight:bold">=</span> ctl.<span style="color:#8caaee">get</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 双重检查线程池的状态</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (<span style="color:#99d1db;font-weight:bold">!</span> isRunning(recheck) <span style="color:#99d1db;font-weight:bold">&amp;&amp;</span> remove(command))  <span style="color:#737994;font-style:italic">// 如果线程池已经停止，从队列中移除任务</span>
</span></span><span style="display:flex;"><span>            reject(command);
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 如果线程池正在运行，但是工作线程数为0，尝试添加一个新的工作线程</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">else</span> <span style="color:#ca9ee6">if</span> (workerCountOf(recheck) <span style="color:#99d1db;font-weight:bold">==</span> 0)
</span></span><span style="display:flex;"><span>            addWorker(<span style="color:#ef9f76">null</span>, <span style="color:#ef9f76">false</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 3. 如果任务队列满了，尝试添加一个新的非核心工作线程来执行任务</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">else</span> <span style="color:#ca9ee6">if</span> (<span style="color:#99d1db;font-weight:bold">!</span>addWorker(command, <span style="color:#ef9f76">false</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 如果无法添加新的工作线程（可能因为线程池已经停止或者达到最大线程数限制），则拒绝任务</span>
</span></span><span style="display:flex;"><span>        reject(command);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ea7b52e09c3e940dc03d793d2fc4b6a1">2.11 - 线程生命周期</h1>
    <div class="lead">操作系统中的线程状态转换</div>
	<p>Java的线程分为两类, 用户线程和守护线程</p>
<p>线程调度就是线程不同状态间的转换</p>
<p>在<a href="%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2.md">操作系统</a>中，线程被视为轻量级的进程，所以<strong>线程状态其实和进程状态是一致的</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205105116917.png" alt="image.png"></p>
<p>Java线程有如下状态</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// Thread.State 源码</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">enum</span> State {
</span></span><span style="display:flex;"><span>    NEW,
</span></span><span style="display:flex;"><span>    RUNNABLE,
</span></span><span style="display:flex;"><span>    BLOCKED,
</span></span><span style="display:flex;"><span>    WAITING,
</span></span><span style="display:flex;"><span>    TIMED_WAITING,
</span></span><span style="display:flex;"><span>    TERMINATED;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="new">NEW<a class="td-heading-self-link" href="#new" aria-label="Heading self-link"></a></h4>
<p>处于 NEW 状态的线程是刚创建 <code>Thread</code> 而尚未启动。这里的尚未启动指的是还没调用 Thread 实例的<code>start()</code>方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">private</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">testStateNew</span>() {
</span></span><span style="display:flex;"><span>    Thread thread <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Thread(() <span style="color:#99d1db;font-weight:bold">-&gt;</span> {});
</span></span><span style="display:flex;"><span>    System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(thread.<span style="color:#8caaee">getState</span>()); <span style="color:#737994;font-style:italic">// 输出 NEW</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="runnable">RUNNABLE<a class="td-heading-self-link" href="#runnable" aria-label="Heading self-link"></a></h4>
<p>当前线程正在运行中。处于 RUNNABLE 状态的线程在 Java 虚拟机中运行，也有可能在等待 CPU 分配非IO资源。</p>
<p>Java 线程的<strong>RUNNABLE</strong>状态其实包括了操作系统线程的<strong>ready</strong>和<strong>running</strong>两个状态。</p>
<h4 id="block">BLOCK<a class="td-heading-self-link" href="#block" aria-label="Heading self-link"></a></h4>
<p>阻塞状态。处于 BLOCKED 状态的线程正等待锁（锁会在后面细讲）的释放以进入同步区。</p>
<h4 id="waiting">WAITING<a class="td-heading-self-link" href="#waiting" aria-label="Heading self-link"></a></h4>
<p>等待状态。处于等待状态的线程变成 RUNNABLE 状态需要其他线程唤醒。</p>
<ul>
<li><code>Object.wait()</code>：使当前线程处于等待状态直到另一个线程唤醒它</li>
<li><code>Thread.join()</code>：等待线程执行完毕，底层调用的是 Object 的 wait 方法,等待期间可以通过<code>Object.notify()</code>/<code>notifyAll()/Locksupport.unpark()</code>唤醒</li>
<li><code>LockSupport.park()</code>：除非获得调用许可，否则禁用当前线程进行线程调度</li>
</ul>
<h4 id="timed_waiting">TIMED_WAITING<a class="td-heading-self-link" href="#timed_waiting" aria-label="Heading self-link"></a></h4>
<p>超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。</p>
<p>调用如下方法会使线程进入超时等待状态：</p>
<ul>
<li>
<p><code>Thread.sleep(long millis)</code>：使当前线程睡眠指定时间</p>
</li>
<li>
<p><code>Object.wait(long timeout)</code>：线程休眠指定时间，等待期间可以通过<code>Object.notify()</code>/<code>notifyAll()/Locksupport.unpark()</code>唤醒</p>
</li>
<li>
<p><code>Thread.join(long millis)</code>：等待当前线程最多执行 millis 毫秒，如果 millis 为 0，则会一直执行</p>
</li>
<li>
<p><code>LockSupport.parkNanos(long nanos)</code>： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间</p>
</li>
<li>
<p><code>LockSupport.parkUntil(long deadline)</code>：同上，也是禁止线程进行调度指定时间；</p>
</li>
</ul>
<h4 id="terminated">TERMINATED<a class="td-heading-self-link" href="#terminated" aria-label="Heading self-link"></a></h4>
<p>终止状态</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205111919918.png" alt="image.png"></p>
<h4 id="调度方法">调度方法<a class="td-heading-self-link" href="#%e8%b0%83%e5%ba%a6%e6%96%b9%e6%b3%95" aria-label="Heading self-link"></a></h4>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205130951244.png" alt="image.png"></p>
<h5 id="等待与通知">等待与通知<a class="td-heading-self-link" href="#%e7%ad%89%e5%be%85%e4%b8%8e%e9%80%9a%e7%9f%a5" aria-label="Heading self-link"></a></h5>
<ol>
<li><code>Object.wait()</code>
调用<code>wait()</code>方法前线程必须持有对象的锁。</li>
</ol>
<p>线程调用<code>wait()</code>方法时，会释放当前的锁，直到有其他线程调用<code>notify()</code>/<code>notifyAll()</code>方法唤醒等待锁的线程。</p>
<p>需要注意的是，其他线程调用<code>notify()</code>方法只会唤醒单个等待锁的线程，如有有多个线程都在等待这个锁的话不一定会唤醒到之前调用<code>wait()</code>方法的线程。</p>
<p>同样，调用<code>notifyAll()</code>方法唤醒所有等待锁的线程之后，也不一定会马上把时间片分给刚才放弃锁的那个线程，具体要看系统的调度。</p>
<ol start="2">
<li><code>Object.wait(long)</code>/<code>Object.wait(long, int)</code></li>
</ol>
<p><code>wait(long)</code>方法使线程进入 TIMED_WAITING 状态。这里的<code>wait(long)</code>方法与无参方法 wait()相同的地方是，都可以通过其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法来唤醒。</p>
<p>不同的地方是，有参方法<code>wait(long)</code>就算其他线程不来唤醒它，经过指定时间 long 之后它会自动唤醒，拥有去争夺锁的资格。</p>
<ol start="3">
<li><code>Thread.join()</code></li>
</ol>
<p>调用<code>join()</code>方法，会一直等待这个线程执行完毕（转换为 TERMINATED 状态）。</p>
<h5 id="休眠">休眠<a class="td-heading-self-link" href="#%e4%bc%91%e7%9c%a0" aria-label="Heading self-link"></a></h5>
<ol>
<li><code>Thread.sleep(long)</code></li>
</ol>
<p>使当前线程睡眠指定时间。需要注意这里的“睡眠”只是暂时使线程停止执行，并不会释放锁。时间到后，线程会重新进入 RUNNABLE 状态。</p>
<h5 id="让出执行权">让出执行权<a class="td-heading-self-link" href="#%e8%ae%a9%e5%87%ba%e6%89%a7%e8%a1%8c%e6%9d%83" aria-label="Heading self-link"></a></h5>
<p><code>yield()</code>：Thread 类中的静态方法，当一个线程调用 yield 方法时，实际是在暗示线程调度器，当前线程请求让出自己的 CPU，但是线程调度器可能会“装看不见”忽略这个暗示。</p>
<h5 id="中断">中断<a class="td-heading-self-link" href="#%e4%b8%ad%e6%96%ad" aria-label="Heading self-link"></a></h5>
<p>中断（Interrupt）一个线程意味着在该线程完成任务之前停止其正在进行的一切，有效地中止其当前的操作。线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序。</p>
<p>那么，我们究竟应该如何停止线程呢？</p>
<ul>
<li>1、任务中一般都会有循环结构，只要用一个标记控制住循环，就可以结束任务。</li>
<li>2、如果线程处于了<code>冻结状态</code>，无法读取标记，此时可以使用<code>interrupt()</code>方法将线程<code>从冻结状态强制恢复到运行状态中</code>来，让线程具备CPU的执行资格。</li>
</ul>
<p><code>Thread.interrupt(long)</code></p>
<p>作用是中断阻塞的线程。将会设置线程中断为true，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。
线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为true）。
<em><strong>该方法只是改变中断状态，不会中断一个正在运行的线程。</strong></em></p>
<p>因为该方法并不执行中断, 只是指示线程中断因此用户需要监视线程的执行结果来判断下一步操作
比如抛出interruptedException的方法, 监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常, 从而指示阻塞线程退出阻塞</p>
<blockquote>
<p>引用:
<a href="https://www.cnblogs.com/myseries/p/10918819.html">博客园</a></p></blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-49dc4004f4087cdd8b87e117f3bd63ce">2.12 - 线程通信</h1>
    <div class="lead">线程之间传递信息有多种方式，比如说使用共享对象、wait() 和 notify() 方法、Exchanger 和 CompletableFuture。</div>
	<p><strong>线程通信</strong></p>
<blockquote>
<p>是一种机制，使得线程能够在执行时进行协作，通常用于解决某些线程需要等待其他线程完成任务的情况。它主要涉及线程之间的等待和通知机制，而不是同一临界区内的互斥访问。</p></blockquote>
<p>线程之间传递信息有多种方式，
比如说使用共享对象、<code>wait()</code> 和 <code>notify()</code> 方法、Exchanger 和 <code>CompletableFuture</code></p>
<h4 id="使用共享对象">使用共享对象<a class="td-heading-self-link" href="#%e4%bd%bf%e7%94%a8%e5%85%b1%e4%ba%ab%e5%af%b9%e8%b1%a1" aria-label="Heading self-link"></a></h4>
<p>多个线程同时访问和修改同一个对象, 从而实现信息传递</p>
<p>比如 <a href="/docs/basic/concurrent/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"><code>volatile</code></a>
<a href="/docs/basic/concurrent/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"><code>synchronized</code></a></p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8d4d929881d72feb82a7b32632a1f7ab">2.13 - 自旋锁与CLH锁</h1>
    <div class="lead">AQS 类的核心数据结构是一种名为 <code>Craig, Landin, and Hagersten locks</code>（下称 CLH 锁）的变体。</div>
	<p>在并发编程中，锁是一种常用的保证线程安全的方法。</p>
<p>Java 中常用的锁主要有两类，一种是关键字 <a href="/docs/basic/concurrent/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/">synchronized</a> ，被称为 Java 内置锁或监视器锁。</p>
<p>另一种就是在 J2SE 1.5版本之后的 java.util.concurrent包（下称j.u.c包）中的各类同步器</p>
<blockquote>
<p>包括 ReentrantLock（可重入锁），ReentrantReadWriteLock（可重入读写锁），Semaphore（信号量），CountDownLatch 等</p></blockquote>
<p>这些同步器都是基于 AbstractQueuedSynchronizer（下称 AQS）这个简单的框架来构建的</p>
<p>AQS 类的核心数据结构是一种名为 <code>Craig, Landin, and Hagersten locks</code>（下称 CLH 锁）的变体。</p>
<p>CLH锁是自旋锁的一种改良</p>
<h4 id="自旋锁">自旋锁<a class="td-heading-self-link" href="#%e8%87%aa%e6%97%8b%e9%94%81" aria-label="Heading self-link"></a></h4>
<p>自旋锁是互斥锁的一种实现, 用于保证线程间正确互斥</p>
<p>获取锁时，线程会对一个原子变量循环执行 <code>compareAndSet</code> 方法，直到该方法返回成功时即为成功获取锁</p>
<blockquote>
<p><code>compareAndSet</code> 方法底层由[[CAS(compare-and-swap)]]实现</p></blockquote>
<p>![[content/en/docs/Basic/Concurrent/Pasted image 20250203201648.png]]</p>
<p>自旋锁减少了线程上下文开销, 减缓了频繁的<a href="/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92/">线程挂起操作</a></p>
<p>但是该锁有很严重的缺点</p>
<ul>
<li>饥饿问题, 竞争激烈下, 可能有线程一直得不到锁</li>
<li>性能问题, 长时间自旋并且由于锁状态变更需要修改状态变量, 导致CPU的高速缓存在线程间频繁同步, 很消耗CPU
![[content/en/docs/Basic/Concurrent/Pasted image 20250203202833.png]]</li>
</ul>
<h4 id="clh锁">CLH锁<a class="td-heading-self-link" href="#clh%e9%94%81" aria-label="Heading self-link"></a></h4>
<blockquote>
<p><a href="/docs/basic/concurrent/volatile%E5%85%B3%E9%94%AE%E5%AD%97/">volatile关键字</a></p></blockquote>
<p>这是对自旋锁的改进版本
主要针对上述两个缺点做了改进</p>
<ul>
<li>饥饿问题, 将线程组织为队列, 先来先服务, 防止饥饿问题</li>
<li>去中心化, 不在使用单独的锁状态变量, 而是在每个线程内维护一个状态变量, 后继线程监视前继线程的状态即可
CLH 锁数据结构很简单，类似一个链表队列，所有请求获取锁的线程会排列在链表队列中，自旋访问队列中前一个节点的状态。</li>
</ul>
<p>![[content/en/docs/Basic/Concurrent/Pasted image 20250203203420.png]]</p>
<ol>
<li>
<p>CLH 锁初始化时会 Tail 会指向一个状态为 false 的空节点，如图1所示。</p>
</li>
<li>
<p>当 Thread 1（下称 T1）请求获取锁时，Tail 节点指向 T1 对应的节点，同时返回空节点。T1 检查到上一个节点状态为 false，就成功获取到锁，可以执行相应的逻辑了，如图2所示。</p>
</li>
<li>
<p>当 Thread 2（下称 T2）请求获取锁时，Tail 节点指向 T2 对应的节点，同时返回 T1 对应的节点。T2检查到上一个节点状态为 True，无法获取到锁，于是开始轮询上一个节点的状态，如图3所示。</p>
</li>
<li>
<p>当 T1 释放锁时，会将状态变量置为 False，如图4所示。</p>
</li>
<li>
<p>T2 轮询到检查到上一个节点状态变为 False，则获取锁成功，如图5所示。</p>
</li>
</ol>
<p>Java 源码</p>
<p>![[content/en/docs/Basic/Concurrent/Pasted image 20250203203732.png]]</p>
<blockquote>
<p>了解
<a href="/docs/basic/concurrent/threadlocal/">ThreadLocal</a></p></blockquote>
<p>利用 <code>ThreadLocal</code>  在独立线程内存维护node, node中只存储了该线程锁状态</p>
<ul>
<li>
<p>为什么锁要加 <code>volatile</code>
注意, 虽然锁状态只由宿主线程读取写入, 是单线程操作没必要保证可见性, 但是作为互斥锁需要保证 <a href="/docs/basic/concurrent/jmm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">happen-before 规则</a>成立, 这就意味着一个监视器锁的解锁发生在该监视器锁的后续锁定之前, 因此为了防止无法预测的重排序导致锁的状态在读取完成前被修改, 使用[[volatile关键字]]禁止重排序</p>
</li>
<li>
<p>为什么作为链表, node中不存储后继指针
很简单, 因为不需要, 作为先来先服务的队列, 没必要在乎后续节点的状态
只要前一个节点释放锁, 就立刻获取即可</p>
</li>
</ul>
<p>CLH 锁作为自旋锁的改进，有以下几个优点：</p>
<ol>
<li>
<p>性能优异，获取和释放锁开销小。释放锁的开销因为不需要使用 CAS 指令而降低了。</p>
</li>
<li>
<p>公平锁。先入队的线程会先得到锁。</p>
</li>
<li>
<p>实现简单，易于理解。</p>
</li>
</ol>
<p>当然，它也有两个缺点：第一是因为有自旋操作，当锁持有时间长时会带来较大的 CPU 开销。第二是基本的 CLH 锁功能单一，不改造不能支持复杂的功能。</p>
<blockquote>
<p>[!引用]
Quner技术沙龙
<a href="https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg">https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg</a></p></blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-b1e03d0071485913d948160ef5df36b9">2.14 - 获取线程执行结果</h1>
    <div class="lead">实际项目中，一个接口可能需要同时获取多种不同的数据，然后再汇总返回，如果是串行（按顺序依次执行每个任务）执行的话，接口的响应速度会非常慢。考虑到这些任务之间有大部分都是 无前后顺序关联 的，可以 并行执行 ，就比如说调用获取商品详情的时候，可以同时调用获取物流信息。通过并行执行多个任务的方式，接口的响应速度会得到大幅优化。</div>
	<blockquote>
<p>Java 1.5 提供了 Callable、Future、FutureTask，它们可以在任务执行完后得到执行结果, 可以实现业务之间的并发执行与返回</p></blockquote>
<p>在[[多线程入门]] 我们讲述了创建线程实现任务并发的 3 种方式，
直接继承 <code>Thread</code>
实现 <code>Runnable</code> 接口
实现 <code>Callable&lt;&gt;</code> 接口</p>
<p>前 2 种方式都有一个缺陷：在执行完任务之后无法获取执行结果。这对需要前置任务返回值的线程来说很重要</p>
<p>Java 1.5 提供了 Callable、Future、FutureTask，它们可以在任务执行完后得到执行结果</p>
<h4 id="callable">Callable&lt;&gt;<a class="td-heading-self-link" href="#callable" aria-label="Heading self-link"></a></h4>
<p><code>callable</code> 源码如下</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">interface</span> <span style="color:#e5c890">Callable</span><span style="color:#99d1db;font-weight:bold">&lt;</span>V<span style="color:#99d1db;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span>    V <span style="color:#8caaee">call</span>() <span style="color:#e78284">throws</span> Exception;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到 <code>call()</code> 方法返回值为泛型 V</p>
<blockquote>
<p>而 <code>Callable&lt;&gt;</code> 允许返回值的一个任务</p>
<p><code>Runnable</code> 接口代表一个可以由线程执行的任务, 实现 <code>Runnable</code> 而不是 <code>callable</code> 主要是线程池的兼容性考虑</p></blockquote>
<h4 id="future-异步计算结果接口"><code>Future</code> 异步计算结果接口<a class="td-heading-self-link" href="#future-%e5%bc%82%e6%ad%a5%e8%ae%a1%e7%ae%97%e7%bb%93%e6%9e%9c%e6%8e%a5%e5%8f%a3" aria-label="Heading self-link"></a></h4>
<p><code>Future</code> 表示异步计算的结果，提供了用于检查计算是否完成、等待计算完成、以及检索计算结果的方法。</p>
<blockquote>
<p><code>Future</code> 接口的设计目标是允许任务在一个线程中执行，并且可以返回执行结果或抛出异常</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">interface</span> <span style="color:#e5c890">Future</span><span style="color:#99d1db;font-weight:bold">&lt;</span>V<span style="color:#99d1db;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">boolean</span> <span style="color:#8caaee">cancel</span>(<span style="color:#e78284">boolean</span> mayInterruptIfRunning);
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">boolean</span> <span style="color:#8caaee">isCancelled</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">boolean</span> <span style="color:#8caaee">isDone</span>();
</span></span><span style="display:flex;"><span>    V <span style="color:#8caaee">get</span>() <span style="color:#e78284">throws</span> InterruptedException, ExecutionException;
</span></span><span style="display:flex;"><span>    V <span style="color:#8caaee">get</span>(<span style="color:#e78284">long</span> timeout, TimeUnit unit)
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">throws</span> InterruptedException, ExecutionException, TimeoutException;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>取消任务；</li>
<li>判断任务是否被取消;</li>
<li><code>get()</code>：等待任务完成，获取执行结果，如果任务取消会抛出异常</li>
<li><code>get(long timeout, TimeUnit unit)</code>：指定等待任务完成的时间，等待超时会抛出异常</li>
</ul>
<blockquote>
<p>注意, <code>get()</code> 方法会阻塞主进程, 一直阻塞到定时结束或者线程返回</p></blockquote>
<blockquote>
<p><code>Future</code> 也属于<a href="/docs/basic/concurrent/aqs/">同步器</a>的一种
因为类内部定义了线程的控制方法, 同步线程之间的状态
<code>Future</code> 的同步机制主要体现在它的 <code>get()</code> 方法：</p>
<ul>
<li>如果任务已完成，<code>get()</code> 立即返回结果。</li>
<li>如果任务尚未完成，<code>get()</code> 会将调用线程挂起，直到任务完成并且结果可用，才会唤醒线程并返回结果。</li>
</ul></blockquote>
<p><code>isDone()</code>：判断任务是否完成
<code>isCancelled()</code>：判断任务是否被取消
<code>cancel(boolean mayInterruptIfRunning)</code>：尝试取消此任务的执行，如果任务已经完成、已经取消或由于其他原因无法取消，则此尝试将失败
参数 <code>mayInterruptIfRunning</code> 表示是否允许取消正在执行却没有执行完毕的任务</p>
<h4 id="futuretask-异步计算接口实现类"><code>FutureTask</code> 异步计算接口实现类<a class="td-heading-self-link" href="#futuretask-%e5%bc%82%e6%ad%a5%e8%ae%a1%e7%ae%97%e6%8e%a5%e5%8f%a3%e5%ae%9e%e7%8e%b0%e7%b1%bb" aria-label="Heading self-link"></a></h4>
<p><code>FutureTask&lt;T&gt;</code> 是 <code>Future</code> 的一个实现类，同时也是 <code>Runnable</code>，可以直接用线程启动。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">FutureTask</span><span style="color:#99d1db;font-weight:bold">&lt;</span>V<span style="color:#99d1db;font-weight:bold">&gt;</span> <span style="color:#e78284">implements</span> RunnableFuture<span style="color:#99d1db;font-weight:bold">&lt;</span>V<span style="color:#99d1db;font-weight:bold">&gt;</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">interface</span> <span style="color:#e5c890">RunnableFuture</span><span style="color:#99d1db;font-weight:bold">&lt;</span>V<span style="color:#99d1db;font-weight:bold">&gt;</span> <span style="color:#e78284">extends</span> Runnable, Future<span style="color:#99d1db;font-weight:bold">&lt;</span>V<span style="color:#99d1db;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">void</span> <span style="color:#8caaee">run</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><code>FutureTask</code> 本身是对异步任务的封装，是 <code>Future</code> 的实现类, 实际的线程控制和结果计算是由其完成的</p>
<p><code>FutureTask</code> 通过 <code>run()</code> 方法实现了 <code>Callable</code> 的任务执行逻辑，因此兼容了 <code>Callable</code> 的行为, 但其本身是 <code>Runnable</code> 的任务</p></blockquote>
<p>使用例子</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#81c8be">import</span> <span style="color:#ef9f76">java.util.concurrent.*</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">FutureExample</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) <span style="color:#e78284">throws</span> Exception {
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 创建一个固定大小为3的线程池</span>
</span></span><span style="display:flex;"><span>        ExecutorService executorService <span style="color:#99d1db;font-weight:bold">=</span> Executors.<span style="color:#8caaee">newFixedThreadPool</span>(3);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 创建一个 Callable 数组，用于存储 5 个任务</span>
</span></span><span style="display:flex;"><span>        Callable<span style="color:#99d1db;font-weight:bold">&lt;</span>Integer<span style="color:#99d1db;font-weight:bold">&gt;[]</span> tasks <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Callable<span style="color:#99d1db;font-weight:bold">[</span>5<span style="color:#99d1db;font-weight:bold">]</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> 0; i <span style="color:#99d1db;font-weight:bold">&lt;</span> tasks.<span style="color:#8caaee">length</span>; i<span style="color:#99d1db;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#e78284">final</span> <span style="color:#e78284">int</span> index <span style="color:#99d1db;font-weight:bold">=</span> i;
</span></span><span style="display:flex;"><span>            tasks<span style="color:#99d1db;font-weight:bold">[</span>i<span style="color:#99d1db;font-weight:bold">]</span> <span style="color:#99d1db;font-weight:bold">=</span> () <span style="color:#99d1db;font-weight:bold">-&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#737994;font-style:italic">// 模拟任务执行时间，每个任务休眠 index+1 秒</span>
</span></span><span style="display:flex;"><span>                TimeUnit.<span style="color:#8caaee">SECONDS</span>.<span style="color:#8caaee">sleep</span>(index <span style="color:#99d1db;font-weight:bold">+</span> 1);
</span></span><span style="display:flex;"><span>                <span style="color:#737994;font-style:italic">// 任务返回 (index + 1) * 100</span>
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">return</span> (index <span style="color:#99d1db;font-weight:bold">+</span> 1) <span style="color:#99d1db;font-weight:bold">*</span> 100;
</span></span><span style="display:flex;"><span>            };
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 使用 Future 数组存储任务的执行结果</span>
</span></span><span style="display:flex;"><span>        Future<span style="color:#99d1db;font-weight:bold">&lt;</span>Integer<span style="color:#99d1db;font-weight:bold">&gt;[]</span> futures <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Future<span style="color:#99d1db;font-weight:bold">[</span>tasks.<span style="color:#8caaee">length</span><span style="color:#99d1db;font-weight:bold">]</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> 0; i <span style="color:#99d1db;font-weight:bold">&lt;</span> tasks.<span style="color:#8caaee">length</span>; i<span style="color:#99d1db;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">// 提交 Callable 任务到线程池，并返回 Future 对象</span>
</span></span><span style="display:flex;"><span>            futures<span style="color:#99d1db;font-weight:bold">[</span>i<span style="color:#99d1db;font-weight:bold">]</span> <span style="color:#99d1db;font-weight:bold">=</span> executorService.<span style="color:#8caaee">submit</span>(tasks<span style="color:#99d1db;font-weight:bold">[</span>i<span style="color:#99d1db;font-weight:bold">]</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 获取任务的执行结果</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> 0; i <span style="color:#99d1db;font-weight:bold">&lt;</span> futures.<span style="color:#8caaee">length</span>; i<span style="color:#99d1db;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">// 调用 get() 方法，会阻塞直到任务完成</span>
</span></span><span style="display:flex;"><span>            System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(<span style="color:#a6d189">&#34;Result of task &#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> (i <span style="color:#99d1db;font-weight:bold">+</span> 1) <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;: &#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> futures<span style="color:#99d1db;font-weight:bold">[</span>i<span style="color:#99d1db;font-weight:bold">]</span>.<span style="color:#8caaee">get</span>());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 关闭线程池，释放资源</span>
</span></span><span style="display:flex;"><span>        executorService.<span style="color:#8caaee">shutdown</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>了解
<a href="/docs/basic/concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"><code>executorService.submit()</code></a></p></blockquote>
<p>上述代码定义了一系列 <code>callable</code> 任务, 包装为<code>FutureTask</code>便于线程池使用,  调用 执行器 创建了线程池服务并要求线程池服务执行提交的 <code>FutureTask</code></p>
<blockquote>
<p><code>Future&lt;Integer&gt;[] futures = new Future[tasks.length]</code> 这里是泛型
实际绑定的是 <code>FutureTask</code></p></blockquote>
<h4 id="completeablefuture-任务编排实现类"><code>CompleteableFuture</code> 任务编排实现类<a class="td-heading-self-link" href="#completeablefuture-%e4%bb%bb%e5%8a%a1%e7%bc%96%e6%8e%92%e5%ae%9e%e7%8e%b0%e7%b1%bb" aria-label="Heading self-link"></a></h4>
<blockquote>
<p>A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html" title="interface in java.util.concurrent"><code>Future</code></a> that may be explicitly completed (setting its value and status), and may be used as a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html" title="interface in java.util.concurrent"><code>CompletionStage</code></a>, supporting dependent functions and actions that trigger upon its completion.</p>
<p><code>Future</code> 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合以及
使用<code>Future</code>获得异步执行结果时，要么调用阻塞方法<code>get()</code>，要么轮询看<code>isDone()</code>是否为<code>true</code>，这两种方法都不是很好，因为主线程也会被迫等待。</p></blockquote>
<blockquote>
<p>从Java 8开始引入了<code>CompletableFuture</code>，它针对<code>Future</code>做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p></blockquote>
<h4 id="如何使用">如何使用<a class="td-heading-self-link" href="#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8" aria-label="Heading self-link"></a></h4>
<p>创建一个<code>CompletableFuture</code>是通过<code>CompletableFuture.supplyAsync()</code>实现的，它需要一个实现了<code>Supplier</code>接口的对象：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">interface</span> <span style="color:#e5c890">Supplier</span><span style="color:#99d1db;font-weight:bold">&lt;</span>T<span style="color:#99d1db;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span>    T <span style="color:#8caaee">get</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>紧接着，<code>CompletableFuture</code>已经被提交给默认的线程池执行了，我们需要定义的是<code>CompletableFuture</code>完成时和异常时需要回调的实例。完成时，<code>CompletableFuture</code>会调用<code>Consumer</code>对象：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">interface</span> <span style="color:#e5c890">Consumer</span><span style="color:#99d1db;font-weight:bold">&lt;</span>T<span style="color:#99d1db;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">void</span> <span style="color:#8caaee">accept</span>(T t);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>异常时，<code>CompletableFuture</code>会调用<code>Function</code>对象：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">interface</span> <span style="color:#e5c890">Function</span><span style="color:#99d1db;font-weight:bold">&lt;</span>T, R<span style="color:#99d1db;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span>    R <span style="color:#8caaee">apply</span>(T t);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>示例:</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @program: alog  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @description: 实现类  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @author: hamhuo  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> **/</span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">Future</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) <span style="color:#e78284">throws</span> InterruptedException {  
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//创建异步执行的耗时任务, 获取一段文字  </span>
</span></span><span style="display:flex;"><span>        CompletableFuture<span style="color:#99d1db;font-weight:bold">&lt;</span>String<span style="color:#99d1db;font-weight:bold">&gt;</span> task <span style="color:#99d1db;font-weight:bold">=</span> CompletableFuture.<span style="color:#8caaee">supplyAsync</span>(<span style="color:#ca9ee6">new</span> fetchString());  
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//这时已经开始执行了  </span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//如果执行成功执行回调 </span>
</span></span><span style="display:flex;"><span>        task.<span style="color:#8caaee">thenAccept</span>((response) <span style="color:#99d1db;font-weight:bold">-&gt;</span> {  
</span></span><span style="display:flex;"><span>            System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(response <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34; human&#34;</span>);  
</span></span><span style="display:flex;"><span>        });  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//如果失败执行回调</span>
</span></span><span style="display:flex;"><span>        task.<span style="color:#8caaee">exceptionally</span>((e) <span style="color:#99d1db;font-weight:bold">-&gt;</span> {  
</span></span><span style="display:flex;"><span>            e.<span style="color:#8caaee">printStackTrace</span>();  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">null</span>;  
</span></span><span style="display:flex;"><span>        });  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//保证线程池正确关闭, 让主线程在任务完成后等一会  </span>
</span></span><span style="display:flex;"><span>        task.<span style="color:#8caaee">join</span>();  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">fetchString</span> <span style="color:#e78284">implements</span> Supplier<span style="color:#99d1db;font-weight:bold">&lt;</span>String<span style="color:#99d1db;font-weight:bold">&gt;</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#8caaee;font-weight:bold">@Override</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">public</span>  String <span style="color:#8caaee">get</span>() {  
</span></span><span style="display:flex;"><span>            String message <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#34;hello from star&#34;</span>;  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">try</span>{  
</span></span><span style="display:flex;"><span>                Thread.<span style="color:#8caaee">sleep</span>(2000);  
</span></span><span style="display:flex;"><span>                message <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#34;re:: correct&#34;</span>;  
</span></span><span style="display:flex;"><span>            } <span style="color:#ca9ee6">catch</span> (InterruptedException e) {  
</span></span><span style="display:flex;"><span>                Thread.<span style="color:#8caaee">currentThread</span>().<span style="color:#8caaee">interrupt</span>();  
</span></span><span style="display:flex;"><span>            }  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (message.<span style="color:#8caaee">equals</span>(<span style="color:#a6d189">&#34;hello from star&#34;</span>)) {  
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">throw</span> <span style="color:#ca9ee6">new</span> RuntimeException(<span style="color:#a6d189">&#34;Earth&#34;</span>);  
</span></span><span style="display:flex;"><span>            }  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">return</span> message;  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>thenAcccept()</code> 不会阻塞线程, 是非阻塞的回调方法, 需要主线程手动等待完成</p>
<blockquote>
<p>引用:
<a href="https://liaoxuefeng.com/books/java/threading/completable-future/index.html">https://liaoxuefeng.com/books/java/threading/completable-future/index.html</a>
<a href="https://javaguide.cn/java/concurrent/completablefuture-intro.html#future-%E4%BB%8B%E7%BB%8D">https://javaguide.cn/java/concurrent/completablefuture-intro.html#future-%E4%BB%8B%E7%BB%8D</a></p></blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1c1b1847caa2841a66eb981677a626fd">2.15 - 通信工具类</h1>
    <div class="lead">JDK 中提供了一些并发编程中常用的通信工具类以供我们开发者使用。它们都在 JUC 包下。先总体概括一下都有哪些工具类，它们有什么作用，然后再分别介绍它们的主要使用方法和原理。</div>
	<p>JDK 中提供了一些并发编程中常用的通信工具类以供我们开发者使用</p>
<table>
  <thead>
      <tr>
          <th>类</th>
          <th>作用</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Semaphore</td>
          <td>限制线程的数量</td>
      </tr>
      <tr>
          <td>Exchanger</td>
          <td>两个线程交换数据</td>
      </tr>
      <tr>
          <td>CountDownLatch</td>
          <td>线程等待直到计数器减为 0 时开始工作</td>
      </tr>
      <tr>
          <td>CyclicBarrier</td>
          <td>作用跟 CountDownLatch 类似，但是可以重复使用</td>
      </tr>
      <tr>
          <td>Phaser</td>
          <td>增强的 CyclicBarrier</td>
      </tr>
  </tbody>
</table>
<h3 id="countdownlatch"><code>CountDownLatch</code><a class="td-heading-self-link" href="#countdownlatch" aria-label="Heading self-link"></a></h3>
<p>一个减法计数器, 基于信号量</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">class</span> <span style="color:#e5c890">CountTest</span>{
</span></span><span style="display:flex;"><span>	  <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) <span style="color:#e78284">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>		<span style="color:#737994;font-style:italic">//设置一个尺寸为10的信号量</span>
</span></span><span style="display:flex;"><span>		 <span style="color:#737994;font-style:italic">//总数是10，必须要执行任务的时候，再使用</span>
</span></span><span style="display:flex;"><span>        CountDownLatch countDownLatch <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> CountDownLatch(10);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span>(<span style="color:#e78284">int</span> i<span style="color:#99d1db;font-weight:bold">=</span>0; i<span style="color:#99d1db;font-weight:bold">&lt;</span>10; i<span style="color:#99d1db;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">new</span> Thread(()<span style="color:#99d1db;font-weight:bold">-&gt;</span>{
</span></span><span style="display:flex;"><span>                System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(Thread.<span style="color:#8caaee">currentThread</span>().<span style="color:#8caaee">getName</span>()<span style="color:#99d1db;font-weight:bold">+</span><span style="color:#a6d189">&#34; Go out&#34;</span>);
</span></span><span style="display:flex;"><span>                countDownLatch.<span style="color:#8caaee">countDown</span>(); <span style="color:#737994;font-style:italic">//数量减1</span>
</span></span><span style="display:flex;"><span>            },String.<span style="color:#8caaee">valueOf</span>(i)).<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        countDownLatch.<span style="color:#8caaee">await</span>(); <span style="color:#737994;font-style:italic">//等待计数器归零，再向下执行</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(<span style="color:#a6d189">&#34;Hello world!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>两个方法</p>
<ul>
<li><code>countDown()</code> 调用后计数减一</li>
<li><code>await()</code> 使线程挂起</li>
</ul>
<h4 id="exchanger"><code>Exchanger</code><a class="td-heading-self-link" href="#exchanger" aria-label="Heading self-link"></a></h4>
<blockquote>
<p>A synchronization point at which threads can pair and swap elements within pairs. Each thread presents some object on entry to the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Exchanger.html#exchange-V-"><code>exchange</code></a> method, matches with a partner thread, and receives its partner&rsquo;s object on return. An Exchanger may be viewed as a bidirectional form of a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/SynchronousQueue.html" title="class in java.util.concurrent"><code>SynchronousQueue</code></a>. Exchangers may be useful in applications such as genetic algorithms and pipeline designs.</p></blockquote>
<ul>
<li>此类提供对外的操作是同步的；</li>
<li>用于成对出现的线程之间交换数据；</li>
<li>可以视作双向的同步队列；</li>
<li>可应用于基因算法、流水线设计等场景。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">class</span> <span style="color:#e5c890">FillAndEmpty</span> {  
</span></span><span style="display:flex;"><span>    Exchanger<span style="color:#99d1db;font-weight:bold">&lt;</span>DataBuffer<span style="color:#99d1db;font-weight:bold">&gt;</span> exchanger <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Exchanger<span style="color:#99d1db;font-weight:bold">&lt;</span>DataBuffer<span style="color:#99d1db;font-weight:bold">&gt;</span>();  
</span></span><span style="display:flex;"><span>    DataBuffer initialEmptyBuffer <span style="color:#99d1db;font-weight:bold">=</span> ... 
</span></span><span style="display:flex;"><span>    DataBuffer initialFullBuffer <span style="color:#99d1db;font-weight:bold">=</span> ...  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">class</span> <span style="color:#e5c890">FillingLoop</span> <span style="color:#e78284">implements</span> Runnable {  
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">run</span>() {  
</span></span><span style="display:flex;"><span>	        <span style="color:#737994;font-style:italic">//初始化缓存</span>
</span></span><span style="display:flex;"><span>            DataBuffer currentBuffer <span style="color:#99d1db;font-weight:bold">=</span> initialEmptyBuffer;  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">try</span> {  
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">while</span> (currentBuffer <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {  
</span></span><span style="display:flex;"><span>                    addToBuffer(currentBuffer);  
</span></span><span style="display:flex;"><span>                    <span style="color:#ca9ee6">if</span> (currentBuffer.<span style="color:#8caaee">isFull</span>()) 
</span></span><span style="display:flex;"><span>	                    <span style="color:#737994;font-style:italic">//如果缓存满, 需要交换, 在这里等 </span>
</span></span><span style="display:flex;"><span>                        currentBuffer <span style="color:#99d1db;font-weight:bold">=</span> exchanger.<span style="color:#8caaee">exchange</span>(currentBuffer);  
</span></span><span style="display:flex;"><span>                }  
</span></span><span style="display:flex;"><span>            } <span style="color:#ca9ee6">catch</span> (InterruptedException ex) { ... handle ... }  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">class</span> <span style="color:#e5c890">EmptyingLoop</span> <span style="color:#e78284">implements</span> Runnable {  
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">run</span>() {  
</span></span><span style="display:flex;"><span>            DataBuffer currentBuffer <span style="color:#99d1db;font-weight:bold">=</span> initialFullBuffer;  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">try</span> {  
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">while</span> (currentBuffer <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {  
</span></span><span style="display:flex;"><span>                    takeFromBuffer(currentBuffer);  
</span></span><span style="display:flex;"><span>                    <span style="color:#ca9ee6">if</span> (currentBuffer.<span style="color:#8caaee">isEmpty</span>()) 
</span></span><span style="display:flex;"><span>	                    <span style="color:#737994;font-style:italic">//如果缓存空, 需要交换, 在这里等 </span>
</span></span><span style="display:flex;"><span>                        currentBuffer <span style="color:#99d1db;font-weight:bold">=</span> exchanger.<span style="color:#8caaee">exchange</span>(currentBuffer);  
</span></span><span style="display:flex;"><span>                }  
</span></span><span style="display:flex;"><span>            } <span style="color:#ca9ee6">catch</span> (InterruptedException ex) { ... handle ...}  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">void</span> <span style="color:#8caaee">start</span>() {  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">new</span> Thread(<span style="color:#ca9ee6">new</span> FillingLoop()).<span style="color:#8caaee">start</span>();  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">new</span> Thread(<span style="color:#ca9ee6">new</span> EmptyingLoop()).<span style="color:#8caaee">start</span>();  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当一个线程调用 exchange 方法后，会处于阻塞状态，只有当另一个线程也调用了 exchange 方法，它才会继续执行。</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250209090451142.png" alt="image.png"></p>
<p>内部使用 <code>CAS</code> 检查, 使用<code>park/unpark</code> 做状态转换</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-796c9ebe903c9d7316b36e64bf412389">2.16 - </h1>
    
	
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6fcba84597d7e94e37305c484c79e11a">2.17 - </h1>
    
	
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-b75dc17122f7fa6015c2c9c6f785bfb9">2.18 - </h1>
    
	<p>#设计模式</p>
<blockquote>
<p>[!NOTE]
模板方法
定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。
模版方法定义了一个算法的步骤，并且允许子类为一个或多个步骤提供实现。</p></blockquote>
<p>算法就是实现某个功能的步骤
我们以工作为例
工作这个过程分为 打卡, 开机, 打代码, 提交关机, 走人
我们先来定义模板类</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">abstract</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">Worker</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">protected</span> String name;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#8caaee">Worker</span>(String name)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#ca9ee6">this</span>.<span style="color:#8caaee">name</span> <span style="color:#99d1db;font-weight:bold">=</span> name;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * 记录一天的工作
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#e78284">final</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">workOneDay</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(<span style="color:#a6d189">&#34;-----------------work start ---------------&#34;</span>);
</span></span><span style="display:flex;"><span>		enterCompany();
</span></span><span style="display:flex;"><span>		computerOn();
</span></span><span style="display:flex;"><span>		work();
</span></span><span style="display:flex;"><span>		computerOff();
</span></span><span style="display:flex;"><span>		exitCompany();
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(<span style="color:#a6d189">&#34;-----------------work end ---------------&#34;</span>);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * 打代码
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#e78284">abstract</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">work</span>();
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * 关闭电脑
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">private</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">computerOff</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(name <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;关闭电脑&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * 打开电脑
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">private</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">computerOn</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(name <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;打开电脑&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * 进入公司
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">enterCompany</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(name <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;进入公司&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * 离开公司
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">exitCompany</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(name <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;离开公司&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中大部分方法都实现了(演示方便, 有返回值就行)
唯独打代码没实现, 那么这个方法延迟到子类实现, 我们看下孩子们是如何实现的
劳大:</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">ITWorker</span> <span style="color:#e78284">extends</span> Worker
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#8caaee">ITWorker</span>(String name)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#e78284">super</span>(name);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#8caaee;font-weight:bold">@Override</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">work</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(name <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;孩子们快跑, 我在finally返回了&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>皮衣黄</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">HRWorker</span> <span style="color:#e78284">extends</span> Worker
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#8caaee">HRWorker</span>(String name)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#e78284">super</span>(name);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#8caaee;font-weight:bold">@Override</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">work</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(name <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;孩子们快跑, deepseek跳过了CUDA&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>马圣</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">QAWorker</span> <span style="color:#e78284">extends</span> Worker
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#8caaee">QAWorker</span>(String name)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#e78284">super</span>(name);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#8caaee;font-weight:bold">@Override</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">work</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(name <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;孩子们快跑, DOGE要开人啦&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这样所有子类只需完成小部分逻辑即可实现功能</p>
<p>![[content/en/docs/Basic/Concurrent/Pasted image 20250203230102.png]]</p>
<h4 id="钩子">钩子<a class="td-heading-self-link" href="#%e9%92%a9%e5%ad%90" aria-label="Heading self-link"></a></h4>
<blockquote>
<p>[!NOTE]
钩子的由来：</p>
<ul>
<li><strong>“钩子”</strong> 这个名字形象地表达了方法在模板方法模式中的角色：它就像一个钩子，可以被子类“挂”上去（重写），也可以“留空”。</li>
<li>子类重写钩子方法，就相当于“挂”上去了，它能改变或增加一些行为；如果不重写钩子方法，就相当于“没挂”——这时模板方法会使用父类提供的默认实现。</li>
<li>可以当成开关理解</li>
</ul></blockquote>
<p>父类可以留几个钩子
比如是否打印时间</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">boolean</span> <span style="color:#8caaee">isNeedPrintDate</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">false</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * 离开公司
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">exitCompany</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#ca9ee6">if</span> (isNeedPrintDate())
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">print</span>(<span style="color:#ca9ee6">new</span> Date().<span style="color:#8caaee">toLocaleString</span>()<span style="color:#99d1db;font-weight:bold">+</span><span style="color:#a6d189">&#34;--&gt;&#34;</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(name <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;离开公司&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>子类重写钩子, 就可以选择算法分支了, 也就是是否打印时间</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>	<span style="color:#8caaee;font-weight:bold">@Override</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#e78284">boolean</span> <span style="color:#8caaee">isNeedPrintDate</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">true</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span></code></pre></div><p>总结:
其实模板方法就是把一类操作提取出统一的逻辑
将不同的参数, 细节等延迟到子类实现</p>
<blockquote>
<p>[!引用]
<a href="https://blog.csdn.net/lmj623565791/article/details/26276093">https://blog.csdn.net/lmj623565791/article/details/26276093</a></p></blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-3289dc0cf77ebdd3067bf799eab51ff2">2.19 - </h1>
    
	
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-0d0829b705f81a8c8a6adb4575b07ebf">2.20 - </h1>
    
	
</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-0faba675a466ec9ffd5f0701d9db5314">3 - Java集合框架</h1>
    
	<p>内容来源:</p>
<ul>
<li>沉默王二 GitHub 上开源的知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">Java 进阶之路</a>》</li>
<li><a href="https://javaguide.cn/java/concurrent/">JavaGuide</a></li>
<li><a href="https://www.geeksforgeeks.org/">Geeksforgeeks</a></li>
<li><a href="https://www.runoob.com/">菜鸟教程</a></li>
</ul>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-c01a54606858a092e8d1f35c7e73f3ce">3.1 - LinkedList</h1>
    <div class="lead"><code>LinkedList</code> 是基于双向链表的数据结构, 实现队列和列表接口的所有方法, 允许存放任意类型元素</div>
	<h4 id="什么是链表">什么是链表<a class="td-heading-self-link" href="#%e4%bb%80%e4%b9%88%e6%98%af%e9%93%be%e8%a1%a8" aria-label="Heading self-link"></a></h4>
<p>链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。</p>
<p>链表可分为单向链表和双向链表。</p>
<p>一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。</p>
<p>单向链表</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250207180458615.png" alt="image.png"></p>
<p>双向链表</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250207180510867.png" alt="image.png"></p>
<p>Doubly-linked list implementation of the <code>List</code> and <code>Deque</code> interfaces. Implements all optional list operations, and permits all elements (including <code>null</code>).
<code>LinkedList</code> 是基于双向链表的数据结构, 实现队列和列表接口的所有方法, 允许存放任意类型元素</p>
<h4 id="基础使用">基础使用<a class="td-heading-self-link" href="#%e5%9f%ba%e7%a1%80%e4%bd%bf%e7%94%a8" aria-label="Heading self-link"></a></h4>
<blockquote>
<p><strong>以下情况使用 LinkedList :</strong></p>
<ul>
<li>你需要通过循环迭代来访问列表中的某些元素。</li>
<li>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</li>
</ul></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">LinkedList</span><span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">extends</span> AbstractSequentialList<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">implements</span> List<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span>, Deque<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span>, Cloneable, Serializable
</span></span></code></pre></div><p>使用之前:</p>
<ul>
<li><code>LinkedList</code> 类位于 <code>java.util</code> 包中，使用前需要引入它</li>
<li>链表实现了 <code>Queue</code> 接口, 可以作为队列使用</li>
<li>链表实现了 <code>List</code> 接口, 可进行列表的相关操作</li>
<li>链表添加标签 <code>Cloneable</code> 允许克隆</li>
<li>链表实现 <code>Serializable</code> 可以序列化</li>
<li>链表线程不安全, 依赖外部同步</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250207181217867.png" alt="image.png"></p>
<p>新建实例</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// 引入 LinkedList 类</span>
</span></span><span style="display:flex;"><span><span style="color:#81c8be">import</span> <span style="color:#ef9f76">java.util.LinkedList</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">RunoobTest</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) {
</span></span><span style="display:flex;"><span>        LinkedList<span style="color:#99d1db;font-weight:bold">&lt;</span>String<span style="color:#99d1db;font-weight:bold">&gt;</span> sites <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> LinkedList<span style="color:#99d1db;font-weight:bold">&lt;</span>String<span style="color:#99d1db;font-weight:bold">&gt;</span>();
</span></span><span style="display:flex;"><span>        sites.<span style="color:#8caaee">add</span>(<span style="color:#a6d189">&#34;Google&#34;</span>);
</span></span><span style="display:flex;"><span>        sites.<span style="color:#8caaee">add</span>(<span style="color:#a6d189">&#34;Runoob&#34;</span>);
</span></span><span style="display:flex;"><span>        sites.<span style="color:#8caaee">add</span>(<span style="color:#a6d189">&#34;Taobao&#34;</span>);
</span></span><span style="display:flex;"><span>        sites.<span style="color:#8caaee">add</span>(<span style="color:#a6d189">&#34;Weibo&#34;</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(sites);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>开头添加元素</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>sites.<span style="color:#8caaee">addFirst</span>()
</span></span></code></pre></div><p>结尾添加元素</p>
<blockquote>
<p>注意
默认的 <code>add()</code> 方法就是在结尾添加</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>sites.<span style="color:#8caaee">addLast</span>()
</span></span></code></pre></div><p>开头删除元素</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>sites.<span style="color:#8caaee">removedFirst</span>()
</span></span></code></pre></div><p>结尾删除元素</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>sites.<span style="color:#8caaee">removedLast</span>()
</span></span></code></pre></div><p>获取元素</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>sites.<span style="color:#8caaee">getFirst</span>()
</span></span><span style="display:flex;"><span>sites.<span style="color:#8caaee">getLast</span>()
</span></span></code></pre></div><p>获取链表长度</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>sites.<span style="color:#8caaee">size</span>()
</span></span></code></pre></div><hr>
<h4 id="进阶部分">进阶部分<a class="td-heading-self-link" href="#%e8%bf%9b%e9%98%b6%e9%83%a8%e5%88%86" aria-label="Heading self-link"></a></h4>
<h4 id="为什么需要链表">为什么需要链表?<a class="td-heading-self-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e9%93%be%e8%a1%a8" aria-label="Heading self-link"></a></h4>
<p>和链表定位类似的是 <code>ArrayList</code> 基于动态数组的列表</p>
<p>相比之下链表有以下优点</p>
<ol>
<li>链表不定长, 内存无需连续</li>
<li>头尾插入快</li>
</ol>
<p>链表大致分为三种</p>
<ul>
<li>“单向链表”，我只有一个后指针，指向下一个数据；</li>
<li>“双向链表”，我有两个指针，后指针指向下一个数据，前指针指向上一个数据。</li>
<li>“二叉树”，把后指针去掉，换成左右指针。</li>
</ul>
<h4 id="linkedlist-解析"><code>LinkedList</code> 解析<a class="td-heading-self-link" href="#linkedlist-%e8%a7%a3%e6%9e%90" aria-label="Heading self-link"></a></h4>
<p>链表的核心是 <code>Node</code> 这是一个内部静态类, 定义存储数据单位的结构</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * 链表中的节点类。
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">Node</span><span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span>    E item; <span style="color:#737994;font-style:italic">// 节点中存储的元素</span>
</span></span><span style="display:flex;"><span>    Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> next; <span style="color:#737994;font-style:italic">// 指向下一个节点的指针</span>
</span></span><span style="display:flex;"><span>    Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> prev; <span style="color:#737994;font-style:italic">// 指向上一个节点的指针</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     * 构造一个新的节点。
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     *
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     * @param prev 前一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     * @param element 节点中要存储的元素
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     * @param next 后一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     */</span>
</span></span><span style="display:flex;"><span>    Node(Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> prev, E element, Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> next) {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">this</span>.<span style="color:#8caaee">item</span> <span style="color:#99d1db;font-weight:bold">=</span> element; <span style="color:#737994;font-style:italic">// 存储元素</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">this</span>.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> next; <span style="color:#737994;font-style:italic">// 设置下一个节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">this</span>.<span style="color:#8caaee">prev</span> <span style="color:#99d1db;font-weight:bold">=</span> prev; <span style="color:#737994;font-style:italic">// 设置上一个节点</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><code>LinkedList</code> 内部使用双向链表实现
<img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250207184211029.png" alt="image.png"></p></blockquote>
<h4 id="添加节点">添加节点<a class="td-heading-self-link" href="#%e6%b7%bb%e5%8a%a0%e8%8a%82%e7%82%b9" aria-label="Heading self-link"></a></h4>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * 将指定的元素添加到列表的尾部。
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @param e 要添加到列表的元素
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @return 始终为 true（根据 Java 集合框架规范）
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">boolean</span> <span style="color:#8caaee">add</span>(E e) {
</span></span><span style="display:flex;"><span>    linkLast(e); <span style="color:#737994;font-style:italic">// 在列表的尾部添加元素</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">true</span>; <span style="color:#737994;font-style:italic">// 添加元素成功，返回 true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>//todo</p>
<h4 id="删除节点">删除节点<a class="td-heading-self-link" href="#%e5%88%a0%e9%99%a4%e8%8a%82%e7%82%b9" aria-label="Heading self-link"></a></h4>
<ul>
<li><code>remove()</code>：删除第一个节点</li>
<li><code>remove(int)</code>：删除指定位置的节点</li>
<li><code>remove(Object)</code>：删除指定元素的节点</li>
<li><code>removeFirst()</code>：删除第一个节点</li>
<li><code>removeLast()</code>：删除最后一个节点</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * 删除指定位置上的元素。
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @param index 要删除的元素的索引
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @return 从列表中删除的元素
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @throws IndexOutOfBoundsException 如果索引越界（index &amp;lt; 0 || index &amp;gt;= size()）
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> E <span style="color:#8caaee">remove</span>(<span style="color:#e78284">int</span> index) {
</span></span><span style="display:flex;"><span>    checkElementIndex(index); <span style="color:#737994;font-style:italic">// 检查索引是否越界</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> unlink(node(index)); <span style="color:#737994;font-style:italic">// 删除指定位置的节点，并返回节点的元素</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * 获取链表中指定位置的节点。
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @param index 节点的位置（从 0 开始）
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @return 指定位置的节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index &gt;= size()）
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span>Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> <span style="color:#8caaee">node</span>(<span style="color:#e78284">int</span> index) {
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (index <span style="color:#99d1db;font-weight:bold">&lt;</span> (size <span style="color:#99d1db;font-weight:bold">&gt;&gt;</span> 1)) { <span style="color:#737994;font-style:italic">// 如果索引在链表的前半部分</span>
</span></span><span style="display:flex;"><span>        Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> x <span style="color:#99d1db;font-weight:bold">=</span> first;
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> 0; i <span style="color:#99d1db;font-weight:bold">&lt;</span> index; i<span style="color:#99d1db;font-weight:bold">++</span>) <span style="color:#737994;font-style:italic">// 从头节点开始向后遍历链表，直到找到指定位置的节点</span>
</span></span><span style="display:flex;"><span>            x <span style="color:#99d1db;font-weight:bold">=</span> x.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> x; <span style="color:#737994;font-style:italic">// 返回指定位置的节点</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#ca9ee6">else</span> { <span style="color:#737994;font-style:italic">// 如果索引在链表的后半部分</span>
</span></span><span style="display:flex;"><span>        Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> x <span style="color:#99d1db;font-weight:bold">=</span> last;
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> size <span style="color:#99d1db;font-weight:bold">-</span> 1; i <span style="color:#99d1db;font-weight:bold">&gt;</span> index; i<span style="color:#99d1db;font-weight:bold">--</span>) <span style="color:#737994;font-style:italic">// 从尾节点开始向前遍历链表，直到找到指定位置的节点</span>
</span></span><span style="display:flex;"><span>            x <span style="color:#99d1db;font-weight:bold">=</span> x.<span style="color:#8caaee">prev</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> x; <span style="color:#737994;font-style:italic">// 返回指定位置的节点</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>内部调用的是 <code>unlink()</code> 方法</p>
<p>大致思路是</p>
<p>删除一共涉及三个节点, 前驱节点, 删除节点, 后驱节点
这是因为一旦节点被删除, 链表就断掉了, 需要重新连接前驱和后驱
拿到这三个节点, 首先进行特殊情况判断</p>
<ul>
<li>删除的是否为头结点
如果是, 就把后驱节点设置为头结点
如果不是, 前驱节点连接后驱节点, 删除节点的前驱置空</li>
<li>删除的是否为尾节点
如果是, 就把前驱节点设置为尾节点
如果不是, 后驱节点连接前驱节点, 完成双向链接, 删除节点的后驱置空</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * 从链表中删除指定节点。
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @param x 要删除的节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @return 从链表中删除的节点的元素
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span>E <span style="color:#8caaee">unlink</span>(Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> x) {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">final</span> E element <span style="color:#99d1db;font-weight:bold">=</span> x.<span style="color:#8caaee">item</span>; <span style="color:#737994;font-style:italic">// 获取要删除节点的元素</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">final</span> Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> next <span style="color:#99d1db;font-weight:bold">=</span> x.<span style="color:#8caaee">next</span>; <span style="color:#737994;font-style:italic">// 获取要删除节点的下一个节点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">final</span> Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> prev <span style="color:#99d1db;font-weight:bold">=</span> x.<span style="color:#8caaee">prev</span>; <span style="color:#737994;font-style:italic">// 获取要删除节点的上一个节点</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (prev <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span>) { <span style="color:#737994;font-style:italic">// 如果要删除节点是第一个节点</span>
</span></span><span style="display:flex;"><span>        first <span style="color:#99d1db;font-weight:bold">=</span> next; <span style="color:#737994;font-style:italic">// 将链表的头节点设置为要删除节点的下一个节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//在这种情况下，不能执行 prev.next = next，因为 prev 是 null，会导致空指针异常</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#ca9ee6">else</span> {
</span></span><span style="display:flex;"><span>        prev.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> next; <span style="color:#737994;font-style:italic">// 将要删除节点的上一个节点指向要删除节点的下一个节点</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        x.<span style="color:#8caaee">prev</span> <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ef9f76">null</span>; <span style="color:#737994;font-style:italic">// 将要删除节点的上一个节点设置为空</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (next <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span>) { <span style="color:#737994;font-style:italic">// 如果要删除节点是最后一个节点</span>
</span></span><span style="display:flex;"><span>        last <span style="color:#99d1db;font-weight:bold">=</span> prev; <span style="color:#737994;font-style:italic">// 将链表的尾节点设置为要删除节点的上一个节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//在这种情况下，不能执行 next.prev = prev，因为 next 是 null，会导致空指针异常</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#ca9ee6">else</span> {
</span></span><span style="display:flex;"><span>        next.<span style="color:#8caaee">prev</span> <span style="color:#99d1db;font-weight:bold">=</span> prev; <span style="color:#737994;font-style:italic">// 将要删除节点的下一个节点指向要删除节点的上一个节点   </span>
</span></span><span style="display:flex;"><span>        x.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ef9f76">null</span>; <span style="color:#737994;font-style:italic">// 将要删除节点的下一个节点设置为空</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    x.<span style="color:#8caaee">item</span> <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ef9f76">null</span>; <span style="color:#737994;font-style:italic">// 将要删除节点的元素设置为空</span>
</span></span><span style="display:flex;"><span>    size<span style="color:#99d1db;font-weight:bold">--</span>; <span style="color:#737994;font-style:italic">// 减少链表的元素个数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> element; <span style="color:#737994;font-style:italic">// 返回被删除节点的元素</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>remove(Object)</code> 内部也调用了 unlink 方法，只不过在此之前要先找到元素所在的节点：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * 从链表中删除指定元素。
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @param o 要从链表中删除的元素
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @return 如果链表包含指定元素，则返回 true；否则返回 false
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">boolean</span> <span style="color:#8caaee">remove</span>(Object o) {
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (o <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span>) { <span style="color:#737994;font-style:italic">// 如果要删除的元素为 null</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> x <span style="color:#99d1db;font-weight:bold">=</span> first; x <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>; x <span style="color:#99d1db;font-weight:bold">=</span> x.<span style="color:#8caaee">next</span>) { <span style="color:#737994;font-style:italic">// 遍历链表</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (x.<span style="color:#8caaee">item</span> <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span>) { <span style="color:#737994;font-style:italic">// 如果节点的元素为 null</span>
</span></span><span style="display:flex;"><span>                unlink(x); <span style="color:#737994;font-style:italic">// 删除节点</span>
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">true</span>; <span style="color:#737994;font-style:italic">// 返回 true 表示删除成功</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#ca9ee6">else</span> { <span style="color:#737994;font-style:italic">// 如果要删除的元素不为 null</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> x <span style="color:#99d1db;font-weight:bold">=</span> first; x <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>; x <span style="color:#99d1db;font-weight:bold">=</span> x.<span style="color:#8caaee">next</span>) { <span style="color:#737994;font-style:italic">// 遍历链表</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (o.<span style="color:#8caaee">equals</span>(x.<span style="color:#8caaee">item</span>)) { <span style="color:#737994;font-style:italic">// 如果节点的元素等于要删除的元素</span>
</span></span><span style="display:flex;"><span>                unlink(x); <span style="color:#737994;font-style:italic">// 删除节点</span>
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">true</span>; <span style="color:#737994;font-style:italic">// 返回 true 表示删除成功</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">false</span>; <span style="color:#737994;font-style:italic">// 如果链表中不包含要删除的元素，则返回 false 表示删除失败</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-826ec4829c43a4d0a4b133ee3b1e9fde">3.2 - </h1>
    
	
</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-015ab6060789604cfb2a274bcd5125f6">4 - JVM</h1>
    
	<p>内容来源:</p>
<ul>
<li>沉默王二 GitHub 上开源的知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">Java 进阶之路</a>》</li>
<li><a href="https://javaguide.cn/java/concurrent/">JavaGuide</a></li>
<li><a href="https://www.geeksforgeeks.org/">Geeksforgeeks</a></li>
<li><a href="https://www.runoob.com/">菜鸟教程</a></li>
</ul>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-fd676f9ad424bbf69b4af55a1c55d98b">4.1 - Java的四种引用</h1>
    <div class="lead">强引用不会被垃圾回收，除非手动弱化；软引用在内存不足时回收，可用于内存敏感的高速缓存；弱引用不管内存是否充足，垃圾回收时都会回收；虚引用不决定对象生命周期，主要用于跟踪对象回收。</div>
	<p>强引用
A a=new A(); 此时引用a强引用对象A；不会被GC
即使OOM也不会回收对象, 而是抛异常</p>
<p>弱引用
<strong>WeakReference.java</strong> 是 Java1.2提供的一个类
当GC发现弱引用后会直接回收该对象</p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-06ecac212db9f5d9be3e85ff8516e084">5 - MySQL</h1>
    <div class="lead">关系性数据库, 程序员的入门教程</div>
	<p>内容来源:</p>
<ul>
<li>沉默王二 GitHub 上开源的知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">Java 进阶之路</a>》</li>
</ul>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-e03b3b407ae2c157a75929111db4a065">5.1 - MySQL字符集和比较规则</h1>
    <div class="lead">当我们创建数据库或者表的时候，就要指定字符集和比较规则。 不指定则MySQL 默认。</div>
	<h4 id="字符集">字符集<a class="td-heading-self-link" href="#%e5%ad%97%e7%ac%a6%e9%9b%86" aria-label="Heading self-link"></a></h4>
<p>计算机的世界里，它是只认识 0 和 1 的, 那汉字怎么办? 英文怎么办?</p>
<p>我们在屏幕上看到的英文、汉字等字符是二进制数转换之后的结果</p>
<p>通俗的说，按照何种规则将字符存储在计算机中，如&rsquo;a&rsquo;用什么表示，称为&quot;编码&quot;；反之，将存储在计算机中的二进制数解析显示出来，称为&quot;解码&quot;,如果使用了错误的解码规则，则导致&rsquo;a&rsquo;解析成&rsquo;b&rsquo;或者乱码。</p>
<h4 id="ascii字符集编码">ASCII字符集&amp;编码<a class="td-heading-self-link" href="#ascii%e5%ad%97%e7%ac%a6%e9%9b%86%e7%bc%96%e7%a0%81" aria-label="Heading self-link"></a></h4>
<blockquote>
<p>ASCII(American Standard Code for Information Interchange，美国信息交换标准代码)</p>
<p>是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语</p></blockquote>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250211010458860.png" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250211010511256.png" alt="image.png"></p>
<p>ASCII的最大缺点是只能显示26个基本拉丁字母、阿拉伯数目字和英式标点符号，因此只能用于显示现代美国英语</p>
<blockquote>
<p>已经淘汰</p></blockquote>
<h3 id="gbxxxx字符集编码">GBXXXX字符集&amp;编码<a class="td-heading-self-link" href="#gbxxxx%e5%ad%97%e7%ac%a6%e9%9b%86%e7%bc%96%e7%a0%81" aria-label="Heading self-link"></a></h3>
<p>计算机发明之处及后面很长一段时间，只用应用于美国及西方一些发达国家，ASCII能够很好满足用户的需求。</p>
<p>但是当天朝也有了计算机之后，为了显示中文，必须设计一套编码规则用于将汉字转换为计算机可以接受的数字系统的字符集。</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250211010616455.png" alt="image.png"></p>
<blockquote>
<p>什么都有, 基本东亚文字全了</p></blockquote>
<p>GBK是对GB2312-80的扩展, 收录了繁体</p>
<h2 id="unicode字符集utf编码">Unicode字符集&amp;UTF编码<a class="td-heading-self-link" href="#unicode%e5%ad%97%e7%ac%a6%e9%9b%86utf%e7%bc%96%e7%a0%81" aria-label="Heading self-link"></a></h2>
<p><em>你说的对, 但是每个国家有自己的编码</em></p>
<p>那网络聊天怎么办? 编码不同根本无法识别</p>
<p>为了解决这个问题，一个伟大的创想产生了——Unicode。Unicode编码系统为表达任意语言的任意字符而设计。
被几种语言共用的字符通常使用相同的数字来编码, 不存在二义性。不再需要记录&quot;模式&quot;了</p>
<h4 id="比较规则">比较规则<a class="td-heading-self-link" href="#%e6%af%94%e8%be%83%e8%a7%84%e5%88%99" aria-label="Heading self-link"></a></h4>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-fadb4161cda4eb7aee82d35d77a64105">5.2 - MySQL数据库操作</h1>
    <div class="lead">十分钟快速上手MySQL</div>
	<p>十分钟快速上手MySQL</p>
<h4 id="创建数据库">创建数据库<a class="td-heading-self-link" href="#%e5%88%9b%e5%bb%ba%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="Heading self-link"></a></h4>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">create</span> <span style="color:#ca9ee6">database</span> <span style="color:#e78284">数据库名</span>;
</span></span></code></pre></div><blockquote>
<p>提示:</p>
<ol>
<li>上下箭头可以切换之前执行的指令</li>
<li>记得加分号</li>
</ol></blockquote>
<h4 id="切换数据库">切换数据库<a class="td-heading-self-link" href="#%e5%88%87%e6%8d%a2%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="Heading self-link"></a></h4>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>use <span style="color:#e78284">数据库名</span>;
</span></span></code></pre></div><h4 id="删除数据库">删除数据库<a class="td-heading-self-link" href="#%e5%88%a0%e9%99%a4%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="Heading self-link"></a></h4>
<blockquote>
<p>提示:
这个指令一般不用😂</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">drop</span> <span style="color:#ca9ee6">database</span> <span style="color:#e78284">数据库名</span>;
</span></span></code></pre></div><blockquote>
<p>了解
<a href="/docs/basic/mysql/mysql%E8%A1%A8%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/">表</a></p></blockquote>
<h4 id="java交互mysql">Java交互MySQL<a class="td-heading-self-link" href="#java%e4%ba%a4%e4%ba%92mysql" aria-label="Heading self-link"></a></h4>
<p>上述都是命令行操作</p>
<p>如何在Java程序对数据库进行操作?</p>
<blockquote>
<p>驱动
和显卡驱动, 网卡驱动类似, Java程序想要对MySQL做操作时也需要这样的桥梁</p></blockquote>
<p><a href="https://dev.mysql.com/downloads/connector/j/">MySQL Connector/J</a></p>
<blockquote>
<p><code>classpath</code>
也就是 <code>src/main/resources</code> 目录</p></blockquote>
<p>将下载的 <code>.jar</code> 包放到项目 <code>classpath</code> 下</p>
<p>在IDE中写一个类连接到服务器</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">class</span> <span style="color:#e5c890">DatabaseCreator</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> String URL <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#34;jdbc:mysql://localhost:3306/?useSSL=false&amp;serverTimezone=UTC&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> String USER <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#34;root&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> String PASSWORD <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#34;Codingmore123&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> String DATABASE_NAME <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#34;pai_coding&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">try</span> (Connection conn <span style="color:#99d1db;font-weight:bold">=</span> DriverManager.<span style="color:#8caaee">getConnection</span>(URL, USER, PASSWORD);
</span></span><span style="display:flex;"><span>             Statement stmt <span style="color:#99d1db;font-weight:bold">=</span> conn.<span style="color:#8caaee">createStatement</span>()) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (<span style="color:#99d1db;font-weight:bold">!</span>databaseExists(conn, DATABASE_NAME)) {
</span></span><span style="display:flex;"><span>                stmt.<span style="color:#8caaee">executeUpdate</span>(<span style="color:#a6d189">&#34;CREATE DATABASE IF NOT EXISTS &#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> DATABASE_NAME);
</span></span><span style="display:flex;"><span>                System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(<span style="color:#a6d189">&#34;数据库创建成功&#34;</span>);
</span></span><span style="display:flex;"><span>            } <span style="color:#ca9ee6">else</span> {
</span></span><span style="display:flex;"><span>                System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(<span style="color:#a6d189">&#34;数据库已经存在&#34;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#ca9ee6">catch</span> (SQLException e) {
</span></span><span style="display:flex;"><span>            e.<span style="color:#8caaee">printStackTrace</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">boolean</span> <span style="color:#8caaee">databaseExists</span>(Connection conn, String dbName) <span style="color:#e78284">throws</span> SQLException {
</span></span><span style="display:flex;"><span>        ResultSet resultSet <span style="color:#99d1db;font-weight:bold">=</span> conn.<span style="color:#8caaee">getMetaData</span>().<span style="color:#8caaee">getCatalogs</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">while</span> (resultSet.<span style="color:#8caaee">next</span>()) {
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (dbName.<span style="color:#8caaee">equals</span>(resultSet.<span style="color:#8caaee">getString</span>(1))) {
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">true</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>DriverManager.getConnection(URL, USER, PASSWORD)</code>：通过 JDBC 建立到 MySQL 服务器的连接。</p>
<blockquote>
<p>初学者不需要完全明白这些代码</p></blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ba3f3c8094c6e9acf93aa7c53ef12f2f">5.3 - MySQL数据库查询</h1>
    <div class="lead">在日常的开发工作中，查询语句也是最常用的</div>
	<p>在日常的开发工作中，查询语句也是最常用的，因为表在一开始设计的时候已经确定了，后期很少去修改表结构，也就意味着插入数据的方式也是确定的</p>
<p>但数据的展示方式却千奇百怪，用户端和 admin 管理端可能需要各种各样的数据，那 MySQL 就要提供最接近需求的数据，这样可以节省 Java 程序对数据的转换处理，也就相应提升了程序的性能。</p>
<p><code>SELECT</code> 语句可以灵活组织不同表的数据, 提供最接近需求的组合</p>
<blockquote>
<p>提示:
接下来的操作默认是单库操作
也就是说需要先选中某个数据库,
快去选择吧</p></blockquote>
<h4 id="查询单个字段">查询单个字段<a class="td-heading-self-link" href="#%e6%9f%a5%e8%af%a2%e5%8d%95%e4%b8%aa%e5%ad%97%e6%ae%b5" aria-label="Heading self-link"></a></h4>
<blockquote>
<p>记录
我们把表中的每一行叫做一个“记录”，每一个记录包含这行中的所有信息，就像在<a href="https://baike.baidu.com/item/%E9%80%9A%E8%AE%AF%E5%BD%95/9635277?fromModule=lemma_inlink">通讯录</a>数据库中某个人全部的信息，但记录在数据库中并没有专门的记录名，常常用它所在的行数表示这是第几个记录。</p></blockquote>
<blockquote>
<p>字段
字段是比记录更小的单位，字段集合组成记录，每个字段描述文献的某一特征，即<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%A1%B9/3227309?fromModule=lemma_inlink">数据项</a>，并有唯一的供计算机识别的<a href="https://baike.baidu.com/item/%E5%AD%97%E6%AE%B5%E6%A0%87%E8%AF%86%E7%AC%A6/53627692?fromModule=lemma_inlink">字段标识符</a>。</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> <span style="color:#e78284">字段名</span> <span style="color:#ca9ee6">FROM</span> <span style="color:#e78284">表名</span>;
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250211000414373.png" alt="image.png"></p>
<h4 id="别名">别名<a class="td-heading-self-link" href="#%e5%88%ab%e5%90%8d" aria-label="Heading self-link"></a></h4>
<p>查出来的字段名字太长, 先更换名字
可以使用 <code>AS</code> 关键字，格式如下所示</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> <span style="color:#e78284">字段名</span> <span style="color:#ca9ee6">AS</span> <span style="color:#e78284">别名</span> <span style="color:#ca9ee6">FROM</span> <span style="color:#e78284">表名</span>;
</span></span></code></pre></div><p>这通常会在多表进行联合查询或者 Java 程序端和 MySQL 表字段不一致时使用。</p>
<p>比如说，Java 程序端的字段名是 <code>articleTitle</code>，那我们就可以使用别名来解决这个问题。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> title <span style="color:#ca9ee6">AS</span> articleTitle <span style="color:#ca9ee6">FROM</span> article;
</span></span></code></pre></div><h4 id="查询多个字段">查询多个字段<a class="td-heading-self-link" href="#%e6%9f%a5%e8%af%a2%e5%a4%9a%e4%b8%aa%e5%ad%97%e6%ae%b5" aria-label="Heading self-link"></a></h4>
<p>有时候我们需要同时拿到多个字段</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> <span style="color:#e78284">字段</span><span style="color:#ef9f76">1</span>, <span style="color:#e78284">字段</span><span style="color:#ef9f76">2</span>, <span style="color:#e78284">字段</span><span style="color:#ef9f76">3</span> <span style="color:#ca9ee6">FROM</span> <span style="color:#e78284">表名</span>;
</span></span></code></pre></div><h4 id="查询所有字段">查询所有字段<a class="td-heading-self-link" href="#%e6%9f%a5%e8%af%a2%e6%89%80%e6%9c%89%e5%ad%97%e6%ae%b5" aria-label="Heading self-link"></a></h4>
<blockquote>
<p>了解
<a href="%E9%80%9A%E9%85%8D%E7%AC%A6.md">通配符</a></p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> <span style="color:#99d1db;font-weight:bold">*</span> <span style="color:#ca9ee6">FROM</span> <span style="color:#e78284">表名</span>;
</span></span></code></pre></div><h4 id="查询结果去重">查询结果去重<a class="td-heading-self-link" href="#%e6%9f%a5%e8%af%a2%e7%bb%93%e6%9e%9c%e5%8e%bb%e9%87%8d" aria-label="Heading self-link"></a></h4>
<p>有可能多个记录会有相同的字段值, 这很正常
懒得一个个分辨可以去重
使用 <code>DISTINCT</code> 关键字进行查询</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> <span style="color:#ca9ee6">DISTINCT</span> <span style="color:#e78284">字段名</span> <span style="color:#ca9ee6">FROM</span> <span style="color:#e78284">表名</span>;
</span></span></code></pre></div><h4 id="查询结果排序">查询结果排序<a class="td-heading-self-link" href="#%e6%9f%a5%e8%af%a2%e7%bb%93%e6%9e%9c%e6%8e%92%e5%ba%8f" aria-label="Heading self-link"></a></h4>
<p>当结果集中需要排序时，可以使用 <code>ORDER BY</code> 关键字进行查询，格式如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> <span style="color:#e78284">字段名</span> <span style="color:#ca9ee6">FROM</span> <span style="color:#e78284">表名</span> <span style="color:#ca9ee6">ORDER</span> <span style="color:#ca9ee6">BY</span> <span style="color:#e78284">字段名</span> [<span style="color:#ca9ee6">ASC</span><span style="color:#99d1db;font-weight:bold">|</span><span style="color:#ca9ee6">DESC</span>];
</span></span></code></pre></div><h4 id="查询结果限制条数">查询结果限制条数<a class="td-heading-self-link" href="#%e6%9f%a5%e8%af%a2%e7%bb%93%e6%9e%9c%e9%99%90%e5%88%b6%e6%9d%a1%e6%95%b0" aria-label="Heading self-link"></a></h4>
<p>我们只想要其中的1条或多条, 从哪里开始找, 查找几行结束</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> <span style="color:#e78284">字段名</span> <span style="color:#ca9ee6">FROM</span> <span style="color:#e78284">表名</span> <span style="color:#ca9ee6">LIMIT</span> <span style="color:#e78284">开始行</span>,<span style="color:#e78284">行数</span>;
</span></span></code></pre></div><blockquote>
<p>开始行也叫偏移量（OFFSET），默认是 0，可以缺省。</p></blockquote>
<blockquote>
<p>了解:
<a href="/docs/basic/mysql/mysql%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/">MySQL条件查询</a></p></blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-5c7eb05872462e8972765a1ac361bc03">5.4 - MySQL数据类型</h1>
    <div class="lead">当我们要创建表的时候，就要根据业务需求，选择合适的数据类型。</div>
	<p>表是由不同数据类型的列组成的，然后填充了一行一行的数据。当我们要创建表的时候，就要根据业务需求，选择合适的数据类型。</p>
<h4 id="整数类型">整数类型<a class="td-heading-self-link" href="#%e6%95%b4%e6%95%b0%e7%b1%bb%e5%9e%8b" aria-label="Heading self-link"></a></h4>
<table>
  <thead>
      <tr>
          <th>类型名称</th>
          <th>存储空间</th>
          <th>范围</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>tinyint</td>
          <td>1 字节</td>
          <td>-128 到 127 或者 0 到 255</td>
      </tr>
      <tr>
          <td>int</td>
          <td>4 字节</td>
          <td>-2147483648 到 2147483647 或者 0 到 4294967295</td>
      </tr>
      <tr>
          <td>bigint</td>
          <td>8 字节</td>
          <td>-9223372036854775808 到 9223372036854775807 或者 0 到 18446744073709551615</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>其实还有个 2 字节的 smallint 但是不常用</p></blockquote>
<p>设计表时</p>
<ul>
<li>对于状态\类型字段使用 <code>tinyint</code></li>
<li>记录id, 主键id等使用 <code>bigint</code></li>
<li>其他用<code>int</code></li>
</ul>
<h5 id="符号">符号?<a class="td-heading-self-link" href="#%e7%ac%a6%e5%8f%b7" aria-label="Heading self-link"></a></h5>
<p>这里注意, MySQL是存在有/无符号整型之分的, Java默认有符号</p>
<p>当涉及到负数表示时, 为了兼容, Java中必须使用<code>Long</code> 型</p>
<p>因为Java的<code>int</code>范围和MySQL不同分别是-2147483648 到 2147483647, 和 0 到 4294967295(无符号)</p>
<p>所以在设计表时, 整数的符号也要考虑</p>
<p>像自增 ID，肯定是无符号的，所以我们会在定义的时候将其设置为 <code>unsigned</code></p>
<h5 id="显示宽度">显示宽度?<a class="td-heading-self-link" href="#%e6%98%be%e7%a4%ba%e5%ae%bd%e5%ba%a6" aria-label="Heading self-link"></a></h5>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">CREATE</span> <span style="color:#ca9ee6">TABLE</span> <span style="color:#99d1db;font-weight:bold">`</span>test<span style="color:#99d1db;font-weight:bold">`</span> (
</span></span><span style="display:flex;"><span>  <span style="color:#99d1db;font-weight:bold">`</span>id<span style="color:#99d1db;font-weight:bold">`</span> <span style="color:#99d1db">int</span>(<span style="color:#ef9f76">10</span>) unsigned <span style="color:#ca9ee6">NOT</span> <span style="color:#ca9ee6">NULL</span> AUTO_INCREMENT,
</span></span><span style="display:flex;"><span>  <span style="color:#99d1db;font-weight:bold">`</span>int10<span style="color:#99d1db;font-weight:bold">`</span> <span style="color:#99d1db">int</span>(<span style="color:#ef9f76">10</span>) <span style="color:#ca9ee6">NOT</span> <span style="color:#ca9ee6">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#99d1db;font-weight:bold">`</span>int11<span style="color:#99d1db;font-weight:bold">`</span> <span style="color:#99d1db">int</span>(<span style="color:#ef9f76">11</span>) <span style="color:#ca9ee6">NOT</span> <span style="color:#ca9ee6">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#99d1db;font-weight:bold">`</span><span style="color:#99d1db">int</span><span style="color:#99d1db;font-weight:bold">`</span> <span style="color:#99d1db">int</span> <span style="color:#ca9ee6">NOT</span> <span style="color:#ca9ee6">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#ca9ee6">PRIMARY</span> <span style="color:#ca9ee6">KEY</span> (<span style="color:#99d1db;font-weight:bold">`</span>id<span style="color:#99d1db;font-weight:bold">`</span>)
</span></span><span style="display:flex;"><span>) ENGINE<span style="color:#99d1db;font-weight:bold">=</span>InnoDB <span style="color:#ca9ee6">DEFAULT</span> CHARSET<span style="color:#99d1db;font-weight:bold">=</span>utf8mb4;
</span></span></code></pre></div><p>经常设计表的同学知道, <code>int(10)</code> 和 <code>int(11)</code> 指的是显示宽度的不同, 这里不涉及精度的问题, 多余的位用0填充</p>
<p>就是视觉规定而已</p>
<blockquote>
<p>了解
<a href="https://alex.kirk.at/2007/08/24/what-does-size-in-intsize-of-mysql-mean/">ALEX</a> 的博客写的很好</p></blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d18d448ea26b2380832c20eaee109e3b">5.5 - MySQL条件查询</h1>
    <div class="lead">真实的业务场景中，数量会非常大，有些甚至会有几百万、几千万条数据，如果不带上查询条件，一次性把全部数据查出来是不太现实的。</div>
	<p>SELECT 查询没有查询条件。比如只返回姓名为xx的人, 年龄为xx的人等条件</p>
<p>要知道，真实的业务场景中，数量会非常大，有些甚至会有几百万、几千万条数据，如果不带上查询条件，一次性把全部数据查出来是不太现实的。</p>
<p>所以，我们通常要求在执行 SELECT 查询时，都要带上查询条件。那这一节，我们就来学习一些简单的 WHERE 条件查询。</p>
<h4 id="查询操作符">查询操作符<a class="td-heading-self-link" href="#%e6%9f%a5%e8%af%a2%e6%93%8d%e4%bd%9c%e7%ac%a6" aria-label="Heading self-link"></a></h4>
<table>
  <thead>
      <tr>
          <th>操作符</th>
          <th>示例</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>=</code></td>
          <td><code>user_id = 1</code></td>
          <td>等于</td>
      </tr>
      <tr>
          <td><code>!=</code> 或 <code>&lt;&gt;</code></td>
          <td><code>user_id != 1</code> 或 <code>user_id &lt;&gt; 1</code></td>
          <td>不等于</td>
      </tr>
      <tr>
          <td><code>&gt;</code></td>
          <td><code>user_id &gt; 1</code></td>
          <td>大于</td>
      </tr>
      <tr>
          <td><code>&lt;</code></td>
          <td><code>user_id &lt; 1</code></td>
          <td>小于</td>
      </tr>
      <tr>
          <td><code>&gt;=</code></td>
          <td><code>user_id &gt;= 1</code></td>
          <td>大于等于</td>
      </tr>
      <tr>
          <td><code>&lt;=</code></td>
          <td><code>user_id &lt;= 1</code></td>
          <td>小于等于</td>
      </tr>
  </tbody>
</table>
<p>示例:
查找id大于1000的文章</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> title, user_id, create_time <span style="color:#ca9ee6">FROM</span> article <span style="color:#ca9ee6">WHERE</span> user_id <span style="color:#99d1db;font-weight:bold">&gt;</span> <span style="color:#ef9f76">1000</span>;
</span></span></code></pre></div><h4 id="区间查询">区间查询<a class="td-heading-self-link" href="#%e5%8c%ba%e9%97%b4%e6%9f%a5%e8%af%a2" aria-label="Heading self-link"></a></h4>
<p>利用一个 <code>&gt;=</code> 和一个 <code>&lt;=</code>，配合 <code>AND</code> 关键字，就可以实现区间查询</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> <span style="color:#e78284">字段名</span> <span style="color:#ca9ee6">FROM</span> <span style="color:#e78284">表</span> <span style="color:#ca9ee6">WHERE</span> user_id <span style="color:#99d1db;font-weight:bold">&gt;=</span> <span style="color:#ef9f76">1000</span> <span style="color:#ca9ee6">AND</span> user_id <span style="color:#99d1db;font-weight:bold">&lt;=</span> <span style="color:#ef9f76">2000</span>;
</span></span></code></pre></div><p>查询上下界id为1000 到 2000 的文章</p>
<blockquote>
<p>其实就是规定上下界
所以可以用 <code>BETWEEN</code> 代替</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> title, user_id, create_time <span style="color:#ca9ee6">FROM</span> article <span style="color:#ca9ee6">WHERE</span> user_id <span style="color:#ca9ee6">BETWEEN</span> <span style="color:#ef9f76">1000</span> <span style="color:#ca9ee6">AND</span> <span style="color:#ef9f76">2000</span>;
</span></span></code></pre></div><p>取反也可以, 加上 <code>NOT</code> 就行</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> title, user_id, create_time <span style="color:#ca9ee6">FROM</span> article <span style="color:#ca9ee6">WHERE</span> user_id <span style="color:#ca9ee6">NOT</span> <span style="color:#ca9ee6">BETWEEN</span> <span style="color:#ef9f76">1000</span> <span style="color:#ca9ee6">AND</span> <span style="color:#ef9f76">2000</span>;
</span></span></code></pre></div><blockquote>
<p>感觉比Python简单</p></blockquote>
<h4 id="枚举查询">枚举查询<a class="td-heading-self-link" href="#%e6%9e%9a%e4%b8%be%e6%9f%a5%e8%af%a2" aria-label="Heading self-link"></a></h4>
<p>当区间为1, 其实就是枚举, 这就不需要指定上下界了
我们可以直接指定数值 用 <code>IN</code></p>
<p>查询 user_id 是 1、2、3 的文章</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> title, user_id, create_time <span style="color:#ca9ee6">FROM</span> article <span style="color:#ca9ee6">WHERE</span> user_id <span style="color:#ca9ee6">IN</span> (<span style="color:#ef9f76">1</span>, <span style="color:#ef9f76">2</span>, <span style="color:#ef9f76">3</span>); 
</span></span></code></pre></div><p>当然可以取反. 此略</p>
<h4 id="逻辑操作符">逻辑操作符<a class="td-heading-self-link" href="#%e9%80%bb%e8%be%91%e6%93%8d%e4%bd%9c%e7%ac%a6" aria-label="Heading self-link"></a></h4>
<p>除了数据操作符外还可以进行逻辑判断</p>
<p>其实上文的 <code>AND</code> 就是一个</p>
<p><code>AND</code> 操作符用于组合多个查询条件，只有当所有的条件都满足时，才会返回结果</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> title, user_id, create_time <span style="color:#ca9ee6">FROM</span> article <span style="color:#ca9ee6">WHERE</span> user_id <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">1</span> <span style="color:#ca9ee6">AND</span> title <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#39;something&#39;</span>;
</span></span></code></pre></div><p><code>OR</code>与其类似</p>
<p>可以使用<code>()</code> 指定优先级</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> title, user_id, create_time <span style="color:#ca9ee6">FROM</span> article <span style="color:#ca9ee6">WHERE</span> user_id <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">1</span> <span style="color:#ca9ee6">AND</span> (title <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#39;聊聊分库分表&#39;</span> <span style="color:#ca9ee6">OR</span> short_title <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#a6d189">&#39;&#39;</span>);
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-48d22b2363579601962c96e1f427026c">5.6 - MySQL表操作</h1>
    <div class="lead">有了数据库以后，我们就可以在数据库中对表进行增删改查了</div>
	<p>有了数据库以后，我们就可以在数据库中对表进行增删改查了</p>
<p>MySQL是关系型数据库, 这个名词通俗来说就是把世界上的一切物体都实体化, 通过属性之间的关系管理数据</p>
<p>实体化的结果叫做表, 数据库中以表为组织单位存储数据</p>
<h4 id="查表">查表<a class="td-heading-self-link" href="#%e6%9f%a5%e8%a1%a8" aria-label="Heading self-link"></a></h4>
<p>首先指定数据库</p>
<p>查看当前数据库中的所有表，可以使用 </p>
<p><code>show tables</code></p>
<p>不首先指定数据库的话</p>
<p><code>show tables from 数据库名;</code></p>
<blockquote>
<p>提示:
这是查看表名的操作, 跟表结构没关系</p></blockquote>
<h4 id="建表">建表<a class="td-heading-self-link" href="#%e5%bb%ba%e8%a1%a8" aria-label="Heading self-link"></a></h4>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">create</span> <span style="color:#ca9ee6">table</span> <span style="color:#e78284">表名</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">列名</span><span style="color:#ef9f76">1</span> <span style="color:#e78284">数据类型</span><span style="color:#ef9f76">1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">列名</span><span style="color:#ef9f76">2</span> <span style="color:#e78284">数据类型</span><span style="color:#ef9f76">2</span>,
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">列名</span>n <span style="color:#e78284">数据类型</span>n
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><blockquote>
<p>了解:
<a href="/docs/basic/mysql/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">MySQL数据类型</a></p></blockquote>
<p>这里可能会遇到问题</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210235135096.png" alt="image.png"></p>
<p>指示表已经存在了, 这时只能删掉以前的表
为了避免这种情况，我们可以在建表的时候，先判断表是否存在，如果不存在，再创建表，语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">create</span> <span style="color:#ca9ee6">table</span> <span style="color:#ca9ee6">if</span> <span style="color:#ca9ee6">not</span> <span style="color:#ca9ee6">exists</span> <span style="color:#e78284">表名</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">列名</span><span style="color:#ef9f76">1</span> <span style="color:#e78284">数据类型</span><span style="color:#ef9f76">1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">列名</span><span style="color:#ef9f76">2</span> <span style="color:#e78284">数据类型</span><span style="color:#ef9f76">2</span>,
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">列名</span>n <span style="color:#e78284">数据类型</span>n
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><h4 id="注释">注释<a class="td-heading-self-link" href="#%e6%b3%a8%e9%87%8a" aria-label="Heading self-link"></a></h4>
<p>是的, 表也有注释, 在上百张表的情况下, 注释就很重要了</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">create</span> <span style="color:#ca9ee6">table</span> <span style="color:#e78284">表名</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">列名</span><span style="color:#ef9f76">1</span> <span style="color:#e78284">数据类型</span><span style="color:#ef9f76">1</span> <span style="color:#ca9ee6">comment</span> <span style="color:#a6d189">&#39;注释1&#39;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">列名</span><span style="color:#ef9f76">2</span> <span style="color:#e78284">数据类型</span><span style="color:#ef9f76">2</span> <span style="color:#ca9ee6">comment</span> <span style="color:#a6d189">&#39;注释2&#39;</span>,
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">列名</span>n <span style="color:#e78284">数据类型</span>n <span style="color:#ca9ee6">comment</span> <span style="color:#a6d189">&#39;注释n&#39;</span>
</span></span><span style="display:flex;"><span>) <span style="color:#ca9ee6">comment</span> <span style="color:#a6d189">&#39;表注释&#39;</span>;
</span></span></code></pre></div><h4 id="查看表结构">查看表结构<a class="td-heading-self-link" href="#%e6%9f%a5%e7%9c%8b%e8%a1%a8%e7%bb%93%e6%9e%84" aria-label="Heading self-link"></a></h4>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">desc</span> <span style="color:#e78284">表名</span>;
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">describe</span> <span style="color:#e78284">表名</span>;
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">explain</span> <span style="color:#e78284">表名</span>;
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">show</span> columns <span style="color:#ca9ee6">from</span> <span style="color:#e78284">表名</span>;
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">show</span> fields <span style="color:#ca9ee6">from</span> <span style="color:#e78284">表名</span>;
</span></span></code></pre></div><p>上述指令效果完全一样</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210235526115.png" alt="image.png"></p>
<h4 id="改表">改表<a class="td-heading-self-link" href="#%e6%94%b9%e8%a1%a8" aria-label="Heading self-link"></a></h4>
<p>这需要一些数据库底层原理基础知识才能操作, 此处略过</p>
<blockquote>
<p>了解
<a href="/docs/basic/mysql/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2/">MySQL数据库简单查询</a>
<a href="/docs/basic/mysql/mysql%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/">MySQL字符集和比较规则</a></p></blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-aec71f889e3edd1c2c139a8adbb7b003">5.7 - 事务</h1>
    <div class="lead">在关系型数据库中，事务的重要性不言而喻，只要对数据库稍有了解的人都知道事务具有 ACID 四个基本属性</div>
	<blockquote>
<p>引用:
go语言大佬, go语言设计与原理作者
<a href="https://draveness.me/mysql-innodb/">面向信仰编程 - draveness</a></p></blockquote>
<p>在关系型数据库中，事务的重要性不言而喻，只要对数据库稍有了解的人都知道事务具有 ACID 四个基本属性，</p>
<p>而我们不知道的可能就是数据库是如何实现这四个属性的；在这篇文章中，我们将对事务的实现进行分析，尝试理解数据库是如何实现事务的，当然我们也会在文章中简单对 MySQL 中对 ACID 的实现进行简单的介绍。</p>
<p>原子性, 一致性, 隔离性, 持久性
ACID</p>
<h4 id="原子性">原子性<a class="td-heading-self-link" href="#%e5%8e%9f%e5%ad%90%e6%80%a7" aria-label="Heading self-link"></a></h4>
<p>事务就是一系列的操作，要么全部都执行，要都不执行，这其实就是对事务原子性的刻画</p>
<p>如果事务不具备原子性，那么就没办法保证同一个事务中的所有操作都被执行或者未被执行了，整个数据库系统就既不可用也不可信。</p>
<blockquote>
<p>数据库的事务提交也是多线程并发的, 适用并发编程</p></blockquote>
<h4 id="持久性">持久性<a class="td-heading-self-link" href="#%e6%8c%81%e4%b9%85%e6%80%a7" aria-label="Heading self-link"></a></h4>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250211011722492.png" alt="image.png"></p>
<p>数据被写入到数据库中，那么数据一定能够被安全存储在磁盘上, 这就是持久性</p>
<p>可能会奇怪, 除非硬盘挂掉, 为什么会存在持久性问题呢</p>
<p>其实持久性并非问题, 而是一种原则</p>
<p>一旦事务被提交，那么数据一定会被写入到数据库中并持久存储起来。
也就是当数据被写到硬盘后, 不允许撤销!</p>
<blockquote>
<p><em>当事务已经被提交之后，就无法再次回滚了，唯一能够撤回已经提交的事务的方式就是创建一个相反的事务对原操作进行『补偿』，这也是事务持久性的体现之一。</em></p></blockquote>
<h4 id="隔离性">隔离性<a class="td-heading-self-link" href="#%e9%9a%94%e7%a6%bb%e6%80%a7" aria-label="Heading self-link"></a></h4>
<p>数据库的事务之间没有隔离性, 就会发生级联回滚的问题, 造成性能上的巨大损失</p>
<p>如果所有的事务的执行顺序都是线性的，那么对于事务的管理容易得多，但是允许事务的并行执行却能能够提升吞吐量和资源利用率，并且可以减少每个事务的等待时间。</p>
<h4 id="一致性">一致性<a class="td-heading-self-link" href="#%e4%b8%80%e8%87%b4%e6%80%a7" aria-label="Heading self-link"></a></h4>
<p>分为两种一致性</p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-00b1f54870739c9642ff5be20f722ae9">6 - 通配符</h1>
    <div class="lead">In software, a wildcard character is a kind of placeholder represented by a single character, such as an asterisk (*), which can be interpreted as a number of literal characters or an empty string. It is often used in file searches so the full name need not be typed.</div>
	<blockquote>
<p>In software, a wildcard character is a kind of placeholder represented by a single character, such as an asterisk (*), which can be interpreted as a number of literal characters or an empty string. It is often used in file searches so the full name need not be typed.</p>
<p>简单来说, 使用通配符来进行模糊查询</p></blockquote>
<h4 id="-通配符"><code>%</code> 通配符<a class="td-heading-self-link" href="#-%e9%80%9a%e9%85%8d%e7%ac%a6" aria-label="Heading self-link"></a></h4>
<p><code>%</code> 通配符用于匹配任意长度的字符串，包括零长度，在查询文章标题、用户名等此类字段时，会非常有用。</p>
<h4 id="-通配符-1"><code>*</code> 通配符<a class="td-heading-self-link" href="#-%e9%80%9a%e9%85%8d%e7%ac%a6-1" aria-label="Heading self-link"></a></h4>
<p>代表匹配所有值</p>
<h4 id="-参数占位符"><code>?</code> 参数占位符<a class="td-heading-self-link" href="#-%e5%8f%82%e6%95%b0%e5%8d%a0%e4%bd%8d%e7%ac%a6" aria-label="Heading self-link"></a></h4>
<p>插值表达式传参使用</p>

</div>



    
	
  



          </main>
        </div>
      </div>
      <footer class="td-footer row d-print-none">
  <div class="container-fluid">
    <div class="row mx-md-2">
      <div class="td-footer__left col-6 col-sm-4 order-sm-1">
        <ul class="td-footer__links-list">
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="User mailing list" aria-label="User mailing list">
    <a target="_blank" rel="noopener" href="https://example.org/mail" aria-label="User mailing list">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="Twitter" aria-label="Twitter">
    <a target="_blank" rel="noopener" href="https://example.org/twitter" aria-label="Twitter">
      <i class="fab fa-twitter"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="Stack Overflow" aria-label="Stack Overflow">
    <a target="_blank" rel="noopener" href="https://example.org/stack" aria-label="Stack Overflow">
      <i class="fab fa-stack-overflow"></i>
    </a>
  </li>
  
</ul>

      </div><div class="td-footer__right col-6 col-sm-4 order-sm-3">
        <ul class="td-footer__links-list">
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="GitHub" aria-label="GitHub">
    <a target="_blank" rel="noopener" href="https://github.com/google/docsy" aria-label="GitHub">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="Slack" aria-label="Slack">
    <a target="_blank" rel="noopener" href="https://example.org/slack" aria-label="Slack">
      <i class="fab fa-slack"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="Developer mailing list" aria-label="Developer mailing list">
    <a target="_blank" rel="noopener" href="https://example.org/mail" aria-label="Developer mailing list">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
</ul>

      </div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2">
        <span class="td-footer__copyright">&copy;
    2025&ndash;2025
    <span class="td-footer__authors">海阔知识库 | <a href="https://creativecommons.org/licenses/by/4.0">CC BY 4.0</a> |</span></span><span class="td-footer__all_rights_reserved">All Rights Reserved</span><span class="ms-2"><a href="https://policies.google.com/privacy" target="_blank" rel="noopener">Privacy Policy</a></span>
      </div>
    </div>
  </div>
</footer>

    </div>
    <script src="/js/main.js"></script>
<script defer src="/js/click-to-copy.js" crossorigin="anonymous"></script>
<script src='/js/tabpane-persist.js'></script>

  </body>
</html>
