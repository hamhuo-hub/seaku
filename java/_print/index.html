<!doctype html>
<html itemscope itemtype="http://schema.org/WebPage" lang="en" class="no-js">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="canonical" type="text/html" href="https://hamhuo.xyz/java/">
<link rel="alternate" type="application/rss&#43;xml" href="https://hamhuo.xyz/java/index.xml">
<meta name="robots" content="noindex, nofollow">


<link rel="shortcut icon" href="/favicons/favicon.ico" >
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/favicons/android-36x36.png" sizes="36x36">
<link rel="icon" type="image/png" href="/favicons/android-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="/favicons/android-72x72.png" sizes="72x72">
<link rel="icon" type="image/png" href="/favicons/android-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicons/android-144x144.png" sizes="144x144">
<link rel="icon" type="image/png" href="/favicons/android-192x192.png" sizes="192x192">

<title>Documents | 海阔集</title>
<meta name="description" content="Overview:JVM:Machine language consists of very simple instructions that can be executed directly by the CPU of a computer.
but Java C&#43;&#43; high-level language cannot be run directly on any computer.
First, it has to be translated into machine language. This translation can be done by a program called a compiler.
Once the translation is done, the machine-language program can be run any number of times">
<meta property="og:url" content="https://hamhuo.xyz/java/">
  <meta property="og:site_name" content="海阔集">
  <meta property="og:title" content="Documents">
  <meta property="og:description" content="Overview:JVM:Machine language consists of very simple instructions that can be executed directly by the CPU of a computer.
but Java C&#43;&#43; high-level language cannot be run directly on any computer.
First, it has to be translated into machine language. This translation can be done by a program called a compiler.
Once the translation is done, the machine-language program can be run any number of times">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="website">

  <meta itemprop="name" content="Documents">
  <meta itemprop="description" content="Overview:JVM:Machine language consists of very simple instructions that can be executed directly by the CPU of a computer.
but Java C&#43;&#43; high-level language cannot be run directly on any computer.
First, it has to be translated into machine language. This translation can be done by a program called a compiler.
Once the translation is done, the machine-language program can be run any number of times">
  <meta itemprop="dateModified" content="2025-03-08T12:51:48+08:00">
  <meta itemprop="wordCount" content="127">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Documents">
  <meta name="twitter:description" content="Overview:JVM:Machine language consists of very simple instructions that can be executed directly by the CPU of a computer.
but Java C&#43;&#43; high-level language cannot be run directly on any computer.
First, it has to be translated into machine language. This translation can be done by a program called a compiler.
Once the translation is done, the machine-language program can be run any number of times">
<link rel="preload" href="/scss/main.min.6c18e25eadfb13d8abc6b872960e12aab94122cfeded66e3b312c962ee366f20.css" as="style" integrity="sha256-bBjiXq37E9irxrhylg4SqrlBIs/t7WbjsxLJYu42byA=" crossorigin="anonymous">
<link href="/scss/main.min.6c18e25eadfb13d8abc6b872960e12aab94122cfeded66e3b312c962ee366f20.css" rel="stylesheet" integrity="sha256-bBjiXq37E9irxrhylg4SqrlBIs/t7WbjsxLJYu42byA=" crossorigin="anonymous">
<script
  src="https://code.jquery.com/jquery-3.7.1.min.js"
  integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g=="
  crossorigin="anonymous"></script>
<script defer
  src="https://unpkg.com/lunr@2.3.9/lunr.min.js"
  integrity="sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli"
  crossorigin="anonymous"></script>

  </head>
  <body class="td-section">
    <header>
      <nav class="td-navbar js-navbar-scroll" data-bs-theme="dark">
<div class="container-fluid flex-column flex-md-row">
  <a class="navbar-brand" href="/"><span class="navbar-brand__logo navbar-logo"><svg width="800" height="800" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M23.3 8.40007 21.82 6.40008C21.7248 6.27314 21.6008 6.17066 21.4583 6.10111 21.3157 6.03156 21.1586 5.99693 21 6.00008H11.2C11.0555 6.00007 10.9128 6.03135 10.7816 6.09177 10.6504 6.15219 10.5339 6.24031 10.44 6.35007L8.71998 8.35008C8.57227 8.53401 8.49435 8.76424 8.49998 9.00008V16.2901C8.50262 18.0317 9.19567 19.7013 10.4272 20.9328c1.2316 1.2316 2.9011 1.9246 4.6428 1.9273h1.86C18.6716 22.8574 20.3412 22.1644 21.5728 20.9328c1.2315-1.2315 1.9245-2.9011 1.9272-4.6427V9.00008C23.5 8.7837 23.4298 8.57317 23.3 8.40007z" fill="#ffcc80"/><path d="M29.78 28.38l-4-5C25.664 23.2321 25.5086 23.1198 25.3318 23.0562 25.1549 22.9925 24.9637 22.98 24.78 23.02L16 25 7.21999 23C7.03632 22.96 6.84507 22.9725 6.6682 23.0362 6.49133 23.0998 6.33598 23.2121 6.21999 23.36l-4 5C2.10392 28.5064 2.03116 28.6823 2.00995 28.8679 1.98874 29.0534 2.01993 29.2413 2.09999 29.41 2.17815 29.5839 2.3044 29.7319 2.46385 29.8364 2.62331 29.9409 2.80933 29.9977 2.99999 30H29C29.1885 29.9995 29.373 29.9457 29.5322 29.8448 29.6914 29.744 29.8189 29.6002 29.9 29.43 29.98 29.2613 30.0112 29.0734 29.99 28.8879 29.9688 28.7023 29.8961 28.5264 29.78 28.38z" fill="#01579b"/><path d="M29.29 6.00003l-13-4C16.0999 1.95002 15.9001 1.95002 15.71 2.00003l-13 4c-.21258.06419-.39774.19732-.5263.37838C2.05515 6.55947 1.99052 6.77817 2 7.00003 1.9917 7.22447 2.0592 7.44518 2.19163 7.62659c.13242.1814.32207.31295.53837.37344L15.73 11.6C15.906 11.6534 16.094 11.6534 16.27 11.6l13-3.59997C29.4863 7.93954 29.6759 7.80799 29.8084 7.62659 29.9408 7.44518 30.0083 7.22447 30 7.00003 30.0095 6.77817 29.9448 6.55947 29.8163 6.37841 29.6877 6.19735 29.5026 6.06422 29.29 6.00003z" fill="#01579b"/><path d="M11.22 6C11.0756 5.99999 10.9328 6.03127 10.8016 6.09169 10.6704 6.15211 10.5539 6.24023 10.46 6.35l-1.72 2C8.58509 8.53114 8.49998 8.76166 8.5 9v7.29C8.50264 18.0317 9.19569 19.7012 10.4272 20.9328c1.2316 1.2315 2.9011 1.9246 4.6428 1.9272H16V6H11.22z" fill="#ffe0b2"/><path d="M7.21999 23C7.03632 22.96 6.84507 22.9725 6.6682 23.0362 6.49133 23.0998 6.33598 23.2121 6.21999 23.36l-4 5C2.10392 28.5064 2.03116 28.6823 2.00995 28.8679 1.98874 29.0534 2.01993 29.2413 2.09999 29.41 2.17815 29.5839 2.3044 29.7319 2.46385 29.8364 2.62331 29.9409 2.80933 29.9977 2.99999 30H16V25L7.21999 23z" fill="#0277bd"/><path d="M15.71 2.00002l-13 4C2.49742 6.06422 2.31226 6.19734 2.1837 6.3784c-.12855.18107-.19318.39977-.1837.62162C1.9917 7.22447 2.0592 7.44518 2.19163 7.62658 2.32405 7.80799 2.5137 7.93954 2.73 8.00002L15.73 11.6C15.8194 11.6146 15.9106 11.6146 16 11.6V2.00002C15.9039 1.98469 15.8061 1.98469 15.71 2.00002z" fill="#0277bd"/><path d="M2.73 8.00003l5.77 1.56V16.29C8.50264 18.0317 9.19569 19.7013 10.4272 20.9328c1.2316 1.2315 2.9011 1.9246 4.6428 1.9272h1.86C18.6717 22.8574 20.3412 22.1643 21.5728 20.9328c1.2315-1.2315 1.9246-2.9011 1.9272-4.6428V9.56003l5.77-1.56C29.4863 7.93954 29.6759 7.80799 29.8084 7.62659 29.9408 7.44518 30.0083 7.22447 30 7.00003 30.0095 6.77817 29.9448 6.55947 29.8163 6.37841 29.6877 6.19735 29.5026 6.06422 29.29 6.00003l-13-4C16.0999 1.95002 15.9001 1.95002 15.71 2.00003l-13 4c-.21258.06419-.39774.19732-.5263.37838C2.05515 6.55947 1.99052 6.77817 2 7.00003 1.9917 7.22447 2.0592 7.44518 2.19163 7.62659c.13242.1814.32207.31295.53837.37344zM21.5 16.29C21.4974 17.5013 21.015 18.6621 20.1586 19.5186 19.3021 20.3751 18.1412 20.8574 16.93 20.86H15.07C13.8588 20.8574 12.6979 20.3751 11.8414 19.5186 10.985 18.6621 10.5026 17.5013 10.5 16.29V10.11l5.23 1.45C15.906 11.6134 16.094 11.6134 16.27 11.56l5.23-1.45v6.18zM16 4.05003l9.44 2.95-9.44 2.56-9.44-2.56 9.44-2.95z" fill="#263238"/><path d="M25.78 23.38C25.664 23.2321 25.5086 23.1198 25.3318 23.0562 25.1549 22.9925 24.9637 22.98 24.78 23.02L16 25 7.21999 23C7.03632 22.96 6.84507 22.9725 6.6682 23.0362 6.49133 23.0998 6.33598 23.2121 6.21999 23.36l-4 5C2.10392 28.5064 2.03116 28.6823 2.00995 28.8679 1.98874 29.0534 2.01993 29.2413 2.09999 29.41 2.17815 29.5839 2.3044 29.7319 2.46385 29.8364 2.62331 29.9409 2.80933 29.9977 2.99999 30H29C29.1885 29.9995 29.373 29.9457 29.5322 29.8448 29.6914 29.744 29.8189 29.6002 29.9 29.43 29.98 29.2613 30.0112 29.0734 29.99 28.8879 29.9688 28.7023 29.8961 28.5264 29.78 28.38l-4-5zM5.07999 28l2.31-2.89L15.78 27C15.9251 27.0299 16.0748 27.0299 16.22 27l8.39-1.87L26.92 28H5.07999z" fill="#263238"/></svg></span><span class="navbar-brand__name">海阔集</span></a>
  <div class="td-navbar-nav-scroll ms-md-auto" id="main_navbar">
    <ul class="navbar-nav">
      <li class="nav-item">
        <a class="nav-link" href="/leetcode/"><span>Alog</span></a>
      </li>
      <li class="nav-item">
        <a class="nav-link active" href="/java/"><span>Doc</span></a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="/graphicsai/"><span>Graphics and AI</span></a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="/interview/"><span>Interview</span></a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="/graphicsai/torch/"><span>Pytorch basics tutorials</span></a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="/school/"><span>课程归档</span></a>
      </li>
      <li class="td-light-dark-menu nav-item dropdown">
        <svg xmlns="http://www.w3.org/2000/svg" class="d-none">
  <symbol id="check2" viewBox="0 0 16 16">
    <path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"/>
  </symbol>
  <symbol id="circle-half" viewBox="0 0 16 16">
    <path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"/>
  </symbol>
  <symbol id="moon-stars-fill" viewBox="0 0 16 16">
    <path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/>
    <path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"/>
  </symbol>
  <symbol id="sun-fill" viewBox="0 0 16 16">
    <path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>
  </symbol>
</svg>

<button class="btn btn-link nav-link dropdown-toggle d-flex align-items-center"
        id="bd-theme"
        type="button"
        aria-expanded="false"
        data-bs-toggle="dropdown"
        data-bs-display="static"
        aria-label="Toggle theme (auto)">
  <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg>
</button>
<ul class="dropdown-menu dropdown-menu-end" aria-labelledby="bd-theme-text">
  <li>
    <button type="button" class="dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
      <svg class="bi me-2 opacity-50"><use href="#sun-fill"></use></svg>
      Light
      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg>
    </button>
  </li>
  <li>
    <button type="button" class="dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
      <svg class="bi me-2 opacity-50"><use href="#moon-stars-fill"></use></svg>
      Dark
      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg>
    </button>
  </li>
  <li>
    <button type="button" class="dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
      <svg class="bi me-2 opacity-50"><use href="#circle-half"></use></svg>
      Auto
      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg>
    </button>
  </li>
</ul>

      </li>
      </ul>
  </div>
  <div class="d-none d-lg-block">
    <div class="td-search td-search--offline">
  <div class="td-search__icon"></div>
  <input
    type="search"
    class="td-search__input form-control"
    placeholder="Search this site…"
    aria-label="Search this site…"
    autocomplete="off"
    
    data-offline-search-index-json-src="/offline-search-index.9540f3f8497a5a12c3e901a8713c85ab.json"
    data-offline-search-base-href="/"
    data-offline-search-max-results="10"
  >
</div>
  </div>
</div>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <main class="col-12 col-md-9 col-xl-8 ps-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
This is the multi-page printable view of this section.
<a href="#" onclick="print();return false;">Click here to print</a>.
</p><p>
<a href="/java/">Return to the regular view of this page</a>.
</p>
</div>



<h1 class="title">Documents</h1>





    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-b7978ead672249ea076838b203f4eace">Java基础能力</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>1.1: <a href="#pg-934d922e423aab8aff14545b41575ff6">Docker</a></li>


    
    <ul>
        
  
  
  
  

  

    </ul>
    
  
    
    
	
<li>1.2: <a href="#pg-6c2d47b64cefac4fe43af4663d886db5">JavaWeb</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>1.2.1: <a href="#pg-aa9a70007dd7e57c4057593dcd0e4970">Servlet</a></li>


    
  

    </ul>
    
  
    
    
	
<li>1.3: <a href="#pg-f6853e40bf40334f142cc35bd48fd71e">Java并发编程</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>1.3.1: <a href="#pg-9ed2b71eb187f4299524c21d7a34a0bf">AQS</a></li>


    
  
    
    
	
<li>1.3.2: <a href="#pg-294b7d04c76f9a59df2c56f6b8a6ce7e">Difference between run() and start()</a></li>


    
  
    
    
	
<li>1.3.3: <a href="#pg-c03adf61efd4dc98aad143480991996b">JMM内存模型</a></li>


    
  
    
    
	
<li>1.3.4: <a href="#pg-83c69e8ed4be282c4741b7a98d22ca92">Liveness</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>1.3.4.1: <a href="#pg-845883f08515cee324b776c88bb2b744">deadlock</a></li>


    
  

    </ul>
    
  
    
    
	
<li>1.3.5: <a href="#pg-d014cd9177c8aa1c4dd81f876057dd69">synchronized</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>1.3.5.1: <a href="#pg-d935226cca7410a10e890a281d87cd7c">atomic</a></li>


    
  
    
    
	
<li>1.3.5.2: <a href="#pg-d84cd7f670a6480268128d704794cf04">Memory Consistency Errors</a></li>


    
  
    
    
	
<li>1.3.5.3: <a href="#pg-94fa4a7164aa50dc3f7e72b40ea93cd8">ReadWriteLock</a></li>


    
  
    
    
	
<li>1.3.5.4: <a href="#pg-44806d547d596a7ad4a84a926b25d7d0">ReentrantLock重入锁</a></li>


    
  

    </ul>
    
  
    
    
	
<li>1.3.6: <a href="#pg-0671a42570c837d9b5dcad4457bbd242">Thread Objects</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>1.3.6.1: <a href="#pg-f8f1cf0a2ad572348931a0a3261648c0">多线程入门</a></li>


    
  
    
    
	
<li>1.3.6.2: <a href="#pg-692ec2134d8731bfeb7329215f96d964">线程</a></li>


    
  
    
    
	
<li>1.3.6.3: <a href="#pg-20bf6e765d72459a6752c379a8afe938">线程生命周期</a></li>


    
  

    </ul>
    
  
    
    
	
<li>1.3.7: <a href="#pg-d582c66e48e4720cfdedf3b426a00eb9">ThreadLocal</a></li>


    
  
    
    
	
<li>1.3.8: <a href="#pg-9cf457bfa828c8ced5473d3530c729ed">volatile关键字</a></li>


    
  
    
    
	
<li>1.3.9: <a href="#pg-715da0d04d4983431cda607d9e28d8de">线程池</a></li>


    
  
    
    
	
<li>1.3.10: <a href="#pg-f678f50588596c85cbf389be75259a81">自旋锁与CLH锁</a></li>


    
  
    
    
	
<li>1.3.11: <a href="#pg-ccc0b90c05532451a1793418e52c926f">获取线程执行结果</a></li>


    
  
    
    
	
<li>1.3.12: <a href="#pg-eb58c6263bd0f4c0a9d27623576ca64e">通信工具类</a></li>


    
  
    
    
	
<li>1.3.13: <a href="#pg-bc1c17d06273c0655aee4c36ef7ac3e4"></a></li>


    
  
    
    
	
<li>1.3.14: <a href="#pg-ab69ccd2ef54b92e136c4c0f577a70d4"></a></li>


    
  
    
    
	
<li>1.3.15: <a href="#pg-3c9d097a3c2cc02642d83a2d176c4c26"></a></li>


    
  

    </ul>
    
  
    
    
	
<li>1.4: <a href="#pg-c00ea7dd56878ea2f5f2ecbde4b08b00">Java数据类型</a></li>


    
  
    
    
	
<li>1.5: <a href="#pg-fb1f1b494bcd063f262ba00385cb3da4">Java集合框架</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>1.5.1: <a href="#pg-9886ba6c7be251f58197e67c1f8cab0b">LinkedList</a></li>


    
  
    
    
	
<li>1.5.2: <a href="#pg-1e2799081c05c7725471a651bb895f48"></a></li>


    
  

    </ul>
    
  
    
    
	
<li>1.6: <a href="#pg-0875c54f6d44df81f93d332739dec85a">JVM</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>1.6.1: <a href="#pg-1cc71c675230af6c3f2a48d23454c2d4">Java的四种引用</a></li>


    
  

    </ul>
    
  
    
    
	
<li>1.7: <a href="#pg-932a01a42f76fda69c7dd02a6867b569">MySQL</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>1.7.1: <a href="#pg-ef17bed2d83c0c5d4e034c246e042618">MySQL字符集和比较规则</a></li>


    
  
    
    
	
<li>1.7.2: <a href="#pg-3c8ae2e325db9dfb27013b9bcb0803d1">MySQL数据库操作</a></li>


    
  
    
    
	
<li>1.7.3: <a href="#pg-8908f767bc059121cf9c4b637a826d79">MySQL数据库查询</a></li>


    
  
    
    
	
<li>1.7.4: <a href="#pg-8ebe80fc40bfabb67174586fde900fd3">MySQL数据类型</a></li>


    
  
    
    
	
<li>1.7.5: <a href="#pg-ac7b3d70780cd7381ef9141dc7bcceeb">MySQL条件查询</a></li>


    
  
    
    
	
<li>1.7.6: <a href="#pg-bb859bbb6df88f0d22408f9500f306f5">MySQL索引</a></li>


    
  
    
    
	
<li>1.7.7: <a href="#pg-095d53f7f8ca5978bc69f27bf77a4e19">MySQL表操作</a></li>


    
  
    
    
	
<li>1.7.8: <a href="#pg-04d36435c7ee74ec811b541c12267369">MySQL连接</a></li>


    
  
    
    
	
<li>1.7.9: <a href="#pg-0ca269ceb9541e7f1eb615a64e7ebf27">事务</a></li>


    
  
    
    
	
<li>1.7.10: <a href="#pg-3f6264d453c28a09c23b292e07d0d7de">数据库设计规范</a></li>


    
  

    </ul>
    
  
    
    
	
<li>1.8: <a href="#pg-4315e9814bd8608b77147cd960f728ea">工厂方法</a></li>


    
  
    
    
	
<li>1.9: <a href="#pg-d9055392eb71058d8d40e7407bf4927f">模板方法</a></li>


    
  
    
    
	
<li>1.10: <a href="#pg-a841198d5abd16a2b0310d3e513b50ad">通配符</a></li>


    
  

    </ul>
    
  
    
    
	
<li>2: <a href="#pg-cb92de0a4259bd45f476feb25241d160">Java进阶能力</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>2.1: <a href="#pg-aca1efb0a9ee065c0b3ad65d73e67dbe"></a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>2.1.1: <a href="#pg-c5546365fa7a60719df25e8956893000">FastDFS分布式存储</a></li>


    
  

    </ul>
    
  
    
    
	
<li>2.2: <a href="#pg-5480c4968cf2bd7572c3d657358f7947"></a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>2.2.1: <a href="#pg-62bb39299d50fdae18e411e45b33da59">RocketMQ</a></li>


    
  

    </ul>
    
  
    
    
	
<li>2.3: <a href="#pg-6847462fbc45c0ec0e2539734fdfc520">AOP面向切面编程</a></li>


    
  
    
    
	
<li>2.4: <a href="#pg-5ba10e92aedbfc888e0e1fc25ad92362">FastExcel报表组件</a></li>


    
  
    
    
	
<li>2.5: <a href="#pg-2b22ec5ab6cb18f57e4a05415d0a34e2">Gateway网关</a></li>


    
  
    
    
	
<li>2.6: <a href="#pg-a10ef0a98cd31d88eed3637bec2fff46">Intercepter拦截器</a></li>


    
  
    
    
	
<li>2.7: <a href="#pg-ed66f29438332c88139caba654f9e301">JWT与Session</a></li>


    
  
    
    
	
<li>2.8: <a href="#pg-14466de61718f3e7e4e0634fcd427c5f">Nacos配置中心</a></li>


    
  
    
    
	
<li>2.9: <a href="#pg-bfce5c28aec1143b74ff0aa46a5285a4">OAuth2认证</a></li>


    
  
    
    
	
<li>2.10: <a href="#pg-7784bca3c26210aa2f38f471a8a3c1c4">SpringMVC</a></li>


    
  
    
    
	
<li>2.11: <a href="#pg-c5be60b3ee2566487eb164b032000197">TTL</a></li>


    
  
    
    
	
<li>2.12: <a href="#pg-f91a61b39377d9ea9caf33190d589187">WebSocket</a></li>


    
  
    
    
	
<li>2.13: <a href="#pg-7a2c40656558a17fe41d7952d03dfa64">事务管理</a></li>


    
  
    
    
	
<li>2.14: <a href="#pg-ca8521f6a11893682100c677a8e28283">响应式编程Reactor库</a></li>


    
  
    
    
	
<li>2.15: <a href="#pg-7f81b67460689b745ab9bb3e9564c653">声明式服务</a></li>


    
  

    </ul>
    
  

    </ul>


<div class="content">
      <h4 id="overview">Overview:<a class="td-heading-self-link" href="#overview" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><h5 id="jvm">JVM:<a class="td-heading-self-link" href="#jvm" aria-label="Heading self-link"></a></h5>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>Machine language consists of very simple instructions that can be executed directly by the CPU of a computer.</p>
<p>but Java C++ high-level language cannot be run directly on any computer.</p>
<p>First, it has to be translated into machine language. This translation can be done by a program called a compiler.</p>
<p>Once the translation is done, the machine-language program can be run any number of times</p>
<p>Of course, a different Java bytecode interpreter is needed for each type of computer, but once a computer has a Java bytecode interpreter, it can run any Java bytecode program, and the same program can be run on any computer that has such an interpreter.</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250303235343054.png" alt="image.png"></p>
<h5 id="hello-world">Hello World!!!<a class="td-heading-self-link" href="#hello-world" aria-label="Heading self-link"></a></h5>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">HelloWorld</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args){
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(<span style="color:#a6d189">&#34;Hello, World!!&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>OK,</p>

</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-b7978ead672249ea076838b203f4eace">1 - Java基础能力</h1>
    
	<p>内容来源:</p>
<ul>
<li>沉默王二 GitHub 上开源的知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">Java 进阶之路</a>》</li>
</ul>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-934d922e423aab8aff14545b41575ff6">1.1 - Docker</h1>
    <div class="lead">应用运行容器, 傻瓜式安装程序环境, 还不怕中病毒</div>
	<p>内容来源:</p>
<ul>
<li>沉默王二 GitHub 上开源的知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">Java 进阶之路</a>》</li>
</ul>

</div>



    
      
  
  
  
  

  
  

  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6c2d47b64cefac4fe43af4663d886db5">1.2 - JavaWeb</h1>
    <div class="lead">web目录</div>
	<p>内容来源:</p>
<ul>
<li>沉默王二 GitHub 上开源的知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">Java 进阶之路</a>》</li>
</ul>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-aa9a70007dd7e57c4057593dcd0e4970">1.2.1 - Servlet</h1>
    <div class="lead">Servlet 容器（也常称为 Servlet 容器或 Web 容器）是一个软件系统，它负责管理和处理 Web 应用程序中的 Servlet。</div>
	<p>Servlet 是整个JavaWeb的核心</p>
<p>当请求传入服务器后, 服务器会交给一个<code>Servlet</code> 处理, 该 <code>Servlet</code> 可以根据请求生成动态的内容</p>
<ul>
<li>查询数据库，</li>
<li>处理表单数据，</li>
<li>返回动态生成的 HTML 页面，</li>
<li>或者返回 JSON 数据供前端使用等。</li>
</ul>
<p>之后 <code>Servlet</code> 会生成响应, 比如 HTML 或者 Json返回浏览器</p>
<p>感性认识: <code>Servlet</code> 像是一个组件, 其中Java服务器使用的 <code>Servlet</code> 负责生成动态内容(请求处理), 其他 <code>Servlet</code> 负责处理静态资源, 错误页面等</p>
<p>举个例子：</p>
<ul>
<li>
<p>如果你访问一个静态页面（如 <code>index.html</code>），Tomcat 会将这个静态页面直接返回给你。这就跟后端服务器没关系了, 直接在 <code>Tomcat</code> 中的某一个 Servlet 就能完成</p>
</li>
<li>
<p>如果你访问一个动态页面（如使用 Spring MVC 的控制器来处理请求），Tomcat 会将请求交给 <code>DispatcherServlet</code>，然后 <code>DispatcherServlet</code> 会找到相应的 <code>Controller</code>，<code>Controller</code> 会生成一些数据，交给视图解析器，将模板与数据结合，最后生成一个完整的 HTML 页面。</p>
</li>
</ul>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f6853e40bf40334f142cc35bd48fd71e">1.3 - Java并发编程</h1>
    
	<p>内容来源:</p>
<ul>
<li>沉默王二 GitHub 上开源的知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">Java 进阶之路</a>》</li>
<li><a href="https://javaguide.cn/java/concurrent/">JavaGuide</a></li>
<li><a href="https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg">CLH锁 - Quner技术沙龙</a></li>
<li>操作系统 - 西电出版</li>
</ul>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9ed2b71eb187f4299524c21d7a34a0bf">1.3.1 - AQS</h1>
    <div class="lead"><strong>AQS</strong>是<code>AbstractQueuedSynchronizer</code>的简称，即<code>抽象的队列同步器</code></div>
	<p><strong>AQS</strong>是<code>AbstractQueuedSynchronizer</code>的简称，即<code>抽象的队列同步器</code></p>
<ul>
<li>抽象：抽象类，只实现一些主要逻辑，有些方法由子类实现；</li>
<li>队列：使用先进先出（FIFO）的队列存储数据；</li>
<li>同步：实现了同步的功能。</li>
</ul>
<h4 id="为什么需要-aqs">为什么需要 <code>AQS</code><a class="td-heading-self-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81-aqs" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的同步器
简单的说,  存储并管理线程同步的模板</p>
<p>具体的同步器（如 <code>ReentrantLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code>, <a href="/java/basic/concurrent/%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C/">FutureTask</a>等）是通过继承 <code>AQS</code> 并实现一些抽象方法来实现资源的具体获取和释放行为的。</p>
<h4 id="aqs的作用是什么"><code>AQS</code>的作用是什么?<a class="td-heading-self-link" href="#aqs%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p>了解
<a href="/java/basic/concurrent/%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8Eclh%E9%94%81/">自旋锁与CLH锁</a></p></blockquote>
<p><code>AQS</code> 是一个 <strong>抽象类</strong>，它为具体的同步器提供了一个通用的执行框架。
它定义了如何获取和释放共享资源的基本流程，但并没有实现具体的逻辑。</p>
<p><code>AQS</code> 提供了同步器所需要的 <strong>框架和基础设施</strong>，比如：</p>
<ol>
<li>如何在多个线程间协调资源的竞争。</li>
<li>如何管理线程的队列（阻塞队列）以等待资源。</li>
</ol>
<blockquote>
<p>其中AQS 的核心数据结构是基于<a href="/java/basic/concurrent/%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8Eclh%E9%94%81/">CLH 锁</a>改进的, 详情下述</p></blockquote>
<ol start="3">
<li>线程的挂起与唤醒等机制。</li>
</ol>
<h4 id="aqs的数据结构">AQS的数据结构<a class="td-heading-self-link" href="#aqs%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>既然是控制线程, 那么数据结构应对并发相应的优化
AQS的核心数据结构是基于 CLH队列锁改进的
<img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/Pasted%20image%2020250203211340.png" alt="Pasted image 20250203211340.png">
CLH队列锁有如下缺点</p>
<ol>
<li>仍然基于自旋, 长时间自旋下CPU占用高</li>
<li>功能单一, 不能挂起, 不能共享读, 只支持独占等
针对以上缺点, AQS进行改造</li>
<li>AQS 将自旋操作改为阻塞线程操作。</li>
<li>AQS 对 CLH 锁进行改造和扩展, 扩展每个节点的状态、显式的维护前驱节点和后继节点</li>
</ol>
<p>AQS 内部使用了一个<a href="/java/basic/concurrent/volatile%E5%85%B3%E9%94%AE%E5%AD%97/">volatile关键字</a> 的变量 <code>state</code> 来作为线程的状态标识。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">volatile</span> <span style="color:#e78284">int</span> waitStatus;
</span></span></code></pre></div><p>该变量有如下状态, AQS提供原子读写
![[content/en/java/Basic/Concurrent/Pasted image 20250203210552.png]]</p>
<ul>
<li>CANCELLED：表示当前节点（对应的线程）已被取消。当等待超时或被中断，会触发进入为此状态，进入该状态后节点状态不再变化；</li>
<li>SIGNAL：后面节点等待当前节点唤醒；</li>
<li>CONDITION：当前线程阻塞在Condition，如果其他线程调用了Condition的signal方法，这个节点将从等待队列转移到同步队列队尾，等待获取同步锁；</li>
</ul>
<blockquote>
<p>了解<a href="/java/basic/concurrent/condition%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9D%A1%E4%BB%B6/">Condition等待通知条件</a></p></blockquote>
<ul>
<li>PROPAGATE：共享模式，前置节点唤醒后面节点后，唤醒操作无条件传播下去；</li>
<li>0：中间状态，当前节点后面的节点已经唤醒，但是当前节点线程还没有执行完成。
状态多了不少, 但是AQS为了优化, 抛弃了自旋设计,这导致线程被阻塞时没办法获取前驱节点的状态
所以AQS显式维护前后节点, 在锁释放时主动通知后继线程解除阻塞
<img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/Pasted%20image%2020250203211000.png" alt="Pasted image 20250203211000.png"></li>
</ul>
<p><em>(T1 释放锁后主动唤醒 T2，使 T2 检测到锁已释放，获取锁成功。)</em></p>
<blockquote>
<p>在释放锁时，如果当前节点的后驱节点不可用时，将从利用队尾指针 Tail 从尾部遍历到直到找到当前节点正确的后驱节点。
这是因为双端队列的插入没有相应的原子操作, 因此后驱节点的设置并非作为原子性插入操作的一部分，而仅是在节点被插入后简单地赋值</p></blockquote>
<p>AQS还实现了共享读
资源有两种共享模式，或者说两种同步方式：</p>
<ul>
<li>
<p>独占模式（Exclusive）：资源是独占的，一次只能有一个线程获取。如 <a href="ReentrantLock%E9%87%8D%E5%85%A5%E9%94%81.md">ReentrantLock重入锁</a> <a href="content/en/java/Basic/Concurrent/synchronization/_index.md">_index</a></p>
</li>
<li>
<p>共享模式（Share）：同时可以被多个线程获取，具体的资源个数可以通过参数指定。如 <a href="/java/basic/concurrent/%E9%80%9A%E4%BF%A1%E5%B7%A5%E5%85%B7%E7%B1%BB/">Semaphore/CountDownLatch</a></p>
</li>
</ul>
<p>这两种模式是在内部类 <code>Node</code> 中实现的</p>
<p>Node源码</p>
<blockquote>
<p>可以看到 node中的状态信息都是常量, 无法修改的</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">static</span> <span style="color:#e78284">final</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">Node</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 标记一个结点（对应的线程）在共享模式下等待</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> Node SHARED <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Node();
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 标记一个结点（对应的线程）在独占模式下等待</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> Node EXCLUSIVE <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ef9f76">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// waitStatus的值，表示该结点（对应的线程）已被取消</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> <span style="color:#e78284">int</span> CANCELLED <span style="color:#99d1db;font-weight:bold">=</span> 1;
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// waitStatus的值，表示后继结点（对应的线程）需要被唤醒</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> <span style="color:#e78284">int</span> SIGNAL <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#99d1db;font-weight:bold">-</span>1;
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// waitStatus的值，表示该结点（对应的线程）在等待某一条件</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> <span style="color:#e78284">int</span> CONDITION <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#99d1db;font-weight:bold">-</span>2;
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">/*waitStatus的值，表示有资源可用，新head结点需要继续唤醒后继结点（共享模式下，多线程并发释放资源，而head唤醒其后继结点后，需要把多出来的资源留给后面的结点；设置新的head结点时，会继续唤醒其后继结点）*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> <span style="color:#e78284">int</span> PROPAGATE <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#99d1db;font-weight:bold">-</span>3;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 等待状态，取值范围，-3，-2，-1，0，1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">volatile</span> <span style="color:#e78284">int</span> waitStatus;
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">volatile</span> Node prev; <span style="color:#737994;font-style:italic">// 前驱结点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">volatile</span> Node next; <span style="color:#737994;font-style:italic">// 后继结点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">volatile</span> Thread thread; <span style="color:#737994;font-style:italic">// 结点对应的线程</span>
</span></span><span style="display:flex;"><span>    Node nextWaiter; <span style="color:#737994;font-style:italic">// 等待队列里下一个等待条件的结点</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 判断共享模式的方法</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">final</span> <span style="color:#e78284">boolean</span> <span style="color:#8caaee">isShared</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> nextWaiter <span style="color:#99d1db;font-weight:bold">==</span> SHARED;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Node(Thread thread, Node mode) {     <span style="color:#737994;font-style:italic">// Used by addWaiter</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">this</span>.<span style="color:#8caaee">nextWaiter</span> <span style="color:#99d1db;font-weight:bold">=</span> mode;
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">this</span>.<span style="color:#8caaee">thread</span> <span style="color:#99d1db;font-weight:bold">=</span> thread;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 其它方法忽略，可以参考具体的源码</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// AQS里面的addWaiter私有方法</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">private</span> Node <span style="color:#8caaee">addWaiter</span>(Node mode) {
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 使用了Node的这个构造函数</span>
</span></span><span style="display:flex;"><span>    Node node <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Node(Thread.<span style="color:#8caaee">currentThread</span>(), mode);
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 其它代码省略</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="aqs源码解析">AQS源码解析<a class="td-heading-self-link" href="#aqs%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>AQS 的设计是基于<a href="%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.md">模板方法</a>的，它有一些方法必须要子类实现，它们主要有：</p>
<ul>
<li><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到 condition 才需要去实现它。</li>
<li><code>tryAcquire(int)</code>：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</li>
<li><code>tryRelease(int)</code>：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。</li>
<li><code>tryAcquireShared(int)</code>：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回 true，否则返回 false。</li>
</ul>
<blockquote>
<p>比较特殊的是, 这里的抽象方法并没有加 <code>abstract</code> 关键字
这是因为并非AQS的所有抽象方法都需要子类实现, 所以子类只重写需要的方法就行</p></blockquote>
<p>子类不是重点, 我们来看模板类, 也就是AQS的逻辑</p>
<h5 id="获取资源">获取资源<a class="td-heading-self-link" href="#%e8%8e%b7%e5%8f%96%e8%b5%84%e6%ba%90" aria-label="Heading self-link"></a></h5>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>获取资源的入口是 <code>acquire(int arg)</code>方法。arg 是要获取的资源个数，在独占模式下始终为 1。我们先来看看这个方法的逻辑：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">final</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">accquire</span>(<span style="color:#e78284">int</span> arg) {
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// tryAcquire 再次尝试获取锁资源，如果尝试成功，返回true，尝试失败返回false</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (<span style="color:#99d1db;font-weight:bold">!</span>tryAcquire(arg) <span style="color:#99d1db;font-weight:bold">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 走到这，代表获取锁资源失败，需要将当前线程封装成一个Node，追加到AQS的队列中</span>
</span></span><span style="display:flex;"><span>        acquireQueued(addWaiter(Node.<span style="color:#8caaee">EXCLUSIVE</span>), arg))
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 线程中断</span>
</span></span><span style="display:flex;"><span>        selfInterrupt();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>首先调用 <code>tryAcquire</code> 尝试去获取资源。如果获取资源失败，就通过 <code>addWaiter(Node.EXCLUSIVE)</code> 方法把这个线程插入到等待队列中。其中传入的参数代表要插入的 Node 是独占式的。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">private</span> Node <span style="color:#8caaee">addWaiter</span>(Node mode) {
</span></span><span style="display:flex;"><span> <span style="color:#737994;font-style:italic">//创建 Node 类，并且设置 thread 为当前线程，设置为排它锁</span>
</span></span><span style="display:flex;"><span> Node node <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Node(Thread.<span style="color:#8caaee">currentThread</span>(), mode);
</span></span><span style="display:flex;"><span> <span style="color:#737994;font-style:italic">// 获取 AQS 中队列的尾部节点</span>
</span></span><span style="display:flex;"><span> Node pred <span style="color:#99d1db;font-weight:bold">=</span> tail;
</span></span><span style="display:flex;"><span> <span style="color:#737994;font-style:italic">// 如果 tail == null，说明是空队列，</span>
</span></span><span style="display:flex;"><span> <span style="color:#737994;font-style:italic">// 不为 null，说明现在队列中有数据，</span>
</span></span><span style="display:flex;"><span> <span style="color:#ca9ee6">if</span> (pred <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#737994;font-style:italic">// 将当前节点的 prev 指向刚才的尾部节点，那么当前节点应该设置为尾部节点</span>
</span></span><span style="display:flex;"><span>  node.<span style="color:#8caaee">prev</span> <span style="color:#99d1db;font-weight:bold">=</span> pred;
</span></span><span style="display:flex;"><span>  <span style="color:#737994;font-style:italic">// CAS 将 tail 节点设置为当前节点</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ca9ee6">if</span> (compareAndSetTail(pred, node)) {
</span></span><span style="display:flex;"><span>   <span style="color:#737994;font-style:italic">// 将之前尾节点的 next 设置为当前节点</span>
</span></span><span style="display:flex;"><span>   pred.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> node;
</span></span><span style="display:flex;"><span>   <span style="color:#737994;font-style:italic">// 返回当前节点</span>
</span></span><span style="display:flex;"><span>   <span style="color:#ca9ee6">return</span> node;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> enq(node);
</span></span><span style="display:flex;"><span> <span style="color:#ca9ee6">return</span> node;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// 自旋CAS插入等待队列</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">private</span> Node <span style="color:#8caaee">enq</span>(<span style="color:#e78284">final</span> Node node) {
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">for</span> (;;) {
</span></span><span style="display:flex;"><span>        Node t <span style="color:#99d1db;font-weight:bold">=</span> tail;
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (t <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span>) { <span style="color:#737994;font-style:italic">// Must initialize</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (compareAndSetHead(<span style="color:#ca9ee6">new</span> Node()))
</span></span><span style="display:flex;"><span>                tail <span style="color:#99d1db;font-weight:bold">=</span> head;
</span></span><span style="display:flex;"><span>        } <span style="color:#ca9ee6">else</span> {
</span></span><span style="display:flex;"><span>            node.<span style="color:#8caaee">prev</span> <span style="color:#99d1db;font-weight:bold">=</span> t;
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (compareAndSetTail(t, node)) {
</span></span><span style="display:flex;"><span>                t.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> node;
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">return</span> t;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在队列的尾部插入新的 Node 节点，但是需要注意的是由于 AQS 中会存在多个线程同时争夺资源的情况，因此肯定会出现多个线程同时插入节点的操作，在这里是通过 CAS 自旋的方式保证了操作的线程安全性。</p>
<h5 id="释放资源">释放资源<a class="td-heading-self-link" href="#%e9%87%8a%e6%94%be%e8%b5%84%e6%ba%90" aria-label="Heading self-link"></a></h5>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">final</span> <span style="color:#e78284">boolean</span> <span style="color:#8caaee">release</span>(<span style="color:#e78284">int</span> arg) {
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (tryRelease(arg)) {
</span></span><span style="display:flex;"><span>        Node h <span style="color:#99d1db;font-weight:bold">=</span> head;
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (h <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">&amp;&amp;</span> h.<span style="color:#8caaee">waitStatus</span> <span style="color:#99d1db;font-weight:bold">!=</span> 0)
</span></span><span style="display:flex;"><span>            unparkSuccessor(h);
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">private</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">unparkSuccessor</span>(Node node) {
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 如果状态是负数，尝试把它设置为0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> ws <span style="color:#99d1db;font-weight:bold">=</span> node.<span style="color:#8caaee">waitStatus</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (ws <span style="color:#99d1db;font-weight:bold">&lt;</span> 0)
</span></span><span style="display:flex;"><span>        compareAndSetWaitStatus(node, ws, 0);
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 得到头结点的后继结点head.next</span>
</span></span><span style="display:flex;"><span>    Node s <span style="color:#99d1db;font-weight:bold">=</span> node.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 如果这个后继结点为空或者状态大于0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 通过前面的定义我们知道，大于0只有一种可能，就是这个结点已被取消（只有 Node.CANCELLED(=1) 这一种状态大于0）</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (s <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">||</span> s.<span style="color:#8caaee">waitStatus</span> <span style="color:#99d1db;font-weight:bold">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>        s <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ef9f76">null</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 从尾部开始倒着寻找第一个还未取消的节点（真正的后继者）</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (Node t <span style="color:#99d1db;font-weight:bold">=</span> tail; t <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">&amp;&amp;</span> t <span style="color:#99d1db;font-weight:bold">!=</span> node; t <span style="color:#99d1db;font-weight:bold">=</span> t.<span style="color:#8caaee">prev</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (t.<span style="color:#8caaee">waitStatus</span> <span style="color:#99d1db;font-weight:bold">&lt;=</span> 0)
</span></span><span style="display:flex;"><span>                s <span style="color:#99d1db;font-weight:bold">=</span> t;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 如果后继结点不为空，</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (s <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>)
</span></span><span style="display:flex;"><span>        LockSupport.<span style="color:#8caaee">unpark</span>(s.<span style="color:#8caaee">thread</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果<code>tryRelease(arg)</code>成功释放了锁，那么接下来会检查队列的头结点。如果头结点存在并且waitStatus不为0（这意味着有线程在等待），那么会调用<code>unparkSuccessor(Node h)</code>方法来唤醒等待的线程。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-294b7d04c76f9a59df2c56f6b8a6ce7e">1.3.2 - Difference between run() and start()</h1>
    <div class="lead"><code>Thread.run()</code> similar to <code>Thread.start()</code> What&rsquo;s the difference?</div>
	<p> the two most significant methods of multithreading are start() and run().</p>
<h4 id="major-differences">major differences<a class="td-heading-self-link" href="#major-differences" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><h5 id="1-thread-creation">1. <strong>Thread creation</strong><a class="td-heading-self-link" href="#1-thread-creation" aria-label="Heading self-link"></a></h5>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>However, if we call the run() function directly, no new thread is generated, and the run() method is executed as a normal method call on the current calling thread, with no multi-threading</p>
<h5 id="2-multiple-invocation"><strong>2. Multiple invocation</strong><a class="td-heading-self-link" href="#2-multiple-invocation" aria-label="Heading self-link"></a></h5>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p> start() method cannot be performed again without throwing an<code>IllegalStateException</code>
 
 It is never legal to start a thread more than once
 
  In particular, a thread may not be restarted once it has completed execution.
 </p>
<blockquote>
<p><a href="%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.md">线程生命周期(Chinese Only)</a></p></blockquote>
<p><code>run()</code> method can call many times since it&rsquo;s just a regular method call</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250307213644400.png" alt="image.png"></p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c03adf61efd4dc98aad143480991996b">1.3.3 - JMM内存模型</h1>
    <div class="lead">Java 内存模型（Java Memory Model，JMM）定义了 Java 程序中的变量、线程如何和主存以及工作内存进行交互的规则</div>
	<p>Java 内存模型（Java Memory Model，JMM）定义了 Java 程序中的变量、线程如何和主存以及工作内存进行交互的规则, 可以理解为并发编程相关的一组规范</p>
<p>JMM在Java中主要解决<a href="%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B.md">线程同步与通信</a>问题, 涉及到内存可见性, 指令重排等问题</p>
<blockquote>
<p>Java 是最早尝试提供内存模型的编程语言。由于早期内存模型存在一些缺陷（比如非常容易削弱编译器的优化能力），从 Java5 开始，Java 开始使用新的内存模型</p></blockquote>
<blockquote>
<p>一般来说，编程语言也可以直接复用操作系统层面的内存模型。不过，不同的操作系统内存模型不同。如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了。
Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。</p></blockquote>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205095605661.png" alt="image.png"></p>
<p>红色区域称主内存, 是线程存放共享变量的区域</p>
<p>白色为本地内存</p>
<ul>
<li><strong>主内存</strong>：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量，还是局部变量，类信息、常量、静态变量都是放在主内存中。为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。</li>
<li><strong>本地内存</strong>：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的副本。每个线程只能操作自己本地内存中的变量，无法直接访问其他线程的本地内存。如果线程间需要通信，必须通过主内存来进行。本地内存是 JMM 抽象出来的一个概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</li>
</ul>
<h4 id="内存可见性问题">内存可见性问题<a class="td-heading-self-link" href="#%e5%86%85%e5%ad%98%e5%8f%af%e8%a7%81%e6%80%a7%e9%97%ae%e9%a2%98" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>和 <a href="CPU%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.md">CPU cache</a> 类似, 当多个线程同时读写共享变量时, 线程不存在同步机制会导致变量被覆写, 导致结果不可预见
<img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205100230451.png" alt="image.png"></p>
<p>如何解决内存可见性问题?</p>
<p>关于主内存与工作内存直接的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义来以下八种同步操作</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205100905174.png" alt="image.png">
初次之外还规定了很多同步规则,这不重要</p>
<h4 id="指令重排序问题">指令重排序问题<a class="td-heading-self-link" href="#%e6%8c%87%e4%bb%a4%e9%87%8d%e6%8e%92%e5%ba%8f%e9%97%ae%e9%a2%98" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。</p>
<p><strong>什么是指令重排序？</strong> 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。<strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p>
<h4 id="happen-before-原则">happen-before 原则<a class="td-heading-self-link" href="#happen-before-%e5%8e%9f%e5%88%99" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p>happens-before 这个概念最早诞生于 Leslie Lamport 于 1978 年发表的论文<a href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf">《Time，Clocks and the Ordering of Events in a Distributed System》</a>。在这篇论文中，Leslie Lamport 提出了逻辑时钟的概念，这也成了第一个逻辑时钟算法 。</p></blockquote>
<p><strong>逻辑时钟并不度量时间本身，仅区分事件发生的前后顺序，其本质就是定义了一种 happens-before 关系。</strong></p>
<p>也就是说, happen-before确定了</p>
<ol>
<li>只要不改变程序的执行结果（单线程程序和正确执行的多线程程序），编译器和处理器怎么进行重排序优化都行。</li>
<li>对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。
<img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205101317644.png" alt="image.png"></li>
</ol>
<p>结合happen-before关系和上述的同步规则, 就可以解决线程的通信与同步</p>
<ul>
<li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前。</li>
<li>两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。
例如</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">int</span> userNum <span style="color:#99d1db;font-weight:bold">=</span> getUserNum();   <span style="color:#737994;font-style:italic">// 1</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> teacherNum <span style="color:#99d1db;font-weight:bold">=</span> getTeacherNum();   <span style="color:#737994;font-style:italic">// 2</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> totalNum <span style="color:#99d1db;font-weight:bold">=</span> userNum <span style="color:#99d1db;font-weight:bold">+</span> teacherNum;  <span style="color:#737994;font-style:italic">// 3</span>
</span></span></code></pre></div><p>虽然 1 happens-before 2，但对 1 和 2 进行重排序不会影响代码的执行结果，所以 JMM 是允许编译器和处理器执行这种重排序的。但 1 和 2 必须是在 3 执行之前，也就是说 1,2 happens-before 3 。</p>
<p>happen-before 的实质就是前一个操作是否需要对后一个操作可见也就是涉及到了两个操作共有的变量, 需要便符合happen-before 关系
这与是否为并发环境无关</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205101819135.png" alt="image.png"></p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-83c69e8ed4be282c4741b7a98d22ca92">1.3.4 - Liveness</h1>
    <div class="lead">A concurrent application&rsquo;s ability to execute in a timely manner is known as its liveness. This section describes the most common kind of liveness problem, deadlock, and goes on to briefly describe two other liveness problems, starvation and livelock.</div>
	<p>A concurrent application&rsquo;s ability to execute in a timely manner is known as its liveness. This section describes the most common kind of liveness problem, [[deadlock]], and goes on to briefly describe two other liveness problems, starvation and livelock.</p>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-845883f08515cee324b776c88bb2b744">1.3.4.1 - deadlock</h1>
    <div class="lead">Deadlock describes a situation where two or more threads are blocked forever, waiting for each other.</div>
	<p><em>Deadlock</em> describes a situation where two or more threads are blocked forever, waiting for each other.</p>
<p>Alphonse and Gaston are friends, and great believers in courtesy. A strict rule of courtesy is that when you bow to a friend, you must remain bowed until your friend has a chance to return the bow. Unfortunately, this rule does not account for the possibility that two friends might bow to each other at the same time. This example application followed models this possibility:</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">Deadlock</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">Friend</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">private</span> <span style="color:#e78284">final</span> String name;
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">public</span> <span style="color:#8caaee">Friend</span>(String name) {
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">this</span>.<span style="color:#8caaee">name</span> <span style="color:#99d1db;font-weight:bold">=</span> name;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">public</span> String <span style="color:#8caaee">getName</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">return</span> <span style="color:#ca9ee6">this</span>.<span style="color:#8caaee">name</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">public</span> <span style="color:#e78284">synchronized</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">bow</span>(Friend bower) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">format</span>(<span style="color:#a6d189">&#34;%s: %s&#34;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;  has bowed to me!%n&#34;</span>, 
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">this</span>.<span style="color:#8caaee">name</span>, bower.<span style="color:#8caaee">getName</span>());
</span></span><span style="display:flex;"><span>            bower.<span style="color:#8caaee">bowBack</span>(<span style="color:#ca9ee6">this</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">public</span> <span style="color:#e78284">synchronized</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">bowBack</span>(Friend bower) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">format</span>(<span style="color:#a6d189">&#34;%s: %s&#34;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34; has bowed back to me!%n&#34;</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">this</span>.<span style="color:#8caaee">name</span>, bower.<span style="color:#8caaee">getName</span>());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">final</span> Friend alphonse <span style="color:#99d1db;font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">new</span> Friend(<span style="color:#a6d189">&#34;Alphonse&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">final</span> Friend gaston <span style="color:#99d1db;font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">new</span> Friend(<span style="color:#a6d189">&#34;Gaston&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">new</span> Thread(<span style="color:#ca9ee6">new</span> Runnable() {
</span></span><span style="display:flex;"><span>            <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">run</span>() { alphonse.<span style="color:#8caaee">bow</span>(gaston); }
</span></span><span style="display:flex;"><span>        }).<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">new</span> Thread(<span style="color:#ca9ee6">new</span> Runnable() {
</span></span><span style="display:flex;"><span>            <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">run</span>() { gaston.<span style="color:#8caaee">bow</span>(alphonse); }
</span></span><span style="display:flex;"><span>        }).<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>when they attempt to invoke <code>bowBack</code>. Neither block will ever end, because each thread is waiting for the other to exit <code>bow</code>.</p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d014cd9177c8aa1c4dd81f876057dd69">1.3.5 - synchronized</h1>
    <div class="lead">Threads communicate primarily by sharing access to fields and the objects reference fields refer to. This form of communication is extremely efficient, but makes two kinds of errors possible: thread interference and memory consistency errors. The tool needed to prevent these errors is synchronization.</div>
	<blockquote>
<p>在 Java 中，关键字 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)
synchronized 的另外一个重要的作用，synchronized 可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到</p></blockquote>
<p>The Java programming language provides two basic synchronization idioms: </p>
<p><em>synchronized methods</em> and <em>synchronized statements</em>.</p>
<p>we are talking about <code>synchronization</code> idioms</p>
<h4 id="synchronization-idioms"><code>synchronization</code> idioms<a class="td-heading-self-link" href="#synchronization-idioms" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>To make a method synchronized, simply add the <code>synchronized</code> keyword to its declaration:</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">SynchronizedCounter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> <span style="color:#e78284">int</span> c <span style="color:#99d1db;font-weight:bold">=</span> 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">synchronized</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">increment</span>() {
</span></span><span style="display:flex;"><span>        c<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">synchronized</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">decrement</span>() {
</span></span><span style="display:flex;"><span>        c<span style="color:#99d1db;font-weight:bold">--</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">synchronized</span> <span style="color:#e78284">int</span> <span style="color:#8caaee">value</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> c;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>making these methods synchronized has two effects</p>
<ul>
<li> methods on the same object to interleave is impossible, other thread must blocked until executing thread finish</li>
<li>when a synchronized method exits, Object lock auto release(<em>we will talk later</em>), <em>any subsequent invocation</em> of a synchronized method for the same object must get lock before execute which  automatically establishes a happens-before relationship. This guarantees that changes to the state of the object are visible to all threads.</li>
</ul>
<blockquote>
<p>Note:
constructors cannot be synchronized, That&rsquo;s doesn&rsquo;t make sense, only thread creates an Object have access to it while it is being constructed</p></blockquote>
<blockquote>
<p>Note:
When constructing an object that will be shared between threads, be very careful that a reference to the object does not &ldquo;leak&rdquo; prematurely.</p>
<p>if we maintain an List in one thread. which hold all instances, the constructor will look like</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span> <span style="color:#737994;font-style:italic">//...new List</span>
</span></span><span style="display:flex;"><span> instances.<span style="color:#8caaee">add</span>(<span style="color:#ca9ee6">this</span>);
</span></span></code></pre></div><blockquote>
<p>If you do that, other thread can call the instances (this) before the construction finish. Which will cause problem.</p></blockquote>
<p>all reads or writes to that object&rsquo;s variables are done through <code>synchronized</code> methods with one exception <code>final</code> field, which can not modify after constructed, can be safely read through non-synchronized methods</p>
<h4 id="intrinsic-locks">Intrinsic Locks<a class="td-heading-self-link" href="#intrinsic-locks" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>we already know <code>sunchronization</code> is to avoid mem-consist problem , How does that work?</p>
<p>Synchronization is built around an internal entity known as the <em>intrinsic lock</em> or <em>monitor lock</em> (an entity simply as a &ldquo;monitor.&rdquo;) with two job</p>
<ul>
<li>enforcing exclusive access to an object&rsquo;s state</li>
<li>establishing happens-before relationships that are essential to visibility.</li>
</ul>
<p><em><strong>Every object has an intrinsic lock associated with it.</strong></em> when one thread need  exclusive and consistent access to an Object, have to acquire lock and release when finish
There is no chance to get the same lock when other thread own that. The other thread will block when it attempts to acquire the lock.</p>
<blockquote>
<p><em><strong>The lock release occurs even if the return was caused by an uncaught exception.</strong></em></p></blockquote>
<p>we also have static sync method, which is associated with a class, not an object.</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">MyClass</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">int</span> staticField <span style="color:#99d1db;font-weight:bold">=</span> 0;  <span style="color:#737994;font-style:italic">// 静态字段</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> <span style="color:#e78284">int</span> instanceField <span style="color:#99d1db;font-weight:bold">=</span> 0;       <span style="color:#737994;font-style:italic">// 实例字段</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 静态方法，访问静态字段</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">synchronized</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">incrementStaticField</span>() {
</span></span><span style="display:flex;"><span>        staticField<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 实例方法，访问实例字段</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">synchronized</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">incrementInstanceField</span>() {
</span></span><span style="display:flex;"><span>        instanceField<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>the thread acquires the intrinsic lock for the <code>Class</code> object associated with the class, which is different from any instance lock.</p>
<h4 id="synchronized-statements">Synchronized Statements<a class="td-heading-self-link" href="#synchronized-statements" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>Another way to create synchronized code is with <em>synchronized statements</em>.
Unlike synchronized methods, synchronized statements must specify the object that provides the intrinsic lock:</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">addName</span>(String name) {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">synchronized</span>(<span style="color:#ca9ee6">this</span>) {
</span></span><span style="display:flex;"><span>        lastName <span style="color:#99d1db;font-weight:bold">=</span> name;
</span></span><span style="display:flex;"><span>        nameCount<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    nameList.<span style="color:#8caaee">add</span>(name);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In that case, <code>addName</code> has to sync change with lastName and nameCount, but also needs to avoid synchronizing invocations of other objects&rsquo; methods. (this may cause a deadlock, will talk later)</p>
<p> Without synchronized statements, there would have to be a separate, unsynchronized method for the sole purpose of invoking <code>nameList.add</code>.</p>
<p>Synchronized statements are also useful for improving concurrency with fine-grained synchronization.</p>
<p>for example, we have two field c1 and c2, they never used together and we should keep all field sync, there&rsquo;s no reason to prevent an update of c1 from being interleaved with an update of c2, since they wont rely on others.</p>
<p>Instead of using synchronized methods or otherwise using the lock associated with <code>this</code>, we create two objects solely to provide locks.</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">MsLunch</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> <span style="color:#e78284">long</span> c1 <span style="color:#99d1db;font-weight:bold">=</span> 0;
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> <span style="color:#e78284">long</span> c2 <span style="color:#99d1db;font-weight:bold">=</span> 0;
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> Object lock1 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Object();
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> Object lock2 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Object();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">inc1</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">synchronized</span>(lock1) {
</span></span><span style="display:flex;"><span>            c1<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">inc2</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">synchronized</span>(lock2) {
</span></span><span style="display:flex;"><span>            c2<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In that case, two variable can update  interleaved.</p>
<blockquote>
<p>these two objects considered &ldquo;locks&rdquo; not two instences</p></blockquote>
<h4 id="reentrant-synchronization">Reentrant Synchronization<a class="td-heading-self-link" href="#reentrant-synchronization" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>Recall that a thread cannot acquire a lock owned by another thread. But a thread <em>can</em> acquire a lock that it already owns.</p>
<p>Allowing a thread to acquire the same lock more than once enables <em>reentrant synchronization</em>. This describes a situation where synchronized code, directly or indirectly, invokes a method that also contains synchronized code, and both sets of code use the same lock.</p>
<p>Without reentrant synchronization, synchronized code would have to take many additional precautions to avoid having a thread cause itself to block. (dead lock we will talk later)</p>
<blockquote>
<p>next
<a href="/java/basic/concurrent/synchronization/atomic/">atomic</a></p></blockquote>
<p>synchronized 关键字最主要有以下 3 种应用方式：</p>
<ul>
<li>
<p>同步方法，为当前对象加锁，进入同步代码前要获得当前对象的锁；</p>
</li>
<li>
<p>同步静态方法，为当前类加锁，进入同步代码前要获得当前类的锁；</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">AccountingSyncClass</span> <span style="color:#e78284">implements</span> Runnable {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> 0;
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     * 同步静态方法,锁是当前class对象，也就是
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     * AccountingSyncClass类对应的class对象
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">synchronized</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">increase</span>() {
</span></span><span style="display:flex;"><span>        i<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 非静态,访问时锁不一样不会发生互斥</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">synchronized</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">increase4Obj</span>() {
</span></span><span style="display:flex;"><span>        i<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#8caaee;font-weight:bold">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span>(<span style="color:#e78284">int</span> j<span style="color:#99d1db;font-weight:bold">=</span>0;j<span style="color:#99d1db;font-weight:bold">&lt;</span>1000000;j<span style="color:#99d1db;font-weight:bold">++</span>){
</span></span><span style="display:flex;"><span>            increase();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) <span style="color:#e78284">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//new新实例</span>
</span></span><span style="display:flex;"><span>        Thread t1<span style="color:#99d1db;font-weight:bold">=</span><span style="color:#ca9ee6">new</span> Thread(<span style="color:#ca9ee6">new</span> AccountingSyncClass());
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//new新实例</span>
</span></span><span style="display:flex;"><span>        Thread t2<span style="color:#99d1db;font-weight:bold">=</span><span style="color:#ca9ee6">new</span> Thread(<span style="color:#ca9ee6">new</span> AccountingSyncClass());
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//启动线程</span>
</span></span><span style="display:flex;"><span>        t1.<span style="color:#8caaee">start</span>();t2.<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>        t1.<span style="color:#8caaee">join</span>();t2.<span style="color:#8caaee">join</span>();
</span></span><span style="display:flex;"><span>        System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * 输出结果:
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * 2000000
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span>
</span></span></code></pre></div><ul>
<li>同步代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">AccountingSync2</span> <span style="color:#e78284">implements</span> Runnable {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> AccountingSync2 instance <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> AccountingSync2(); <span style="color:#737994;font-style:italic">// 饿汉单例模式</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">int</span> i<span style="color:#99d1db;font-weight:bold">=</span>0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8caaee;font-weight:bold">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//省略其他耗时操作....</span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//使用同步代码块对变量i进行同步操作,锁对象为instance</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">synchronized</span>(instance){
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">for</span>(<span style="color:#e78284">int</span> j<span style="color:#99d1db;font-weight:bold">=</span>0;j<span style="color:#99d1db;font-weight:bold">&lt;</span>1000000;j<span style="color:#99d1db;font-weight:bold">++</span>){
</span></span><span style="display:flex;"><span>                i<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) <span style="color:#e78284">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>        Thread t1<span style="color:#99d1db;font-weight:bold">=</span><span style="color:#ca9ee6">new</span> Thread(instance);
</span></span><span style="display:flex;"><span>        Thread t2<span style="color:#99d1db;font-weight:bold">=</span><span style="color:#ca9ee6">new</span> Thread(instance);
</span></span><span style="display:flex;"><span>        t1.<span style="color:#8caaee">start</span>();t2.<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>        t1.<span style="color:#8caaee">join</span>();t2.<span style="color:#8caaee">join</span>();
</span></span><span style="display:flex;"><span>        System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>这里的锁指的是 Java 内置的隐式锁 monitor 也是 <code>synchronized</code> 封装好的实现
每个对象都有一个对象锁，不同的对象，他们的锁不会互相影响。</p></blockquote>
<blockquote>
<p>synchronized 与 happens before</p>
<p>[[JMM内存模型]]</p></blockquote>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d935226cca7410a10e890a281d87cd7c">1.3.5.1 - atomic</h1>
    <div class="lead">In programming, an atomic action is one that effectively happens all at once.</div>
	<p>In programming, an <em>atomic</em> action is one that effectively happens all at once.</p>
<p><em><strong>it either happens completely, or it doesn&rsquo;t happen at all.</strong></em></p>
<p>some method you can consider as atomic</p>
<ul>
<li>
<p>Reads and writes are atomic for reference variables and for most primitive variables <em><strong>(all types except <code>long</code> and <code>double</code>).</strong></em></p>
</li>
<li>
<p>Reads and writes are atomic for <em>all</em> variables declared <code>volatile</code></p>
</li>
</ul>
<p>Atomic actions cannot be interleaved, so they can be used without fear of thread interference.</p>
<h4 id="volatile-idiom"><code>volatile</code> idiom<a class="td-heading-self-link" href="#volatile-idiom" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>Reads and writes are atomic for <em>all</em> variables declared <code>volatile</code> (include double and long)</p>
<blockquote>
<p>In <strong>most 32-bit and 64-bit processors</strong>, a <code>long</code> or <code>double</code> variable requires <strong>two separate 32-bit reads or writes</strong> to access the full 64-bit value.</p>
<p>As a result, the operation of reading or writing a <code>long</code> or <code>double</code> is not guaranteed to be atomic at the hardware level.</p></blockquote>
<p>Using <code>volatile</code> can reduce the risk of mem-consist, because any write to volatile var will establishes a happen-before relationship with subsequent reads of that same variable</p>
<p>This means that changes to a <code>volatile</code> variable are always visible to other threads.</p>
<p>Using simple atomic variable access is more efficient than accessing these variables through synchronized code</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d84cd7f670a6480268128d704794cf04">1.3.5.2 - Memory Consistency Errors</h1>
    <div class="lead">Memory consistency errors occur when different threads have inconsistent views of what should be the same data.</div>
	<h5 id="what-is-a-memory-consistency-errors">What is a Memory Consistency Errors?<a class="td-heading-self-link" href="#what-is-a-memory-consistency-errors" aria-label="Heading self-link"></a></h5>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p>one of Thread <em><strong>most</strong></em> 3 errors</p></blockquote>
<p>different threads have inconsistent views of what should be the same data</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250307230309089.png" alt="image.png"></p>
<p>The causes of memory consistency errors are complex, Fortunately, we don&rsquo;t have to need a detailed understanding of these causes.</p>
<p>we need a strategy for avoiding them.</p>
<p>The key to avoid MC errors is understanding <code>Happen-before</code> relationship</p>
<h5 id="happen-before"><code>Happen-before</code><a class="td-heading-self-link" href="#happen-before" aria-label="Heading self-link"></a></h5>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>a relationship guarantee memory writes by one specific statement are visible to another specific statement</p>
<p>for our example, Change in Thread A will visible to Thread B</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250307231035238.png" alt="image.png"></p>
<blockquote>
<p>the value will lost, because there&rsquo;s no guarantee that thread A&rsquo;s change to <code>i</code> will be visible to thread B</p></blockquote>
<p>To create a happen-before relation, we can use <a href="content/en/java/Basic/Concurrent/synchronization/_index.md"><code>synchronization</code></a></p>
<p>We already see <code>happen-before</code> relationship</p>
<ul>
<li>
<p><code>Thread.start()</code>
when a statement invoke start(), every statement happen-before the statement also has same relation with new thread&rsquo;s statement</p>
<p>means that the effects of creating new thread are visible</p>
</li>
<li>
<p><code>Thread.join</code>
all the statements executed by the terminated thread have a happens-before relationship with all the statements following the successful join</p>
<p>the effect of terminated thread now visiable to the thread performed join</p>
</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-94fa4a7164aa50dc3f7e72b40ea93cd8">1.3.5.3 - ReadWriteLock</h1>
    <div class="lead">A ReadWriteLock maintains a pair of associated locks, one for read-only operations and one for writing.</div>
	
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-44806d547d596a7ad4a84a926b25d7d0">1.3.5.4 - ReentrantLock重入锁</h1>
    <div class="lead">java.util.concurrent.locks包提供的ReentrantLock用于替代synchronized加锁</div>
	<h4 id="重入性">重入性<a class="td-heading-self-link" href="#%e9%87%8d%e5%85%a5%e6%80%a7" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>重入性指当线程需要再次获取同一把锁时, 不会因为自身而造成死锁, 锁的本质是<strong>作用于代码块或方法</strong>，而不是线程的整个执行上下文。即使线程已经持有锁，进入新的同步方法或代码块时，仍然需要执行<strong>获取锁</strong>的操作，确保锁的计数正确。</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250209113038176.png" alt="image.png"></p>
<p>所以支持重入性应该解决下列问题</p>
<ul>
<li>由于获得多次相同的锁, 需要计数以释放相同次数</li>
<li>相同线程再次获取锁应当直接成功, 防止死锁</li>
</ul>
<h4 id="为什么需要reentrantlock">为什么需要<code>ReentrantLock</code><a class="td-heading-self-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81reentrantlock" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>Java语言直接提供了<code>synchronized</code>关键字用于加锁，但这种锁一是很重，二是获取时必须一直等待，没有额外的尝试机制。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#ca9ee6">if</span> (lock.<span style="color:#8caaee">tryLock</span>(1, TimeUnit.<span style="color:#8caaee">SECONDS</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">try</span> {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    } <span style="color:#ca9ee6">finally</span> {
</span></span><span style="display:flex;"><span>        lock.<span style="color:#8caaee">unlock</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>java.util.concurrent.locks</code>包提供的<code>ReentrantLock</code>用于替代<code>synchronized</code>加锁</p>
<p>尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，<code>tryLock()</code>返回<code>false</code>，程序就可以做一些额外处理，而不是无限等待下去。</p>
<p>所以，使用<code>ReentrantLock</code>比直接使用<code>synchronized</code>更安全，线程在<code>tryLock()</code>失败的时候不会导致死锁。</p>
<h1 id="reentrantlock使用">ReentrantLock使用<a class="td-heading-self-link" href="#reentrantlock%e4%bd%bf%e7%94%a8" aria-label="Heading self-link"></a></h1>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">Counter</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//和关键字不同, 需要获得一个重入锁对象</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> <span style="color:#e78284">final</span> Lock lock <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> ReentrantLock();
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> <span style="color:#e78284">int</span> count;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">add</span>(<span style="color:#e78284">int</span> n) {
</span></span><span style="display:flex;"><span>		<span style="color:#737994;font-style:italic">//代码块加锁</span>
</span></span><span style="display:flex;"><span>        lock.<span style="color:#8caaee">lock</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">try</span> {
</span></span><span style="display:flex;"><span>            count <span style="color:#99d1db;font-weight:bold">+=</span> n;
</span></span><span style="display:flex;"><span>        } <span style="color:#ca9ee6">finally</span> {
</span></span><span style="display:flex;"><span>	        <span style="color:#737994;font-style:italic">//在finally中解锁</span>
</span></span><span style="display:flex;"><span>            lock.<span style="color:#8caaee">unlock</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-0671a42570c837d9b5dcad4457bbd242">1.3.6 - Thread Objects</h1>
    
	<p>内容来源:</p>
<ul>
<li>沉默王二 GitHub 上开源的知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">Java 进阶之路</a>》</li>
<li><a href="https://javaguide.cn/java/concurrent/">JavaGuide</a></li>
<li><a href="https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg">CLH锁 - Quner技术沙龙</a></li>
<li>操作系统 - 西电出版</li>
</ul>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f8f1cf0a2ad572348931a0a3261648c0">1.3.6.1 - 多线程入门</h1>
    <div class="lead">并发编程入口</div>
	<h4 id="为什么要实现多线程">为什么要实现多线程?<a class="td-heading-self-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%ae%9e%e7%8e%b0%e5%a4%9a%e7%ba%bf%e7%a8%8b" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p><a href="/java/basic/concurrent/threadobjects/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/">线程与进程</a></p></blockquote>
<p>进程使得操作系统可以<a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7.md">并发</a>的执行任务
但是在一段时间内单个进程只能执行一个任务
进程内的子任务只能逐个按顺序执行, 效率还有提升空间</p>
<p>因此提出线程概念, 使得一个线程可以执行一个子任务使得进程内部也可实现并发, 提高效率</p>
<blockquote>
<p>多线程的优势</p>
<ul>
<li>
<p>进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信很容易。</p>
</li>
<li>
<p>进程是重量级的，而线程是轻量级的，多线程方式的系统开销更小。</p>
</li>
</ul></blockquote>
<p>Java中创建线程的三种方式</p>
<h4 id="继承-thread-类">继承 <code>Thread</code> 类<a class="td-heading-self-link" href="#%e7%bb%a7%e6%89%bf-thread-%e7%b1%bb" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>重写 <code>run</code> 方法</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">MyThread</span> <span style="color:#e78284">extends</span> Thread {
</span></span><span style="display:flex;"><span>    <span style="color:#8caaee;font-weight:bold">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> 0; i <span style="color:#99d1db;font-weight:bold">&lt;</span> 100; i<span style="color:#99d1db;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(getName() <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;:打了&#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> i <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;个小兵&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>主函数启动线程</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//创建MyThread对象</span>
</span></span><span style="display:flex;"><span>MyThread t1<span style="color:#99d1db;font-weight:bold">=</span><span style="color:#ca9ee6">new</span> MyThread();
</span></span><span style="display:flex;"><span>MyThread t2<span style="color:#99d1db;font-weight:bold">=</span><span style="color:#ca9ee6">new</span> MyThread();
</span></span><span style="display:flex;"><span>MyThread t3<span style="color:#99d1db;font-weight:bold">=</span><span style="color:#ca9ee6">new</span> MyThread();
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//设置线程的名字</span>
</span></span><span style="display:flex;"><span>t1.<span style="color:#8caaee">setName</span>(<span style="color:#a6d189">&#34;鲁班&#34;</span>);
</span></span><span style="display:flex;"><span>t2.<span style="color:#8caaee">setName</span>(<span style="color:#a6d189">&#34;刘备&#34;</span>);
</span></span><span style="display:flex;"><span>t3.<span style="color:#8caaee">setName</span>(<span style="color:#a6d189">&#34;亚瑟&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//启动线程</span>
</span></span><span style="display:flex;"><span>t1.<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>t2.<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>t3.<span style="color:#8caaee">start</span>();
</span></span></code></pre></div><h4 id="实现-runnable-接口">实现 <code>Runnable</code> 接口<a class="td-heading-self-link" href="#%e5%ae%9e%e7%8e%b0-runnable-%e6%8e%a5%e5%8f%a3" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>创建任务类实现 <code>Runnable</code> 接口</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">MyRunnable</span> <span style="color:#e78284">implements</span> Runnable {
</span></span><span style="display:flex;"><span>    <span style="color:#8caaee;font-weight:bold">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> 0; i <span style="color:#99d1db;font-weight:bold">&lt;</span> 10; i<span style="color:#99d1db;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">try</span> {<span style="color:#737994;font-style:italic">//sleep会发生异常要显式处理</span>
</span></span><span style="display:flex;"><span>                Thread.<span style="color:#8caaee">sleep</span>(20);<span style="color:#737994;font-style:italic">//暂停20毫秒</span>
</span></span><span style="display:flex;"><span>            } <span style="color:#ca9ee6">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                e.<span style="color:#8caaee">printStackTrace</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(Thread.<span style="color:#8caaee">currentThread</span>().<span style="color:#8caaee">getName</span>() <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;打了:&#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> i <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;个小兵&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>主函数启动线程</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//创建MyRunnable类</span>
</span></span><span style="display:flex;"><span>MyRunnable mr <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> MyRunnable();
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//创建Thread类的有参构造,并设置线程名</span>
</span></span><span style="display:flex;"><span>Thread t1 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Thread(mr, <span style="color:#a6d189">&#34;张飞&#34;</span>);
</span></span><span style="display:flex;"><span>Thread t2 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Thread(mr, <span style="color:#a6d189">&#34;貂蝉&#34;</span>);
</span></span><span style="display:flex;"><span>Thread t3 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Thread(mr, <span style="color:#a6d189">&#34;吕布&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//启动线程</span>
</span></span><span style="display:flex;"><span>t1.<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>t2.<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>t3.<span style="color:#8caaee">start</span>();
</span></span></code></pre></div><h4 id="实现-callable-接口">实现 <code>Callable&lt;&gt;</code> 接口<a class="td-heading-self-link" href="#%e5%ae%9e%e7%8e%b0-callable-%e6%8e%a5%e5%8f%a3" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p>相较于 <code>Runnable</code> 接口
<code>callable&lt;&gt;</code> 可以获取线程的执行结果, 使用 <code>FutureTask</code> 类存储
了解 [[获取线程执行结果]]</p></blockquote>
<p>重写 <code>call&lt;&gt;</code> 方法</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">CallerTask</span> <span style="color:#e78284">implements</span> Callable<span style="color:#99d1db;font-weight:bold">&lt;</span>String<span style="color:#99d1db;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#e78284">public</span> String <span style="color:#8caaee">call</span>() <span style="color:#e78284">throws</span> Exception {
</span></span><span style="display:flex;"><span>       <span style="color:#ca9ee6">return</span> <span style="color:#a6d189">&#34;Hello,i am running!&#34;</span>;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>主函数启动线程</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//创建异步任务</span>
</span></span><span style="display:flex;"><span>        FutureTask<span style="color:#99d1db;font-weight:bold">&lt;</span>String<span style="color:#99d1db;font-weight:bold">&gt;</span> task<span style="color:#99d1db;font-weight:bold">=</span><span style="color:#ca9ee6">new</span> FutureTask<span style="color:#99d1db;font-weight:bold">&lt;</span>String<span style="color:#99d1db;font-weight:bold">&gt;</span>(<span style="color:#ca9ee6">new</span> CallerTask());
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//启动线程</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">new</span> Thread(task).<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">//等待执行完成，并获取返回结果</span>
</span></span><span style="display:flex;"><span>            String result<span style="color:#99d1db;font-weight:bold">=</span>task.<span style="color:#8caaee">get</span>();
</span></span><span style="display:flex;"><span>            System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(result);
</span></span><span style="display:flex;"><span>        } <span style="color:#ca9ee6">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>            e.<span style="color:#8caaee">printStackTrace</span>();
</span></span><span style="display:flex;"><span>        } <span style="color:#ca9ee6">catch</span> (ExecutionException e) {
</span></span><span style="display:flex;"><span>            e.<span style="color:#8caaee">printStackTrace</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-692ec2134d8731bfeb7329215f96d964">1.3.6.2 - 线程</h1>
    <div class="lead">线程，是进程的子任务，是 CPU 调度和分派的基本单位，实现了进程内部的并发。</div>
	<p>进程
说简单点就是我们在电脑上启动的一个个应用。它是操作系统分配资源的最小单位。</p>
<p>线程
是进程的子任务，是 CPU 调度和分派的基本单位，实现了进程内部的并发。</p>
<h4 id="线程与进程">线程与进程<a class="td-heading-self-link" href="#%e7%ba%bf%e7%a8%8b%e4%b8%8e%e8%bf%9b%e7%a8%8b" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>线程，是进程的子任务，是进程中的独立执行单元。多个线程可以共享同一个进程的资源，如内存；每个线程都有自己独立的栈和寄存器。</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205083709918.png" alt="image.png"></p>
<p>并发环境下, 多线程存在下述问题</p>
<ol>
<li>线程之间如何确保执行顺序,实现线程之间的协调与合作? 线程通信</li>
<li>线程之间如何确保对临界资源修改不会冲突? 线程同步?</li>
</ol>
<h4 id="线程通信"><a href="%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1.md">线程通信</a><a class="td-heading-self-link" href="#%e7%ba%bf%e7%a8%8b%e9%80%9a%e4%bf%a1" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p><em>Inter-thread communication in Java is a mechanism in which a thread is paused running in its critical section and another thread is allowed to enter (or lock) in the same critical section to be executed.</em></p>
<p><strong>线程间通信</strong>
是一种机制，使得线程能够在执行时进行协作，通常用于解决某些线程需要等待其他线程完成任务的情况。它主要涉及线程之间的等待和通知机制，而不是同一临界区内的互斥访问。</p></blockquote>
<h4 id="线程同步">线程同步<a class="td-heading-self-link" href="#%e7%ba%bf%e7%a8%8b%e5%90%8c%e6%ad%a5" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p><strong>Synchronization</strong> is crucial for ensuring that multiple threads operate safely on shared resources. Without *<strong>Synchronization</strong>, data inconsistency or corruption can occur when multiple threads try to access and modify shared variables simultaneously. In Java, it is a mechanism that ensures that only one thread can access a resource at any given time</p>
<p>线程同步的重点是 <strong>保证线程安全</strong>，特别是在多个线程访问共享资源时。同步机制通过确保某个共享资源在同一时刻只能被一个线程访问来防止数据不一致或冲突。Java 中的 <code>synchronized</code> 关键字和 <code>ReentrantLock</code> 都是同步机制的实现，确保线程在访问共享资源时不会发生并发冲突。</p></blockquote>
<p>解决上述问题的方式有两种</p>
<ol>
<li>共享内存</li>
<li>消息传递</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205093046393.png" alt="image.png"></p>
<p>Java 使用共享内存的并发模型实现线程同步与通信, 这个模型称之为 <a href="JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.md">JMM</a>
JMM 决定了一个线程对共享变量的写入何时对另外一个线程可见。</p>
<p>引用:
<a href="https://www.geeksforgeeks.org/inter-thread-communication-java/">Geekfork</a></p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-20bf6e765d72459a6752c379a8afe938">1.3.6.3 - 线程生命周期</h1>
    <div class="lead">操作系统中的线程状态转换</div>
	<p>Java的线程分为两类, 用户线程和守护线程</p>
<p>线程调度就是线程不同状态间的转换</p>
<p>在<a href="%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2.md">操作系统</a>中，线程被视为轻量级的进程，所以<strong>线程状态其实和进程状态是一致的</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205105116917.png" alt="image.png"></p>
<p>Java线程有如下状态</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// Thread.State 源码</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">enum</span> State {
</span></span><span style="display:flex;"><span>    NEW,
</span></span><span style="display:flex;"><span>    RUNNABLE,
</span></span><span style="display:flex;"><span>    BLOCKED,
</span></span><span style="display:flex;"><span>    WAITING,
</span></span><span style="display:flex;"><span>    TIMED_WAITING,
</span></span><span style="display:flex;"><span>    TERMINATED;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="new">NEW<a class="td-heading-self-link" href="#new" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>处于 NEW 状态的线程是刚创建 <code>Thread</code> 而尚未启动。这里的尚未启动指的是还没调用 Thread 实例的<code>start()</code>方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">private</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">testStateNew</span>() {
</span></span><span style="display:flex;"><span>    Thread thread <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Thread(() <span style="color:#99d1db;font-weight:bold">-&gt;</span> {});
</span></span><span style="display:flex;"><span>    System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(thread.<span style="color:#8caaee">getState</span>()); <span style="color:#737994;font-style:italic">// 输出 NEW</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="runnable">RUNNABLE<a class="td-heading-self-link" href="#runnable" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>线程启动之后的状态</p>
<p>call <code>thread.start()</code> will Causes this thread to begin execution; the Java Virtual Machine calls the <code>run</code> method of this thread.</p>
<p>The result is that two threads are running concurrently: the current thread (which returns from the call to the <code>start</code> method) and the other thread (which executes its <code>run</code> method).</p>
<p>当前线程正在运行中。处于 RUNNABLE 状态的线程在 Java 虚拟机中运行</p>
<p>It is never legal to start a thread more than once. In particular, a thread may not be restarted once it has completed execution.</p>
<p>when recall a RUNNABLE thread, an <code>IllegalThreadStateException</code> will throwed if the thread was already started.</p>
<p>Java 线程的<strong>RUNNABLE</strong>状态其实包括了操作系统线程的<strong>ready</strong>和<strong>running</strong>两个状态。</p>
<h4 id="block">BLOCK<a class="td-heading-self-link" href="#block" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>阻塞状态。处于 BLOCKED 状态的线程正等待锁（锁会在后面细讲）的释放以进入同步区。</p>
<h4 id="waiting">WAITING<a class="td-heading-self-link" href="#waiting" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>等待状态。处于等待状态的线程变成 RUNNABLE 状态需要其他线程唤醒。</p>
<ul>
<li><code>Object.wait()</code>：使当前线程处于等待状态直到另一个线程唤醒它</li>
<li><code>Thread.join()</code>：等待线程执行完毕，底层调用的是 Object 的 wait 方法,等待期间可以通过<code>Object.notify()</code>/<code>notifyAll()/Locksupport.unpark()</code>唤醒</li>
<li><code>LockSupport.park()</code>：除非获得调用许可，否则禁用当前线程进行线程调度</li>
</ul>
<h4 id="timed_waiting">TIMED_WAITING<a class="td-heading-self-link" href="#timed_waiting" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。</p>
<p>调用如下方法会使线程进入超时等待状态：</p>
<ul>
<li>
<p><code>Thread.sleep(long millis)</code>：使当前线程睡眠指定时间</p>
</li>
<li>
<p><code>Object.wait(long timeout)</code>：线程休眠指定时间，等待期间可以通过<code>Object.notify()</code>/<code>notifyAll()/Locksupport.unpark()</code>唤醒</p>
</li>
<li>
<p><code>Thread.join(long millis)</code>：等待当前线程最多执行 millis 毫秒，如果 millis 为 0，则会一直执行</p>
</li>
<li>
<p><code>LockSupport.parkNanos(long nanos)</code>： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间</p>
</li>
<li>
<p><code>LockSupport.parkUntil(long deadline)</code>：同上，也是禁止线程进行调度指定时间；</p>
</li>
</ul>
<h4 id="terminated">TERMINATED<a class="td-heading-self-link" href="#terminated" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>终止状态</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205111919918.png" alt="image.png"></p>
<h4 id="调度方法">调度方法<a class="td-heading-self-link" href="#%e8%b0%83%e5%ba%a6%e6%96%b9%e6%b3%95" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250205130951244.png" alt="image.png"></p>
<h5 id="等待与通知">等待与通知<a class="td-heading-self-link" href="#%e7%ad%89%e5%be%85%e4%b8%8e%e9%80%9a%e7%9f%a5" aria-label="Heading self-link"></a></h5>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><ol>
<li><code>Object.wait()</code>
调用<code>wait()</code>方法前线程必须持有对象的锁。</li>
</ol>
<p>线程调用<code>wait()</code>方法时，会释放当前的锁，直到有其他线程调用<code>notify()</code>/<code>notifyAll()</code>方法唤醒等待锁的线程。</p>
<p>需要注意的是，其他线程调用<code>notify()</code>方法只会唤醒单个等待锁的线程，如有有多个线程都在等待这个锁的话不一定会唤醒到之前调用<code>wait()</code>方法的线程。</p>
<p>同样，调用<code>notifyAll()</code>方法唤醒所有等待锁的线程之后，也不一定会马上把时间片分给刚才放弃锁的那个线程，具体要看系统的调度。</p>
<ol start="2">
<li><code>Object.wait(long)</code>/<code>Object.wait(long, int)</code></li>
</ol>
<p><code>wait(long)</code>方法使线程进入 TIMED_WAITING 状态。这里的<code>wait(long)</code>方法与无参方法 wait()相同的地方是，都可以通过其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法来唤醒。</p>
<p>不同的地方是，有参方法<code>wait(long)</code>就算其他线程不来唤醒它，经过指定时间 long 之后它会自动唤醒，拥有去争夺锁的资格。</p>
<ol start="3">
<li><code>Thread.join()</code></li>
</ol>
<p>调用<code>join()</code>方法，会一直等待这个线程执行完毕（转换为 TERMINATED 状态）。</p>
<h5 id="休眠">休眠<a class="td-heading-self-link" href="#%e4%bc%91%e7%9c%a0" aria-label="Heading self-link"></a></h5>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><ol>
<li><code>Thread.sleep(long)</code></li>
</ol>
<p>使当前线程睡眠指定时间。需要注意这里的“睡眠”只是暂时使线程停止执行，并不会释放锁。时间到后，线程会重新进入 RUNNABLE 状态。</p>
<h5 id="让出执行权">让出执行权<a class="td-heading-self-link" href="#%e8%ae%a9%e5%87%ba%e6%89%a7%e8%a1%8c%e6%9d%83" aria-label="Heading self-link"></a></h5>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p><code>yield()</code>：Thread 类中的静态方法，当一个线程调用 yield 方法时，实际是在暗示线程调度器，当前线程请求让出自己的 CPU，但是线程调度器可能会“装看不见”忽略这个暗示。</p>
<h5 id="中断">中断<a class="td-heading-self-link" href="#%e4%b8%ad%e6%96%ad" aria-label="Heading self-link"></a></h5>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>中断（Interrupt）一个线程意味着在该线程完成任务之前停止其正在进行的一切，有效地中止其当前的操作。线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序。</p>
<p>那么，我们究竟应该如何停止线程呢？</p>
<ul>
<li>1、任务中一般都会有循环结构，只要用一个标记控制住循环，就可以结束任务。</li>
<li>2、如果线程处于了<code>冻结状态</code>，无法读取标记，此时可以使用<code>interrupt()</code>方法将线程<code>从冻结状态强制恢复到运行状态中</code>来，让线程具备CPU的执行资格。</li>
</ul>
<p><code>Thread.interrupt(long)</code></p>
<p>作用是中断阻塞的线程。将会设置线程中断为true，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。
线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为true）。
<em><strong>该方法只是改变中断状态，不会中断一个正在运行的线程。</strong></em></p>
<p>因为该方法并不执行中断, 只是指示线程中断因此用户需要监视线程的执行结果来判断下一步操作
比如抛出interruptedException的方法, 监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常, 从而指示阻塞线程退出阻塞</p>
<blockquote>
<p>引用:
<a href="https://www.cnblogs.com/myseries/p/10918819.html">博客园</a></p></blockquote>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d582c66e48e4720cfdedf3b426a00eb9">1.3.7 - ThreadLocal</h1>
    <div class="lead">ThreadLocal 是Java中 lang 包下的一个类，是用来解决多线程下共享变量并发问题的，所谓共享变量即同一个变量在不同线程下赋予不同值, 而ThreadLocal会在不同线程中维护共享变量的独立副本</div>
	<blockquote>
<p>前置
<a href="/java/basic/concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a></p></blockquote>
<p>是 Java 中提供的一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离，用于解决多线程中共享对象的线程安全问题。</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210182243836.png" alt="image.png"></p>
<p>使用:</p>
<p>创建 ThreadLocal对象</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//创建一个ThreadLocal变量</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">static</span> ThreadLocal<span style="color:#99d1db;font-weight:bold">&lt;</span>String<span style="color:#99d1db;font-weight:bold">&gt;</span> localVariable <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> ThreadLocal<span style="color:#99d1db;font-weight:bold">&lt;&gt;</span>();
</span></span></code></pre></div><p>设置值</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//设置ThreadLocal变量的值 localVariable.set(&#34;0001&#34;);</span>
</span></span></code></pre></div><p>获取值</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//获取ThreadLocal变量的值 String value = localVariable.get();</span>
</span></span></code></pre></div><p>优点</p>
<ol>
<li>
<p>线程隔离
实现了变量的独占, 使变量不需要同步处理</p>
</li>
<li>
<p>数据传递方便
ThreadLocal 常用于在跨方法、跨类时传递上下文数据（如用户信息等），而不需要在方法间传递参数。</p>
</li>
</ol>
<h4 id="threadlocalmap"><code>ThreadLocalMap</code><a class="td-heading-self-link" href="#threadlocalmap" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>ThreadLocalMap, 一个key-value数据形式结构，也是ThreadLocal的核心。</p>
<p>Map内部维护了一个Entry数组, 真正的数据存储在 Entry中, map的key是每个线程中ThreadLocal对象的哈希, value是隔离变量</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * 初始容量
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> <span style="color:#e78284">int</span> INITIAL_CAPACITY <span style="color:#99d1db;font-weight:bold">=</span> 16;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * ThreadLocalMap数据真正存储在table中
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">private</span> Entry<span style="color:#99d1db;font-weight:bold">[]</span> table;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * ThreadLocalMap条数
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">private</span> <span style="color:#e78284">int</span> size <span style="color:#99d1db;font-weight:bold">=</span> 0;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * 达到这个大小，则扩容
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">private</span> <span style="color:#e78284">int</span> threshold; <span style="color:#737994;font-style:italic">// 默认为0</span>
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210192010058.png" alt="image.png"></p>
<p>为了保证Entry[] 数组散步均匀, 哈希算法如下</p>
<p>把对应的 key 映射到 table 数组的相应下标，ThreadLocalMap 用的是哈希取余法，取出 key 的 threadLocalHashCode，然后和 table 数组长度减一&amp;运算（相当于取余）。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> key.<span style="color:#8caaee">threadLocalHashCode</span> <span style="color:#99d1db;font-weight:bold">&amp;</span> (table.<span style="color:#8caaee">length</span> <span style="color:#99d1db;font-weight:bold">-</span> 1);
</span></span></code></pre></div><p>这里的hashcode由魔术数生成
每创建一个 ThreadLocal 对象，它就会新增<code>0x61c88647</code>，这个值很特殊，它是<strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong>。<code>hash</code>增量为 这个数字，带来的好处就是 <code>hash</code> <strong>分布非常均匀</strong>。</p>
<h4 id="inheritablethreadlocal"><code>InheritableThreadLocal()</code><a class="td-heading-self-link" href="#inheritablethreadlocal" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>父子线程是无法传输数据的, 但是通过InheritableThreadLocal实例就可以在子线程拿到值</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">InheritableThreadLocalTest</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">final</span> ThreadLocal threadLocal <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> InheritableThreadLocal();
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 主线程</span>
</span></span><span style="display:flex;"><span>        threadLocal.<span style="color:#8caaee">set</span>(<span style="color:#a6d189">&#34;父线程&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//子线程</span>
</span></span><span style="display:flex;"><span>        Thread t <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Thread() {
</span></span><span style="display:flex;"><span>            <span style="color:#8caaee;font-weight:bold">@Override</span>
</span></span><span style="display:flex;"><span>            <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">run</span>() {
</span></span><span style="display:flex;"><span>                <span style="color:#e78284">super</span>.<span style="color:#8caaee">run</span>();
</span></span><span style="display:flex;"><span>                System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(<span style="color:#a6d189">&#34;子线程 ，&#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> threadLocal.<span style="color:#8caaee">get</span>());
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        t.<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>原理:</p>
<p>在Thread中有一个变量</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ThreadLocal.<span style="color:#8caaee">ThreadLocalMap</span> inheritableThreadLocals <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ef9f76">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">if</span> (inheritThreadLocals <span style="color:#99d1db;font-weight:bold">&amp;&amp;</span> parent.<span style="color:#8caaee">inheritableThreadLocals</span> <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">this</span>.<span style="color:#8caaee">inheritableThreadLocals</span> <span style="color:#99d1db;font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>        ThreadLocal.<span style="color:#8caaee">createInheritedMap</span>(parent.<span style="color:#8caaee">inheritableThreadLocals</span>);
</span></span></code></pre></div><p>在 Thread.init 的时候，如果父线程的<code>inheritableThreadLocals</code>不为空，就把它赋给当前线程（子线程）的<code>inheritableThreadLocals</code> 。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9cf457bfa828c8ced5473d3530c729ed">1.3.8 - volatile关键字</h1>
    <div class="lead">volatile 可以保证可见性，但不保证原子性：当写一个 volatile 变量时，JMM 会把该线程在本地内存中的变量强制刷新到主内存中去；这个写操作会导致其他线程中的 volatile 变量缓存无效。</div>
	<h4 id="什么是-volatile">什么是 <code>volatile</code><a class="td-heading-self-link" href="#%e4%bb%80%e4%b9%88%e6%98%af-volatile" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><h4 id="为什么要使用-volatile">为什么要使用 <code>volatile</code><a class="td-heading-self-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8-volatile" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p>[[线程安全问题]]</p></blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-715da0d04d4983431cda607d9e28d8de">1.3.9 - 线程池</h1>
    <div class="lead">池化技术的核心思想就是实现资源的复用，避免资源的重复创建和销毁带来的性能开销。</div>
	<h4 id="什么是线程池">什么是线程池<a class="td-heading-self-link" href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%bf%e7%a8%8b%e6%b1%a0" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>线程池(ThreadPool) 是一种基于池化思想管理线程的工具</p>
<p>线程池解决的问题是, 在任意时刻下, 确定系统应该投入多少资源, 解决多少任务</p>
<p>不将线程统一管理可能会出现以下问题</p>
<ol>
<li>频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li>
<li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li>
<li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li>
</ol>
<p>为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210102309459.png" alt="image.png"></p>
<p>线程池内部维护了许多线程, 当有新任务时就会分配一个空闲线程执行
当所有线程都有任务时, 新的任务要么放到阻塞队列里面要么增加线程</p>
<h4 id="使用线程池">使用线程池<a class="td-heading-self-link" href="#%e4%bd%bf%e7%94%a8%e7%ba%bf%e7%a8%8b%e6%b1%a0" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>用法:</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// 创建固定大小的线程池:</span>
</span></span><span style="display:flex;"><span>ExecutorService executor <span style="color:#99d1db;font-weight:bold">=</span> Executors.<span style="color:#8caaee">newFixedThreadPool</span>(3);
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// 提交任务:</span>
</span></span><span style="display:flex;"><span>executor.<span style="color:#8caaee">submit</span>(task1);
</span></span><span style="display:flex;"><span>executor.<span style="color:#8caaee">submit</span>(task2);
</span></span><span style="display:flex;"><span>executor.<span style="color:#8caaee">submit</span>(task3);
</span></span><span style="display:flex;"><span>executor.<span style="color:#8caaee">submit</span>(task4);
</span></span><span style="display:flex;"><span>executor.<span style="color:#8caaee">submit</span>(task5);
</span></span></code></pre></div><p>上述代码创建了大小为3的线程池, 并提交了5个任务</p>
<p><code>ExecutorService</code>该接口要求实现工厂方法, 返回如下类型的线程池</p>
<ul>
<li>FixedThreadPool：线程数固定的线程池；</li>
<li>CachedThreadPool：线程数根据任务动态调整的线程池；</li>
<li>ScheduledThreadPool:  定时执行线程池</li>
<li>SingleThreadExecutor：仅单线程执行的线程池。</li>
</ul>
<h4 id="线程池原理解析">线程池原理解析<a class="td-heading-self-link" href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e5%8e%9f%e7%90%86%e8%a7%a3%e6%9e%90" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>Java的线程池核心实现为 <code>ThreadPoolExecutor</code></p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210180713994.png" alt="image.png"></p>
<p>顶级接口 <code>Excutor</code> 提供了一种思想, 将任务提交与任务执行解耦
用户只需提供 <code>Runnable</code> 对像, 将任务提交到执行器中, 剩余的线程调配和任务执行由执行器完成</p>
<p>ExecutorService接口增加了一些能力：
（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。</p>
<p>线程池构造类 <code>ThreadPoolExecutor</code>
通过传入参数实现线程池的构造
如下是成员变量,
![[content/en/java/Basic/Concurrent/Pasted image 20250203123133.png]]
参数解释</p>
<ul>
<li><code>corePoolSize</code>：线程池中用来工作的核心线程数量。</li>
<li><code>maximumPoolSize</code>：最大线程数，线程池允许创建的最大线程数, 可以理解为非核心线程 + 核心线程数</li>
<li><code>workQueue</code>：任务队列，是一个阻塞队列，当线程数达到核心线程数后，会将任务存储在阻塞队列中。</li>
<li><code>threadFactory</code> ：线程池内部创建线程所用的工厂。</li>
<li><code>handler</code>：拒绝策略；当队列已满并且线程数量达到最大线程数量时，会调用该方法处理任务</li>
</ul>
<blockquote>
<p>线程池使用前记得初始化</p></blockquote>
<p>线程池的默认策略是构造完成后不创建线程, 也就是说刚创建好的线程池是没有线程的, 只有传入的 <code>BlockingQueue</code> 也就是[[阻塞队列]] 和其他参数
![[content/en/java/Basic/Concurrent/Pasted image 20250203123400.png]]
使用线程池之后
当调用任务执行方法 <code>execute()</code> 时启动执行流程
线程执行任务流程如下</p>
<ul>
<li><strong>核心线程数未满</strong>：直接创建新线程执行任务（<strong>不会进队列</strong>）。</li>
<li><strong>核心线程数已满</strong>，<strong>队列未满</strong>：任务进入阻塞队列等待空闲线程执行。</li>
<li><strong>核心线程数已满</strong>，<strong>队列已满</strong>：
<ul>
<li><strong>如果当前线程池线程数未达到最大线程数</strong>，创建非核心线程执行任务。</li>
<li><strong>否则，执行拒绝策略</strong>。</li>
</ul>
</li>
</ul>
<p>队列未满, 创建核心线程</p>
<p>![[content/en/java/Basic/Concurrent/Pasted image 20250203123742.png]]
队列已满, 创建非核心线程![[content/en/java/Basic/Concurrent/Pasted image 20250203124516.png]]</p>
<blockquote>
<p>所以，就算队列中已经塞满了任务，新创建的线程还是会优先处理提交的任务，而不是从队列中获取已有的任务执行，<strong>从这可以看出，先提交的任务不一定先执行</strong>。</p></blockquote>
<p>当上述流程无法完成时, 会使用拒绝策略抛出异常
JDK 自带的 <code>RejectedExecutionHandler</code> 实现有 4 种</p>
<ul>
<li>AbortPolicy：丢弃任务，抛出运行时异常</li>
<li>CallerRunsPolicy：由提交任务的线程来执行任务</li>
<li>DiscardPolicy：丢弃这个任务，但是不抛异常</li>
<li>DiscardOldestPolicy：从队列中剔除最先进入队列的任务，然后再次提交任务</li>
</ul>
<p>任务执行方法 <code>excute()</code>
源码如下</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">execute</span>(Runnable command) {
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 首先检查提交的任务是否为null，是的话则抛出NullPointerException。</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (command <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">throw</span> <span style="color:#ca9ee6">new</span> NullPointerException();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 获取线程池的当前状态（ctl是一个AtomicInteger，其中包含了线程池状态和工作线程数）</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> c <span style="color:#99d1db;font-weight:bold">=</span> ctl.<span style="color:#8caaee">get</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 1. 检查当前运行的工作线程数是否少于核心线程数（corePoolSize）</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (workerCountOf(c) <span style="color:#99d1db;font-weight:bold">&lt;</span> corePoolSize) {
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 如果少于核心线程数，尝试添加一个新的工作线程来执行提交的任务</span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// addWorker方法会检查线程池状态和工作线程数，并决定是否真的添加新线程</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (addWorker(command, <span style="color:#ef9f76">true</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">return</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 重新获取线程池的状态，因为在尝试添加线程的过程中线程池的状态可能已经发生变化</span>
</span></span><span style="display:flex;"><span>        c <span style="color:#99d1db;font-weight:bold">=</span> ctl.<span style="color:#8caaee">get</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 2. 尝试将任务添加到任务队列中</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (isRunning(c) <span style="color:#99d1db;font-weight:bold">&amp;&amp;</span> workQueue.<span style="color:#8caaee">offer</span>(command)) {
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">int</span> recheck <span style="color:#99d1db;font-weight:bold">=</span> ctl.<span style="color:#8caaee">get</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 双重检查线程池的状态</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (<span style="color:#99d1db;font-weight:bold">!</span> isRunning(recheck) <span style="color:#99d1db;font-weight:bold">&amp;&amp;</span> remove(command))  <span style="color:#737994;font-style:italic">// 如果线程池已经停止，从队列中移除任务</span>
</span></span><span style="display:flex;"><span>            reject(command);
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 如果线程池正在运行，但是工作线程数为0，尝试添加一个新的工作线程</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">else</span> <span style="color:#ca9ee6">if</span> (workerCountOf(recheck) <span style="color:#99d1db;font-weight:bold">==</span> 0)
</span></span><span style="display:flex;"><span>            addWorker(<span style="color:#ef9f76">null</span>, <span style="color:#ef9f76">false</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 3. 如果任务队列满了，尝试添加一个新的非核心工作线程来执行任务</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">else</span> <span style="color:#ca9ee6">if</span> (<span style="color:#99d1db;font-weight:bold">!</span>addWorker(command, <span style="color:#ef9f76">false</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 如果无法添加新的工作线程（可能因为线程池已经停止或者达到最大线程数限制），则拒绝任务</span>
</span></span><span style="display:flex;"><span>        reject(command);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f678f50588596c85cbf389be75259a81">1.3.10 - 自旋锁与CLH锁</h1>
    <div class="lead">AQS 类的核心数据结构是一种名为 <code>Craig, Landin, and Hagersten locks</code>（下称 CLH 锁）的变体。</div>
	<p>在并发编程中，锁是一种常用的保证线程安全的方法。</p>
<p>Java 中常用的锁主要有两类，一种是关键字 <a href="content/en/java/Basic/Concurrent/synchronization/_index.md">_index</a> ，被称为 Java 内置锁或监视器锁。</p>
<p>另一种就是在 J2SE 1.5版本之后的 java.util.concurrent包（下称j.u.c包）中的各类同步器</p>
<blockquote>
<p>包括 ReentrantLock（可重入锁），ReentrantReadWriteLock（可重入读写锁），Semaphore（信号量），CountDownLatch 等</p></blockquote>
<p>这些同步器都是基于 AbstractQueuedSynchronizer（下称 AQS）这个简单的框架来构建的</p>
<p>AQS 类的核心数据结构是一种名为 <code>Craig, Landin, and Hagersten locks</code>（下称 CLH 锁）的变体。</p>
<p>CLH锁是自旋锁的一种改良</p>
<h4 id="自旋锁">自旋锁<a class="td-heading-self-link" href="#%e8%87%aa%e6%97%8b%e9%94%81" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>自旋锁是互斥锁的一种实现, 用于保证线程间正确互斥</p>
<p>获取锁时，线程会对一个原子变量循环执行 <code>compareAndSet</code> 方法，直到该方法返回成功时即为成功获取锁</p>
<blockquote>
<p><code>compareAndSet</code> 方法底层由[[atomic]]实现</p></blockquote>
<p>![[content/en/java/Basic/Concurrent/Pasted image 20250203201648.png]]</p>
<p>自旋锁减少了线程上下文开销, 减缓了频繁的<a href="/java/basic/concurrent/%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92/">线程挂起操作</a></p>
<p>但是该锁有很严重的缺点</p>
<ul>
<li>饥饿问题, 竞争激烈下, 可能有线程一直得不到锁</li>
<li>性能问题, 长时间自旋并且由于锁状态变更需要修改状态变量, 导致CPU的高速缓存在线程间频繁同步, 很消耗CPU
![[content/en/java/Basic/Concurrent/Pasted image 20250203202833.png]]</li>
</ul>
<h4 id="clh锁">CLH锁<a class="td-heading-self-link" href="#clh%e9%94%81" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p><a href="/java/basic/concurrent/volatile%E5%85%B3%E9%94%AE%E5%AD%97/">volatile关键字</a></p></blockquote>
<p>这是对自旋锁的改进版本
主要针对上述两个缺点做了改进</p>
<ul>
<li>饥饿问题, 将线程组织为队列, 先来先服务, 防止饥饿问题</li>
<li>去中心化, 不在使用单独的锁状态变量, 而是在每个线程内维护一个状态变量, 后继线程监视前继线程的状态即可
CLH 锁数据结构很简单，类似一个链表队列，所有请求获取锁的线程会排列在链表队列中，自旋访问队列中前一个节点的状态。</li>
</ul>
<p>![[content/en/java/Basic/Concurrent/Pasted image 20250203203420.png]]</p>
<ol>
<li>
<p>CLH 锁初始化时会 Tail 会指向一个状态为 false 的空节点，如图1所示。</p>
</li>
<li>
<p>当 Thread 1（下称 T1）请求获取锁时，Tail 节点指向 T1 对应的节点，同时返回空节点。T1 检查到上一个节点状态为 false，就成功获取到锁，可以执行相应的逻辑了，如图2所示。</p>
</li>
<li>
<p>当 Thread 2（下称 T2）请求获取锁时，Tail 节点指向 T2 对应的节点，同时返回 T1 对应的节点。T2检查到上一个节点状态为 True，无法获取到锁，于是开始轮询上一个节点的状态，如图3所示。</p>
</li>
<li>
<p>当 T1 释放锁时，会将状态变量置为 False，如图4所示。</p>
</li>
<li>
<p>T2 轮询到检查到上一个节点状态变为 False，则获取锁成功，如图5所示。</p>
</li>
</ol>
<p>Java 源码</p>
<p>![[content/en/java/Basic/Concurrent/Pasted image 20250203203732.png]]</p>
<blockquote>
<p>了解
<a href="/java/basic/concurrent/threadlocal/">ThreadLocal</a></p></blockquote>
<p>利用 <code>ThreadLocal</code>  在独立线程内存维护node, node中只存储了该线程锁状态</p>
<ul>
<li>
<p>为什么锁要加 <code>volatile</code>
注意, 虽然锁状态只由宿主线程读取写入, 是单线程操作没必要保证可见性, 但是作为互斥锁需要保证 <a href="/java/basic/concurrent/jmm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">happen-before 规则</a>成立, 这就意味着一个监视器锁的解锁发生在该监视器锁的后续锁定之前, 因此为了防止无法预测的重排序导致锁的状态在读取完成前被修改, 使用[[volatile关键字]]禁止重排序</p>
</li>
<li>
<p>为什么作为链表, node中不存储后继指针
很简单, 因为不需要, 作为先来先服务的队列, 没必要在乎后续节点的状态
只要前一个节点释放锁, 就立刻获取即可</p>
</li>
</ul>
<p>CLH 锁作为自旋锁的改进，有以下几个优点：</p>
<ol>
<li>
<p>性能优异，获取和释放锁开销小。释放锁的开销因为不需要使用 CAS 指令而降低了。</p>
</li>
<li>
<p>公平锁。先入队的线程会先得到锁。</p>
</li>
<li>
<p>实现简单，易于理解。</p>
</li>
</ol>
<p>当然，它也有两个缺点：第一是因为有自旋操作，当锁持有时间长时会带来较大的 CPU 开销。第二是基本的 CLH 锁功能单一，不改造不能支持复杂的功能。</p>
<blockquote>
<p>[!引用]
Quner技术沙龙
<a href="https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg">https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg</a></p></blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ccc0b90c05532451a1793418e52c926f">1.3.11 - 获取线程执行结果</h1>
    <div class="lead">实际项目中，一个接口可能需要同时获取多种不同的数据，然后再汇总返回，如果是串行（按顺序依次执行每个任务）执行的话，接口的响应速度会非常慢。考虑到这些任务之间有大部分都是 无前后顺序关联 的，可以 并行执行 ，就比如说调用获取商品详情的时候，可以同时调用获取物流信息。通过并行执行多个任务的方式，接口的响应速度会得到大幅优化。</div>
	<blockquote>
<p>Java 1.5 提供了 Callable、Future、FutureTask，它们可以在任务执行完后得到执行结果, 可以实现业务之间的并发执行与返回</p></blockquote>
<p>在[[procthread]] 我们讲述了创建线程实现任务并发的 3 种方式，
直接继承 <code>Thread</code>
实现 <code>Runnable</code> 接口
实现 <code>Callable&lt;&gt;</code> 接口</p>
<p>前 2 种方式都有一个缺陷：在执行完任务之后无法获取执行结果。这对需要前置任务返回值的线程来说很重要</p>
<p>Java 1.5 提供了 Callable、Future、FutureTask，它们可以在任务执行完后得到执行结果</p>
<h4 id="callable">Callable&lt;&gt;<a class="td-heading-self-link" href="#callable" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p><code>callable</code> 源码如下</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">interface</span> <span style="color:#e5c890">Callable</span><span style="color:#99d1db;font-weight:bold">&lt;</span>V<span style="color:#99d1db;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span>    V <span style="color:#8caaee">call</span>() <span style="color:#e78284">throws</span> Exception;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到 <code>call()</code> 方法返回值为泛型 V</p>
<blockquote>
<p>而 <code>Callable&lt;&gt;</code> 允许返回值的一个任务</p>
<p><code>Runnable</code> 接口代表一个可以由线程执行的任务, 实现 <code>Runnable</code> 而不是 <code>callable</code> 主要是线程池的兼容性考虑</p></blockquote>
<h4 id="future-异步计算结果接口"><code>Future</code> 异步计算结果接口<a class="td-heading-self-link" href="#future-%e5%bc%82%e6%ad%a5%e8%ae%a1%e7%ae%97%e7%bb%93%e6%9e%9c%e6%8e%a5%e5%8f%a3" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p><code>Future</code> 表示异步计算的结果，提供了用于检查计算是否完成、等待计算完成、以及检索计算结果的方法。</p>
<blockquote>
<p><code>Future</code> 接口的设计目标是允许任务在一个线程中执行，并且可以返回执行结果或抛出异常</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">interface</span> <span style="color:#e5c890">Future</span><span style="color:#99d1db;font-weight:bold">&lt;</span>V<span style="color:#99d1db;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">boolean</span> <span style="color:#8caaee">cancel</span>(<span style="color:#e78284">boolean</span> mayInterruptIfRunning);
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">boolean</span> <span style="color:#8caaee">isCancelled</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">boolean</span> <span style="color:#8caaee">isDone</span>();
</span></span><span style="display:flex;"><span>    V <span style="color:#8caaee">get</span>() <span style="color:#e78284">throws</span> InterruptedException, ExecutionException;
</span></span><span style="display:flex;"><span>    V <span style="color:#8caaee">get</span>(<span style="color:#e78284">long</span> timeout, TimeUnit unit)
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">throws</span> InterruptedException, ExecutionException, TimeoutException;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>取消任务；</li>
<li>判断任务是否被取消;</li>
<li><code>get()</code>：等待任务完成，获取执行结果，如果任务取消会抛出异常</li>
<li><code>get(long timeout, TimeUnit unit)</code>：指定等待任务完成的时间，等待超时会抛出异常</li>
</ul>
<blockquote>
<p>注意, <code>get()</code> 方法会阻塞主进程, 一直阻塞到定时结束或者线程返回</p></blockquote>
<blockquote>
<p><code>Future</code> 也属于<a href="/java/basic/concurrent/aqs/">同步器</a>的一种
因为类内部定义了线程的控制方法, 同步线程之间的状态
<code>Future</code> 的同步机制主要体现在它的 <code>get()</code> 方法：</p>
<ul>
<li>如果任务已完成，<code>get()</code> 立即返回结果。</li>
<li>如果任务尚未完成，<code>get()</code> 会将调用线程挂起，直到任务完成并且结果可用，才会唤醒线程并返回结果。</li>
</ul></blockquote>
<p><code>isDone()</code>：判断任务是否完成
<code>isCancelled()</code>：判断任务是否被取消
<code>cancel(boolean mayInterruptIfRunning)</code>：尝试取消此任务的执行，如果任务已经完成、已经取消或由于其他原因无法取消，则此尝试将失败
参数 <code>mayInterruptIfRunning</code> 表示是否允许取消正在执行却没有执行完毕的任务</p>
<h4 id="futuretask-异步计算接口实现类"><code>FutureTask</code> 异步计算接口实现类<a class="td-heading-self-link" href="#futuretask-%e5%bc%82%e6%ad%a5%e8%ae%a1%e7%ae%97%e6%8e%a5%e5%8f%a3%e5%ae%9e%e7%8e%b0%e7%b1%bb" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p><code>FutureTask&lt;T&gt;</code> 是 <code>Future</code> 的一个实现类，同时也是 <code>Runnable</code>，可以直接用线程启动。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">FutureTask</span><span style="color:#99d1db;font-weight:bold">&lt;</span>V<span style="color:#99d1db;font-weight:bold">&gt;</span> <span style="color:#e78284">implements</span> RunnableFuture<span style="color:#99d1db;font-weight:bold">&lt;</span>V<span style="color:#99d1db;font-weight:bold">&gt;</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">interface</span> <span style="color:#e5c890">RunnableFuture</span><span style="color:#99d1db;font-weight:bold">&lt;</span>V<span style="color:#99d1db;font-weight:bold">&gt;</span> <span style="color:#e78284">extends</span> Runnable, Future<span style="color:#99d1db;font-weight:bold">&lt;</span>V<span style="color:#99d1db;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">void</span> <span style="color:#8caaee">run</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><code>FutureTask</code> 本身是对异步任务的封装，是 <code>Future</code> 的实现类, 实际的线程控制和结果计算是由其完成的</p>
<p><code>FutureTask</code> 通过 <code>run()</code> 方法实现了 <code>Callable</code> 的任务执行逻辑，因此兼容了 <code>Callable</code> 的行为, 但其本身是 <code>Runnable</code> 的任务</p></blockquote>
<p>使用例子</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#81c8be">import</span> <span style="color:#ef9f76">java.util.concurrent.*</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">FutureExample</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) <span style="color:#e78284">throws</span> Exception {
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 创建一个固定大小为3的线程池</span>
</span></span><span style="display:flex;"><span>        ExecutorService executorService <span style="color:#99d1db;font-weight:bold">=</span> Executors.<span style="color:#8caaee">newFixedThreadPool</span>(3);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 创建一个 Callable 数组，用于存储 5 个任务</span>
</span></span><span style="display:flex;"><span>        Callable<span style="color:#99d1db;font-weight:bold">&lt;</span>Integer<span style="color:#99d1db;font-weight:bold">&gt;[]</span> tasks <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Callable<span style="color:#99d1db;font-weight:bold">[</span>5<span style="color:#99d1db;font-weight:bold">]</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> 0; i <span style="color:#99d1db;font-weight:bold">&lt;</span> tasks.<span style="color:#8caaee">length</span>; i<span style="color:#99d1db;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#e78284">final</span> <span style="color:#e78284">int</span> index <span style="color:#99d1db;font-weight:bold">=</span> i;
</span></span><span style="display:flex;"><span>            tasks<span style="color:#99d1db;font-weight:bold">[</span>i<span style="color:#99d1db;font-weight:bold">]</span> <span style="color:#99d1db;font-weight:bold">=</span> () <span style="color:#99d1db;font-weight:bold">-&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#737994;font-style:italic">// 模拟任务执行时间，每个任务休眠 index+1 秒</span>
</span></span><span style="display:flex;"><span>                TimeUnit.<span style="color:#8caaee">SECONDS</span>.<span style="color:#8caaee">sleep</span>(index <span style="color:#99d1db;font-weight:bold">+</span> 1);
</span></span><span style="display:flex;"><span>                <span style="color:#737994;font-style:italic">// 任务返回 (index + 1) * 100</span>
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">return</span> (index <span style="color:#99d1db;font-weight:bold">+</span> 1) <span style="color:#99d1db;font-weight:bold">*</span> 100;
</span></span><span style="display:flex;"><span>            };
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 使用 Future 数组存储任务的执行结果</span>
</span></span><span style="display:flex;"><span>        Future<span style="color:#99d1db;font-weight:bold">&lt;</span>Integer<span style="color:#99d1db;font-weight:bold">&gt;[]</span> futures <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Future<span style="color:#99d1db;font-weight:bold">[</span>tasks.<span style="color:#8caaee">length</span><span style="color:#99d1db;font-weight:bold">]</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> 0; i <span style="color:#99d1db;font-weight:bold">&lt;</span> tasks.<span style="color:#8caaee">length</span>; i<span style="color:#99d1db;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">// 提交 Callable 任务到线程池，并返回 Future 对象</span>
</span></span><span style="display:flex;"><span>            futures<span style="color:#99d1db;font-weight:bold">[</span>i<span style="color:#99d1db;font-weight:bold">]</span> <span style="color:#99d1db;font-weight:bold">=</span> executorService.<span style="color:#8caaee">submit</span>(tasks<span style="color:#99d1db;font-weight:bold">[</span>i<span style="color:#99d1db;font-weight:bold">]</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 获取任务的执行结果</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> 0; i <span style="color:#99d1db;font-weight:bold">&lt;</span> futures.<span style="color:#8caaee">length</span>; i<span style="color:#99d1db;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">// 调用 get() 方法，会阻塞直到任务完成</span>
</span></span><span style="display:flex;"><span>            System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(<span style="color:#a6d189">&#34;Result of task &#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> (i <span style="color:#99d1db;font-weight:bold">+</span> 1) <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;: &#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> futures<span style="color:#99d1db;font-weight:bold">[</span>i<span style="color:#99d1db;font-weight:bold">]</span>.<span style="color:#8caaee">get</span>());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 关闭线程池，释放资源</span>
</span></span><span style="display:flex;"><span>        executorService.<span style="color:#8caaee">shutdown</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>了解
<a href="/java/basic/concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"><code>executorService.submit()</code></a></p></blockquote>
<p>上述代码定义了一系列 <code>callable</code> 任务, 包装为<code>FutureTask</code>便于线程池使用,  调用 执行器 创建了线程池服务并要求线程池服务执行提交的 <code>FutureTask</code></p>
<blockquote>
<p><code>Future&lt;Integer&gt;[] futures = new Future[tasks.length]</code> 这里是泛型
实际绑定的是 <code>FutureTask</code></p></blockquote>
<h4 id="completeablefuture-任务编排实现类"><code>CompleteableFuture</code> 任务编排实现类<a class="td-heading-self-link" href="#completeablefuture-%e4%bb%bb%e5%8a%a1%e7%bc%96%e6%8e%92%e5%ae%9e%e7%8e%b0%e7%b1%bb" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p>A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html" title="interface in java.util.concurrent"><code>Future</code></a> that may be explicitly completed (setting its value and status), and may be used as a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html" title="interface in java.util.concurrent"><code>CompletionStage</code></a>, supporting dependent functions and actions that trigger upon its completion.</p>
<p><code>Future</code> 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合以及
使用<code>Future</code>获得异步执行结果时，要么调用阻塞方法<code>get()</code>，要么轮询看<code>isDone()</code>是否为<code>true</code>，这两种方法都不是很好，因为主线程也会被迫等待。</p></blockquote>
<blockquote>
<p>从Java 8开始引入了<code>CompletableFuture</code>，它针对<code>Future</code>做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p></blockquote>
<h4 id="如何使用">如何使用<a class="td-heading-self-link" href="#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>创建一个<code>CompletableFuture</code>是通过<code>CompletableFuture.supplyAsync()</code>实现的，它需要一个实现了<code>Supplier</code>接口的对象：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">interface</span> <span style="color:#e5c890">Supplier</span><span style="color:#99d1db;font-weight:bold">&lt;</span>T<span style="color:#99d1db;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span>    T <span style="color:#8caaee">get</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>紧接着，<code>CompletableFuture</code>已经被提交给默认的线程池执行了，我们需要定义的是<code>CompletableFuture</code>完成时和异常时需要回调的实例。完成时，<code>CompletableFuture</code>会调用<code>Consumer</code>对象：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">interface</span> <span style="color:#e5c890">Consumer</span><span style="color:#99d1db;font-weight:bold">&lt;</span>T<span style="color:#99d1db;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">void</span> <span style="color:#8caaee">accept</span>(T t);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>异常时，<code>CompletableFuture</code>会调用<code>Function</code>对象：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">interface</span> <span style="color:#e5c890">Function</span><span style="color:#99d1db;font-weight:bold">&lt;</span>T, R<span style="color:#99d1db;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span>    R <span style="color:#8caaee">apply</span>(T t);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>示例:</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @program: alog  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @description: 实现类  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @author: hamhuo  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> **/</span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">Future</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) <span style="color:#e78284">throws</span> InterruptedException {  
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//创建异步执行的耗时任务, 获取一段文字  </span>
</span></span><span style="display:flex;"><span>        CompletableFuture<span style="color:#99d1db;font-weight:bold">&lt;</span>String<span style="color:#99d1db;font-weight:bold">&gt;</span> task <span style="color:#99d1db;font-weight:bold">=</span> CompletableFuture.<span style="color:#8caaee">supplyAsync</span>(<span style="color:#ca9ee6">new</span> fetchString());  
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//这时已经开始执行了  </span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//如果执行成功执行回调 </span>
</span></span><span style="display:flex;"><span>        task.<span style="color:#8caaee">thenAccept</span>((response) <span style="color:#99d1db;font-weight:bold">-&gt;</span> {  
</span></span><span style="display:flex;"><span>            System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(response <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34; human&#34;</span>);  
</span></span><span style="display:flex;"><span>        });  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//如果失败执行回调</span>
</span></span><span style="display:flex;"><span>        task.<span style="color:#8caaee">exceptionally</span>((e) <span style="color:#99d1db;font-weight:bold">-&gt;</span> {  
</span></span><span style="display:flex;"><span>            e.<span style="color:#8caaee">printStackTrace</span>();  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">null</span>;  
</span></span><span style="display:flex;"><span>        });  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//保证线程池正确关闭, 让主线程在任务完成后等一会  </span>
</span></span><span style="display:flex;"><span>        task.<span style="color:#8caaee">join</span>();  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">static</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">fetchString</span> <span style="color:#e78284">implements</span> Supplier<span style="color:#99d1db;font-weight:bold">&lt;</span>String<span style="color:#99d1db;font-weight:bold">&gt;</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#8caaee;font-weight:bold">@Override</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">public</span>  String <span style="color:#8caaee">get</span>() {  
</span></span><span style="display:flex;"><span>            String message <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#34;hello from star&#34;</span>;  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">try</span>{  
</span></span><span style="display:flex;"><span>                Thread.<span style="color:#8caaee">sleep</span>(2000);  
</span></span><span style="display:flex;"><span>                message <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#34;re:: correct&#34;</span>;  
</span></span><span style="display:flex;"><span>            } <span style="color:#ca9ee6">catch</span> (InterruptedException e) {  
</span></span><span style="display:flex;"><span>                Thread.<span style="color:#8caaee">currentThread</span>().<span style="color:#8caaee">interrupt</span>();  
</span></span><span style="display:flex;"><span>            }  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (message.<span style="color:#8caaee">equals</span>(<span style="color:#a6d189">&#34;hello from star&#34;</span>)) {  
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">throw</span> <span style="color:#ca9ee6">new</span> RuntimeException(<span style="color:#a6d189">&#34;Earth&#34;</span>);  
</span></span><span style="display:flex;"><span>            }  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">return</span> message;  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>thenAcccept()</code> 不会阻塞线程, 是非阻塞的回调方法, 需要主线程手动等待完成</p>
<blockquote>
<p>引用:
<a href="https://liaoxuefeng.com/books/java/threading/completable-future/index.html">https://liaoxuefeng.com/books/java/threading/completable-future/index.html</a>
<a href="https://javaguide.cn/java/concurrent/completablefuture-intro.html#future-%E4%BB%8B%E7%BB%8D">https://javaguide.cn/java/concurrent/completablefuture-intro.html#future-%E4%BB%8B%E7%BB%8D</a></p></blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-eb58c6263bd0f4c0a9d27623576ca64e">1.3.12 - 通信工具类</h1>
    <div class="lead">JDK 中提供了一些并发编程中常用的通信工具类以供我们开发者使用。它们都在 JUC 包下。先总体概括一下都有哪些工具类，它们有什么作用，然后再分别介绍它们的主要使用方法和原理。</div>
	<p>JDK 中提供了一些并发编程中常用的通信工具类以供我们开发者使用</p>
<table>
  <thead>
      <tr>
          <th>类</th>
          <th>作用</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Semaphore</td>
          <td>限制线程的数量</td>
      </tr>
      <tr>
          <td>Exchanger</td>
          <td>两个线程交换数据</td>
      </tr>
      <tr>
          <td>CountDownLatch</td>
          <td>线程等待直到计数器减为 0 时开始工作</td>
      </tr>
      <tr>
          <td>CyclicBarrier</td>
          <td>作用跟 CountDownLatch 类似，但是可以重复使用</td>
      </tr>
      <tr>
          <td>Phaser</td>
          <td>增强的 CyclicBarrier</td>
      </tr>
  </tbody>
</table>
<h3 id="countdownlatch"><code>CountDownLatch</code><a class="td-heading-self-link" href="#countdownlatch" aria-label="Heading self-link"></a></h3>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>一个减法计数器, 基于信号量</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">class</span> <span style="color:#e5c890">CountTest</span>{
</span></span><span style="display:flex;"><span>	  <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) <span style="color:#e78284">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>		<span style="color:#737994;font-style:italic">//设置一个尺寸为10的信号量</span>
</span></span><span style="display:flex;"><span>		 <span style="color:#737994;font-style:italic">//总数是10，必须要执行任务的时候，再使用</span>
</span></span><span style="display:flex;"><span>        CountDownLatch countDownLatch <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> CountDownLatch(10);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span>(<span style="color:#e78284">int</span> i<span style="color:#99d1db;font-weight:bold">=</span>0; i<span style="color:#99d1db;font-weight:bold">&lt;</span>10; i<span style="color:#99d1db;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">new</span> Thread(()<span style="color:#99d1db;font-weight:bold">-&gt;</span>{
</span></span><span style="display:flex;"><span>                System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(Thread.<span style="color:#8caaee">currentThread</span>().<span style="color:#8caaee">getName</span>()<span style="color:#99d1db;font-weight:bold">+</span><span style="color:#a6d189">&#34; Go out&#34;</span>);
</span></span><span style="display:flex;"><span>                countDownLatch.<span style="color:#8caaee">countDown</span>(); <span style="color:#737994;font-style:italic">//数量减1</span>
</span></span><span style="display:flex;"><span>            },String.<span style="color:#8caaee">valueOf</span>(i)).<span style="color:#8caaee">start</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        countDownLatch.<span style="color:#8caaee">await</span>(); <span style="color:#737994;font-style:italic">//等待计数器归零，再向下执行</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(<span style="color:#a6d189">&#34;Hello world!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>两个方法</p>
<ul>
<li><code>countDown()</code> 调用后计数减一</li>
<li><code>await()</code> 使线程挂起</li>
</ul>
<h4 id="exchanger"><code>Exchanger</code><a class="td-heading-self-link" href="#exchanger" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p>A synchronization point at which threads can pair and swap elements within pairs. Each thread presents some object on entry to the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Exchanger.html#exchange-V-"><code>exchange</code></a> method, matches with a partner thread, and receives its partner&rsquo;s object on return. An Exchanger may be viewed as a bidirectional form of a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/SynchronousQueue.html" title="class in java.util.concurrent"><code>SynchronousQueue</code></a>. Exchangers may be useful in applications such as genetic algorithms and pipeline designs.</p></blockquote>
<ul>
<li>此类提供对外的操作是同步的；</li>
<li>用于成对出现的线程之间交换数据；</li>
<li>可以视作双向的同步队列；</li>
<li>可应用于基因算法、流水线设计等场景。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">class</span> <span style="color:#e5c890">FillAndEmpty</span> {  
</span></span><span style="display:flex;"><span>    Exchanger<span style="color:#99d1db;font-weight:bold">&lt;</span>DataBuffer<span style="color:#99d1db;font-weight:bold">&gt;</span> exchanger <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> Exchanger<span style="color:#99d1db;font-weight:bold">&lt;</span>DataBuffer<span style="color:#99d1db;font-weight:bold">&gt;</span>();  
</span></span><span style="display:flex;"><span>    DataBuffer initialEmptyBuffer <span style="color:#99d1db;font-weight:bold">=</span> ... 
</span></span><span style="display:flex;"><span>    DataBuffer initialFullBuffer <span style="color:#99d1db;font-weight:bold">=</span> ...  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">class</span> <span style="color:#e5c890">FillingLoop</span> <span style="color:#e78284">implements</span> Runnable {  
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">run</span>() {  
</span></span><span style="display:flex;"><span>	        <span style="color:#737994;font-style:italic">//初始化缓存</span>
</span></span><span style="display:flex;"><span>            DataBuffer currentBuffer <span style="color:#99d1db;font-weight:bold">=</span> initialEmptyBuffer;  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">try</span> {  
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">while</span> (currentBuffer <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {  
</span></span><span style="display:flex;"><span>                    addToBuffer(currentBuffer);  
</span></span><span style="display:flex;"><span>                    <span style="color:#ca9ee6">if</span> (currentBuffer.<span style="color:#8caaee">isFull</span>()) 
</span></span><span style="display:flex;"><span>	                    <span style="color:#737994;font-style:italic">//如果缓存满, 需要交换, 在这里等 </span>
</span></span><span style="display:flex;"><span>                        currentBuffer <span style="color:#99d1db;font-weight:bold">=</span> exchanger.<span style="color:#8caaee">exchange</span>(currentBuffer);  
</span></span><span style="display:flex;"><span>                }  
</span></span><span style="display:flex;"><span>            } <span style="color:#ca9ee6">catch</span> (InterruptedException ex) { ... handle ... }  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">class</span> <span style="color:#e5c890">EmptyingLoop</span> <span style="color:#e78284">implements</span> Runnable {  
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">run</span>() {  
</span></span><span style="display:flex;"><span>            DataBuffer currentBuffer <span style="color:#99d1db;font-weight:bold">=</span> initialFullBuffer;  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">try</span> {  
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">while</span> (currentBuffer <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {  
</span></span><span style="display:flex;"><span>                    takeFromBuffer(currentBuffer);  
</span></span><span style="display:flex;"><span>                    <span style="color:#ca9ee6">if</span> (currentBuffer.<span style="color:#8caaee">isEmpty</span>()) 
</span></span><span style="display:flex;"><span>	                    <span style="color:#737994;font-style:italic">//如果缓存空, 需要交换, 在这里等 </span>
</span></span><span style="display:flex;"><span>                        currentBuffer <span style="color:#99d1db;font-weight:bold">=</span> exchanger.<span style="color:#8caaee">exchange</span>(currentBuffer);  
</span></span><span style="display:flex;"><span>                }  
</span></span><span style="display:flex;"><span>            } <span style="color:#ca9ee6">catch</span> (InterruptedException ex) { ... handle ...}  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">void</span> <span style="color:#8caaee">start</span>() {  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">new</span> Thread(<span style="color:#ca9ee6">new</span> FillingLoop()).<span style="color:#8caaee">start</span>();  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">new</span> Thread(<span style="color:#ca9ee6">new</span> EmptyingLoop()).<span style="color:#8caaee">start</span>();  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当一个线程调用 exchange 方法后，会处于阻塞状态，只有当另一个线程也调用了 exchange 方法，它才会继续执行。</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250209090451142.png" alt="image.png"></p>
<p>内部使用 <code>CAS</code> 检查, 使用<code>park/unpark</code> 做状态转换</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bc1c17d06273c0655aee4c36ef7ac3e4">1.3.13 - </h1>
    
	
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ab69ccd2ef54b92e136c4c0f577a70d4">1.3.14 - </h1>
    
	
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-3c9d097a3c2cc02642d83a2d176c4c26">1.3.15 - </h1>
    
	
</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c00ea7dd56878ea2f5f2ecbde4b08b00">1.4 - Java数据类型</h1>
    <div class="lead">变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</div>
	<h4 id="三元运算符">三元运算符<a class="td-heading-self-link" href="#%e4%b8%89%e5%85%83%e8%bf%90%e7%ae%97%e7%ac%a6" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>Java的三元运算符返回值必须赋值, 不能单纯的执行语句</p>
<h4 id="bigdecimal-类"><code>BigDecimal</code> 类<a class="td-heading-self-link" href="#bigdecimal-%e7%b1%bb" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p>Immutable, arbitrary-precision signed decimal numbers.
A <code>BigDecimal</code> consists of an arbitrary precision integer <em>unscaled value</em> and a 32-bit integer <em>scale</em>.</p>
<p>不可变的, 有符号任意精度数, 有32位的标度和未缩放值组成, 精度极高
计算式</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250221212904257.png" alt="image.png"></p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>BigDecimal bd1 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> BigDecimal(<span style="color:#a6d189">&#34;12.345&#34;</span>);
</span></span><span style="display:flex;"><span>BigDecimal bd2 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> BigDecimal(<span style="color:#a6d189">&#34;0.005&#34;</span>);
</span></span><span style="display:flex;"><span>BigDecimal result <span style="color:#99d1db;font-weight:bold">=</span> bd1.<span style="color:#8caaee">add</span>(bd2);
</span></span><span style="display:flex;"><span>System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(result);  <span style="color:#737994;font-style:italic">// 输出 12.350</span>
</span></span></code></pre></div><h4 id="string-类-和-arrays-类">String 类 和 Arrays 类<a class="td-heading-self-link" href="#string-%e7%b1%bb-%e5%92%8c-arrays-%e7%b1%bb" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>字符串, 但很多时候需要转换为字符数组</p>
<p>如何对 <code>String</code> 字符排序?</p>
<p>转化为字符数组, 调用数组的排序方法</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) {
</span></span><span style="display:flex;"><span>        String s <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#34;hamhuo&#34;</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// Convert the string to a character array</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">char</span><span style="color:#99d1db;font-weight:bold">[]</span> arr <span style="color:#99d1db;font-weight:bold">=</span> s.<span style="color:#8caaee">toCharArray</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// Sort the character array</span>
</span></span><span style="display:flex;"><span>        Arrays.<span style="color:#8caaee">sort</span>(arr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// Convert sorted character array back to string</span>
</span></span><span style="display:flex;"><span>        s <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> String(arr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// Print the sorted string</span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">print</span>(s);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p><code>Array.sort()</code></p>
<p>数组提供了排序方法</p>
<blockquote>
<p>Sorts the specified range of the array into ascending order. The range to be sorted extends from the index <code>fromIndex</code>, inclusive, to the index <code>toIndex</code>, exclusive. If <code>fromIndex == toIndex</code>, the range to be sorted is empty.
该方法使用比较器比较元素, 实现排序
对于对象数组，Java 会选择 <strong>双轴快速排序（Dual-Pivot Quicksort）</strong> 或 <strong>归并排序（Merge Sort）</strong> 来排序。对于原始类型数组（如 <code>int[]</code>），Java 会使用 <strong>优化后的快速排序（QuickSort）</strong> 或 <strong>归并排序（MergeSort）</strong>。</p></blockquote>
<p><code>String.charAt()</code></p>
<p>返回字符串的某个字符
在快速取出某个位置的字符时非常有用, 比如指针遍历字符串, 需要拿指针指向的字符时可以使用</p>
<blockquote>
<p>Returns the <code>char</code> value at the specified index. An index ranges from <code>0</code> to <code>length() - 1</code>. The first <code>char</code> value of the sequence is at index <code>0</code>, the next at index <code>1</code>, and so on, as for array indexing.</p></blockquote>
<p><code>Arrays.equals()</code></p>
<p><code>Arrays.equals(a, b)</code> 是 <code>java.util.Arrays</code> 类中的一个静态方法，用于比较两个数组是否相等。它会逐个元素地比较两个数组的内容是否相同。</p>
<blockquote>
<p>和 <code>Object.equals()</code> 完全不同
前者是数组提供的工具方法, 用于比较内容, 而后者是通用的父类方法, 用于比较地址</p></blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-fb1f1b494bcd063f262ba00385cb3da4">1.5 - Java集合框架</h1>
    
	<p>内容来源:</p>
<ul>
<li>沉默王二 GitHub 上开源的知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">Java 进阶之路</a>》</li>
<li><a href="https://javaguide.cn/java/concurrent/">JavaGuide</a></li>
<li><a href="https://www.geeksforgeeks.org/">Geeksforgeeks</a></li>
<li><a href="https://www.runoob.com/">菜鸟教程</a></li>
</ul>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-9886ba6c7be251f58197e67c1f8cab0b">1.5.1 - LinkedList</h1>
    <div class="lead"><code>LinkedList</code> 是基于双向链表的数据结构, 实现队列和列表接口的所有方法, 允许存放任意类型元素</div>
	<h4 id="什么是链表">什么是链表<a class="td-heading-self-link" href="#%e4%bb%80%e4%b9%88%e6%98%af%e9%93%be%e8%a1%a8" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。</p>
<p>链表可分为单向链表和双向链表。</p>
<p>一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。</p>
<p>单向链表</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250207180458615.png" alt="image.png"></p>
<p>双向链表</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250207180510867.png" alt="image.png"></p>
<p>Doubly-linked list implementation of the <code>List</code> and <code>Deque</code> interfaces. Implements all optional list operations, and permits all elements (including <code>null</code>).
<code>LinkedList</code> 是基于双向链表的数据结构, 实现队列和列表接口的所有方法, 允许存放任意类型元素</p>
<h4 id="基础使用">基础使用<a class="td-heading-self-link" href="#%e5%9f%ba%e7%a1%80%e4%bd%bf%e7%94%a8" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p><strong>以下情况使用 LinkedList :</strong></p>
<ul>
<li>你需要通过循环迭代来访问列表中的某些元素。</li>
<li>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</li>
</ul></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">LinkedList</span><span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">extends</span> AbstractSequentialList<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">implements</span> List<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span>, Deque<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span>, Cloneable, Serializable
</span></span></code></pre></div><p>使用之前:</p>
<ul>
<li><code>LinkedList</code> 类位于 <code>java.util</code> 包中，使用前需要引入它</li>
<li>链表实现了 <code>Queue</code> 接口, 可以作为队列使用</li>
<li>链表实现了 <code>List</code> 接口, 可进行列表的相关操作</li>
<li>链表添加标签 <code>Cloneable</code> 允许克隆</li>
<li>链表实现 <code>Serializable</code> 可以序列化</li>
<li>链表线程不安全, 依赖外部同步</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250207181217867.png" alt="image.png"></p>
<p>新建实例</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// 引入 LinkedList 类</span>
</span></span><span style="display:flex;"><span><span style="color:#81c8be">import</span> <span style="color:#ef9f76">java.util.LinkedList</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">RunoobTest</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) {
</span></span><span style="display:flex;"><span>        LinkedList<span style="color:#99d1db;font-weight:bold">&lt;</span>String<span style="color:#99d1db;font-weight:bold">&gt;</span> sites <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> LinkedList<span style="color:#99d1db;font-weight:bold">&lt;</span>String<span style="color:#99d1db;font-weight:bold">&gt;</span>();
</span></span><span style="display:flex;"><span>        sites.<span style="color:#8caaee">add</span>(<span style="color:#a6d189">&#34;Google&#34;</span>);
</span></span><span style="display:flex;"><span>        sites.<span style="color:#8caaee">add</span>(<span style="color:#a6d189">&#34;Runoob&#34;</span>);
</span></span><span style="display:flex;"><span>        sites.<span style="color:#8caaee">add</span>(<span style="color:#a6d189">&#34;Taobao&#34;</span>);
</span></span><span style="display:flex;"><span>        sites.<span style="color:#8caaee">add</span>(<span style="color:#a6d189">&#34;Weibo&#34;</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(sites);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>开头添加元素</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>sites.<span style="color:#8caaee">addFirst</span>()
</span></span></code></pre></div><p>结尾添加元素</p>
<blockquote>
<p>注意
默认的 <code>add()</code> 方法就是在结尾添加</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>sites.<span style="color:#8caaee">addLast</span>()
</span></span></code></pre></div><p>开头删除元素</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>sites.<span style="color:#8caaee">removedFirst</span>()
</span></span></code></pre></div><p>结尾删除元素</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>sites.<span style="color:#8caaee">removedLast</span>()
</span></span></code></pre></div><p>获取元素</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>sites.<span style="color:#8caaee">getFirst</span>()
</span></span><span style="display:flex;"><span>sites.<span style="color:#8caaee">getLast</span>()
</span></span></code></pre></div><p>获取链表长度</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>sites.<span style="color:#8caaee">size</span>()
</span></span></code></pre></div><hr>
<h4 id="进阶部分">进阶部分<a class="td-heading-self-link" href="#%e8%bf%9b%e9%98%b6%e9%83%a8%e5%88%86" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><h4 id="为什么需要链表">为什么需要链表?<a class="td-heading-self-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e9%93%be%e8%a1%a8" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>和链表定位类似的是 <code>ArrayList</code> 基于动态数组的列表</p>
<p>相比之下链表有以下优点</p>
<ol>
<li>链表不定长, 内存无需连续</li>
<li>头尾插入快</li>
</ol>
<p>链表大致分为三种</p>
<ul>
<li>“单向链表”，我只有一个后指针，指向下一个数据；</li>
<li>“双向链表”，我有两个指针，后指针指向下一个数据，前指针指向上一个数据。</li>
<li>“二叉树”，把后指针去掉，换成左右指针。</li>
</ul>
<h4 id="linkedlist-解析"><code>LinkedList</code> 解析<a class="td-heading-self-link" href="#linkedlist-%e8%a7%a3%e6%9e%90" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>链表的核心是 <code>Node</code> 这是一个内部静态类, 定义存储数据单位的结构</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * 链表中的节点类。
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">Node</span><span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span>    E item; <span style="color:#737994;font-style:italic">// 节点中存储的元素</span>
</span></span><span style="display:flex;"><span>    Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> next; <span style="color:#737994;font-style:italic">// 指向下一个节点的指针</span>
</span></span><span style="display:flex;"><span>    Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> prev; <span style="color:#737994;font-style:italic">// 指向上一个节点的指针</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     * 构造一个新的节点。
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     *
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     * @param prev 前一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     * @param element 节点中要存储的元素
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     * @param next 后一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     */</span>
</span></span><span style="display:flex;"><span>    Node(Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> prev, E element, Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> next) {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">this</span>.<span style="color:#8caaee">item</span> <span style="color:#99d1db;font-weight:bold">=</span> element; <span style="color:#737994;font-style:italic">// 存储元素</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">this</span>.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> next; <span style="color:#737994;font-style:italic">// 设置下一个节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">this</span>.<span style="color:#8caaee">prev</span> <span style="color:#99d1db;font-weight:bold">=</span> prev; <span style="color:#737994;font-style:italic">// 设置上一个节点</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><code>LinkedList</code> 内部使用双向链表实现
<img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250207184211029.png" alt="image.png"></p></blockquote>
<h4 id="添加节点">添加节点<a class="td-heading-self-link" href="#%e6%b7%bb%e5%8a%a0%e8%8a%82%e7%82%b9" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * 将指定的元素添加到列表的尾部。
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @param e 要添加到列表的元素
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @return 始终为 true（根据 Java 集合框架规范）
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">boolean</span> <span style="color:#8caaee">add</span>(E e) {
</span></span><span style="display:flex;"><span>    linkLast(e); <span style="color:#737994;font-style:italic">// 在列表的尾部添加元素</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">true</span>; <span style="color:#737994;font-style:italic">// 添加元素成功，返回 true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>//todo</p>
<h4 id="删除节点">删除节点<a class="td-heading-self-link" href="#%e5%88%a0%e9%99%a4%e8%8a%82%e7%82%b9" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><ul>
<li><code>remove()</code>：删除第一个节点</li>
<li><code>remove(int)</code>：删除指定位置的节点</li>
<li><code>remove(Object)</code>：删除指定元素的节点</li>
<li><code>removeFirst()</code>：删除第一个节点</li>
<li><code>removeLast()</code>：删除最后一个节点</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * 删除指定位置上的元素。
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @param index 要删除的元素的索引
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @return 从列表中删除的元素
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @throws IndexOutOfBoundsException 如果索引越界（index &amp;lt; 0 || index &amp;gt;= size()）
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> E <span style="color:#8caaee">remove</span>(<span style="color:#e78284">int</span> index) {
</span></span><span style="display:flex;"><span>    checkElementIndex(index); <span style="color:#737994;font-style:italic">// 检查索引是否越界</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> unlink(node(index)); <span style="color:#737994;font-style:italic">// 删除指定位置的节点，并返回节点的元素</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * 获取链表中指定位置的节点。
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @param index 节点的位置（从 0 开始）
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @return 指定位置的节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index &gt;= size()）
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span>Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> <span style="color:#8caaee">node</span>(<span style="color:#e78284">int</span> index) {
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (index <span style="color:#99d1db;font-weight:bold">&lt;</span> (size <span style="color:#99d1db;font-weight:bold">&gt;&gt;</span> 1)) { <span style="color:#737994;font-style:italic">// 如果索引在链表的前半部分</span>
</span></span><span style="display:flex;"><span>        Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> x <span style="color:#99d1db;font-weight:bold">=</span> first;
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> 0; i <span style="color:#99d1db;font-weight:bold">&lt;</span> index; i<span style="color:#99d1db;font-weight:bold">++</span>) <span style="color:#737994;font-style:italic">// 从头节点开始向后遍历链表，直到找到指定位置的节点</span>
</span></span><span style="display:flex;"><span>            x <span style="color:#99d1db;font-weight:bold">=</span> x.<span style="color:#8caaee">next</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> x; <span style="color:#737994;font-style:italic">// 返回指定位置的节点</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#ca9ee6">else</span> { <span style="color:#737994;font-style:italic">// 如果索引在链表的后半部分</span>
</span></span><span style="display:flex;"><span>        Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> x <span style="color:#99d1db;font-weight:bold">=</span> last;
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (<span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> size <span style="color:#99d1db;font-weight:bold">-</span> 1; i <span style="color:#99d1db;font-weight:bold">&gt;</span> index; i<span style="color:#99d1db;font-weight:bold">--</span>) <span style="color:#737994;font-style:italic">// 从尾节点开始向前遍历链表，直到找到指定位置的节点</span>
</span></span><span style="display:flex;"><span>            x <span style="color:#99d1db;font-weight:bold">=</span> x.<span style="color:#8caaee">prev</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> x; <span style="color:#737994;font-style:italic">// 返回指定位置的节点</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>内部调用的是 <code>unlink()</code> 方法</p>
<p>大致思路是</p>
<p>删除一共涉及三个节点, 前驱节点, 删除节点, 后驱节点
这是因为一旦节点被删除, 链表就断掉了, 需要重新连接前驱和后驱
拿到这三个节点, 首先进行特殊情况判断</p>
<ul>
<li>删除的是否为头结点
如果是, 就把后驱节点设置为头结点
如果不是, 前驱节点连接后驱节点, 删除节点的前驱置空</li>
<li>删除的是否为尾节点
如果是, 就把前驱节点设置为尾节点
如果不是, 后驱节点连接前驱节点, 完成双向链接, 删除节点的后驱置空</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * 从链表中删除指定节点。
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @param x 要删除的节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @return 从链表中删除的节点的元素
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span>E <span style="color:#8caaee">unlink</span>(Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> x) {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">final</span> E element <span style="color:#99d1db;font-weight:bold">=</span> x.<span style="color:#8caaee">item</span>; <span style="color:#737994;font-style:italic">// 获取要删除节点的元素</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">final</span> Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> next <span style="color:#99d1db;font-weight:bold">=</span> x.<span style="color:#8caaee">next</span>; <span style="color:#737994;font-style:italic">// 获取要删除节点的下一个节点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">final</span> Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> prev <span style="color:#99d1db;font-weight:bold">=</span> x.<span style="color:#8caaee">prev</span>; <span style="color:#737994;font-style:italic">// 获取要删除节点的上一个节点</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (prev <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span>) { <span style="color:#737994;font-style:italic">// 如果要删除节点是第一个节点</span>
</span></span><span style="display:flex;"><span>        first <span style="color:#99d1db;font-weight:bold">=</span> next; <span style="color:#737994;font-style:italic">// 将链表的头节点设置为要删除节点的下一个节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//在这种情况下，不能执行 prev.next = next，因为 prev 是 null，会导致空指针异常</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#ca9ee6">else</span> {
</span></span><span style="display:flex;"><span>        prev.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> next; <span style="color:#737994;font-style:italic">// 将要删除节点的上一个节点指向要删除节点的下一个节点</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        x.<span style="color:#8caaee">prev</span> <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ef9f76">null</span>; <span style="color:#737994;font-style:italic">// 将要删除节点的上一个节点设置为空</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (next <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span>) { <span style="color:#737994;font-style:italic">// 如果要删除节点是最后一个节点</span>
</span></span><span style="display:flex;"><span>        last <span style="color:#99d1db;font-weight:bold">=</span> prev; <span style="color:#737994;font-style:italic">// 将链表的尾节点设置为要删除节点的上一个节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//在这种情况下，不能执行 next.prev = prev，因为 next 是 null，会导致空指针异常</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#ca9ee6">else</span> {
</span></span><span style="display:flex;"><span>        next.<span style="color:#8caaee">prev</span> <span style="color:#99d1db;font-weight:bold">=</span> prev; <span style="color:#737994;font-style:italic">// 将要删除节点的下一个节点指向要删除节点的上一个节点   </span>
</span></span><span style="display:flex;"><span>        x.<span style="color:#8caaee">next</span> <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ef9f76">null</span>; <span style="color:#737994;font-style:italic">// 将要删除节点的下一个节点设置为空</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    x.<span style="color:#8caaee">item</span> <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ef9f76">null</span>; <span style="color:#737994;font-style:italic">// 将要删除节点的元素设置为空</span>
</span></span><span style="display:flex;"><span>    size<span style="color:#99d1db;font-weight:bold">--</span>; <span style="color:#737994;font-style:italic">// 减少链表的元素个数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> element; <span style="color:#737994;font-style:italic">// 返回被删除节点的元素</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>remove(Object)</code> 内部也调用了 unlink 方法，只不过在此之前要先找到元素所在的节点：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * 从链表中删除指定元素。
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @param o 要从链表中删除的元素
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @return 如果链表包含指定元素，则返回 true；否则返回 false
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">boolean</span> <span style="color:#8caaee">remove</span>(Object o) {
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (o <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span>) { <span style="color:#737994;font-style:italic">// 如果要删除的元素为 null</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> x <span style="color:#99d1db;font-weight:bold">=</span> first; x <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>; x <span style="color:#99d1db;font-weight:bold">=</span> x.<span style="color:#8caaee">next</span>) { <span style="color:#737994;font-style:italic">// 遍历链表</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (x.<span style="color:#8caaee">item</span> <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span>) { <span style="color:#737994;font-style:italic">// 如果节点的元素为 null</span>
</span></span><span style="display:flex;"><span>                unlink(x); <span style="color:#737994;font-style:italic">// 删除节点</span>
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">true</span>; <span style="color:#737994;font-style:italic">// 返回 true 表示删除成功</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#ca9ee6">else</span> { <span style="color:#737994;font-style:italic">// 如果要删除的元素不为 null</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (Node<span style="color:#99d1db;font-weight:bold">&lt;</span>E<span style="color:#99d1db;font-weight:bold">&gt;</span> x <span style="color:#99d1db;font-weight:bold">=</span> first; x <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>; x <span style="color:#99d1db;font-weight:bold">=</span> x.<span style="color:#8caaee">next</span>) { <span style="color:#737994;font-style:italic">// 遍历链表</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (o.<span style="color:#8caaee">equals</span>(x.<span style="color:#8caaee">item</span>)) { <span style="color:#737994;font-style:italic">// 如果节点的元素等于要删除的元素</span>
</span></span><span style="display:flex;"><span>                unlink(x); <span style="color:#737994;font-style:italic">// 删除节点</span>
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">true</span>; <span style="color:#737994;font-style:italic">// 返回 true 表示删除成功</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">false</span>; <span style="color:#737994;font-style:italic">// 如果链表中不包含要删除的元素，则返回 false 表示删除失败</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1e2799081c05c7725471a651bb895f48">1.5.2 - </h1>
    
	
</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-0875c54f6d44df81f93d332739dec85a">1.6 - JVM</h1>
    
	<p>内容来源:</p>
<ul>
<li>沉默王二 GitHub 上开源的知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">Java 进阶之路</a>》</li>
<li><a href="https://javaguide.cn/java/concurrent/">JavaGuide</a></li>
<li><a href="https://www.geeksforgeeks.org/">Geeksforgeeks</a></li>
<li><a href="https://www.runoob.com/">菜鸟教程</a></li>
</ul>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-1cc71c675230af6c3f2a48d23454c2d4">1.6.1 - Java的四种引用</h1>
    <div class="lead">强引用不会被垃圾回收，除非手动弱化；软引用在内存不足时回收，可用于内存敏感的高速缓存；弱引用不管内存是否充足，垃圾回收时都会回收；虚引用不决定对象生命周期，主要用于跟踪对象回收。</div>
	<p>强引用
A a=new A(); 此时引用a强引用对象A；不会被GC
即使OOM也不会回收对象, 而是抛异常</p>
<p>弱引用
<strong>WeakReference.java</strong> 是 Java1.2提供的一个类
当GC发现弱引用后会直接回收该对象</p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-932a01a42f76fda69c7dd02a6867b569">1.7 - MySQL</h1>
    <div class="lead">关系性数据库, 程序员的入门教程</div>
	<p>内容来源:</p>
<ul>
<li>沉默王二 GitHub 上开源的知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">Java 进阶之路</a>》</li>
</ul>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-ef17bed2d83c0c5d4e034c246e042618">1.7.1 - MySQL字符集和比较规则</h1>
    <div class="lead">当我们创建数据库或者表的时候，就要指定字符集和比较规则。 不指定则MySQL 默认。</div>
	<h4 id="字符集">字符集<a class="td-heading-self-link" href="#%e5%ad%97%e7%ac%a6%e9%9b%86" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>计算机的世界里，它是只认识 0 和 1 的, 那汉字怎么办? 英文怎么办?</p>
<p>我们在屏幕上看到的英文、汉字等字符是二进制数转换之后的结果</p>
<p>通俗的说，按照何种规则将字符存储在计算机中，如&rsquo;a&rsquo;用什么表示，称为&quot;编码&quot;；反之，将存储在计算机中的二进制数解析显示出来，称为&quot;解码&quot;,如果使用了错误的解码规则，则导致&rsquo;a&rsquo;解析成&rsquo;b&rsquo;或者乱码。</p>
<h4 id="ascii字符集编码">ASCII字符集&amp;编码<a class="td-heading-self-link" href="#ascii%e5%ad%97%e7%ac%a6%e9%9b%86%e7%bc%96%e7%a0%81" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p>ASCII(American Standard Code for Information Interchange，美国信息交换标准代码)</p>
<p>是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语</p></blockquote>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250211010458860.png" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250211010511256.png" alt="image.png"></p>
<p>ASCII的最大缺点是只能显示26个基本拉丁字母、阿拉伯数目字和英式标点符号，因此只能用于显示现代美国英语</p>
<blockquote>
<p>已经淘汰</p></blockquote>
<h3 id="gbxxxx字符集编码">GBXXXX字符集&amp;编码<a class="td-heading-self-link" href="#gbxxxx%e5%ad%97%e7%ac%a6%e9%9b%86%e7%bc%96%e7%a0%81" aria-label="Heading self-link"></a></h3>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>计算机发明之处及后面很长一段时间，只用应用于美国及西方一些发达国家，ASCII能够很好满足用户的需求。</p>
<p>但是当天朝也有了计算机之后，为了显示中文，必须设计一套编码规则用于将汉字转换为计算机可以接受的数字系统的字符集。</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250211010616455.png" alt="image.png"></p>
<blockquote>
<p>什么都有, 基本东亚文字全了</p></blockquote>
<p>GBK是对GB2312-80的扩展, 收录了繁体</p>
<h2 id="unicode字符集utf编码">Unicode字符集&amp;UTF编码<a class="td-heading-self-link" href="#unicode%e5%ad%97%e7%ac%a6%e9%9b%86utf%e7%bc%96%e7%a0%81" aria-label="Heading self-link"></a></h2>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p><em>你说的对, 但是每个国家有自己的编码</em></p>
<p>那网络聊天怎么办? 编码不同根本无法识别</p>
<p>为了解决这个问题，一个伟大的创想产生了——Unicode。Unicode编码系统为表达任意语言的任意字符而设计。
被几种语言共用的字符通常使用相同的数字来编码, 不存在二义性。不再需要记录&quot;模式&quot;了</p>
<p>MySQL的UTF-8最多支持三个字节</p>
<p>UTF-8mb4支持四个字节</p>
<h4 id="比较规则">比较规则<a class="td-heading-self-link" href="#%e6%af%94%e8%be%83%e8%a7%84%e5%88%99" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" />
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-3c8ae2e325db9dfb27013b9bcb0803d1">1.7.2 - MySQL数据库操作</h1>
    <div class="lead">十分钟快速上手MySQL</div>
	<p>十分钟快速上手MySQL</p>
<h4 id="创建数据库">创建数据库<a class="td-heading-self-link" href="#%e5%88%9b%e5%bb%ba%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">create</span> <span style="color:#ca9ee6">database</span> <span style="color:#e78284">数据库名</span>;
</span></span></code></pre></div><blockquote>
<p>提示:</p>
<ol>
<li>上下箭头可以切换之前执行的指令</li>
<li>记得加分号</li>
</ol></blockquote>
<h4 id="切换数据库">切换数据库<a class="td-heading-self-link" href="#%e5%88%87%e6%8d%a2%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>use <span style="color:#e78284">数据库名</span>;
</span></span></code></pre></div><h4 id="删除数据库">删除数据库<a class="td-heading-self-link" href="#%e5%88%a0%e9%99%a4%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p>提示:
这个指令一般不用😂</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">drop</span> <span style="color:#ca9ee6">database</span> <span style="color:#e78284">数据库名</span>;
</span></span></code></pre></div><blockquote>
<p>了解
<a href="/java/basic/mysql/mysql%E8%A1%A8%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/">表</a></p></blockquote>
<h4 id="java交互mysql">Java交互MySQL<a class="td-heading-self-link" href="#java%e4%ba%a4%e4%ba%92mysql" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>上述都是命令行操作</p>
<p>如何在Java程序对数据库进行操作?</p>
<blockquote>
<p>驱动
和显卡驱动, 网卡驱动类似, Java程序想要对MySQL做操作时也需要这样的桥梁</p></blockquote>
<p><a href="https://dev.mysql.com/downloads/connector/j/">MySQL Connector/J</a></p>
<blockquote>
<p><code>classpath</code>
也就是 <code>src/main/resources</code> 目录</p></blockquote>
<p>将下载的 <code>.jar</code> 包放到项目 <code>classpath</code> 下</p>
<p>在IDE中写一个类连接到服务器</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">class</span> <span style="color:#e5c890">DatabaseCreator</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> String URL <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#34;jdbc:mysql://localhost:3306/?useSSL=false&amp;serverTimezone=UTC&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> String USER <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#34;root&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> String PASSWORD <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#34;Codingmore123&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> String DATABASE_NAME <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#34;pai_coding&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">try</span> (Connection conn <span style="color:#99d1db;font-weight:bold">=</span> DriverManager.<span style="color:#8caaee">getConnection</span>(URL, USER, PASSWORD);
</span></span><span style="display:flex;"><span>             Statement stmt <span style="color:#99d1db;font-weight:bold">=</span> conn.<span style="color:#8caaee">createStatement</span>()) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (<span style="color:#99d1db;font-weight:bold">!</span>databaseExists(conn, DATABASE_NAME)) {
</span></span><span style="display:flex;"><span>                stmt.<span style="color:#8caaee">executeUpdate</span>(<span style="color:#a6d189">&#34;CREATE DATABASE IF NOT EXISTS &#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> DATABASE_NAME);
</span></span><span style="display:flex;"><span>                System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(<span style="color:#a6d189">&#34;数据库创建成功&#34;</span>);
</span></span><span style="display:flex;"><span>            } <span style="color:#ca9ee6">else</span> {
</span></span><span style="display:flex;"><span>                System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(<span style="color:#a6d189">&#34;数据库已经存在&#34;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#ca9ee6">catch</span> (SQLException e) {
</span></span><span style="display:flex;"><span>            e.<span style="color:#8caaee">printStackTrace</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">boolean</span> <span style="color:#8caaee">databaseExists</span>(Connection conn, String dbName) <span style="color:#e78284">throws</span> SQLException {
</span></span><span style="display:flex;"><span>        ResultSet resultSet <span style="color:#99d1db;font-weight:bold">=</span> conn.<span style="color:#8caaee">getMetaData</span>().<span style="color:#8caaee">getCatalogs</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">while</span> (resultSet.<span style="color:#8caaee">next</span>()) {
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (dbName.<span style="color:#8caaee">equals</span>(resultSet.<span style="color:#8caaee">getString</span>(1))) {
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">true</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>DriverManager.getConnection(URL, USER, PASSWORD)</code>：通过 JDBC 建立到 MySQL 服务器的连接。</p>
<blockquote>
<p>初学者不需要完全明白这些代码</p></blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8908f767bc059121cf9c4b637a826d79">1.7.3 - MySQL数据库查询</h1>
    <div class="lead">在日常的开发工作中，查询语句也是最常用的</div>
	<p>在日常的开发工作中，查询语句也是最常用的，因为表在一开始设计的时候已经确定了，后期很少去修改表结构，也就意味着插入数据的方式也是确定的</p>
<p>但数据的展示方式却千奇百怪，用户端和 admin 管理端可能需要各种各样的数据，那 MySQL 就要提供最接近需求的数据，这样可以节省 Java 程序对数据的转换处理，也就相应提升了程序的性能。</p>
<p><code>SELECT</code> 语句可以灵活组织不同表的数据, 提供最接近需求的组合</p>
<blockquote>
<p>提示:
接下来的操作默认是单库操作
也就是说需要先选中某个数据库,
快去选择吧</p></blockquote>
<h4 id="查询单个字段">查询单个字段<a class="td-heading-self-link" href="#%e6%9f%a5%e8%af%a2%e5%8d%95%e4%b8%aa%e5%ad%97%e6%ae%b5" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p>记录
我们把表中的每一行叫做一个“记录”，每一个记录包含这行中的所有信息，就像在<a href="https://baike.baidu.com/item/%E9%80%9A%E8%AE%AF%E5%BD%95/9635277?fromModule=lemma_inlink">通讯录</a>数据库中某个人全部的信息，但记录在数据库中并没有专门的记录名，常常用它所在的行数表示这是第几个记录。</p></blockquote>
<blockquote>
<p>字段
字段是比记录更小的单位，字段集合组成记录，每个字段描述文献的某一特征，即<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%A1%B9/3227309?fromModule=lemma_inlink">数据项</a>，并有唯一的供计算机识别的<a href="https://baike.baidu.com/item/%E5%AD%97%E6%AE%B5%E6%A0%87%E8%AF%86%E7%AC%A6/53627692?fromModule=lemma_inlink">字段标识符</a>。</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> <span style="color:#e78284">字段名</span> <span style="color:#ca9ee6">FROM</span> <span style="color:#e78284">表名</span>;
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250211000414373.png" alt="image.png"></p>
<h4 id="别名">别名<a class="td-heading-self-link" href="#%e5%88%ab%e5%90%8d" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>查出来的字段名字太长, 先更换名字
可以使用 <code>AS</code> 关键字，格式如下所示</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> <span style="color:#e78284">字段名</span> <span style="color:#ca9ee6">AS</span> <span style="color:#e78284">别名</span> <span style="color:#ca9ee6">FROM</span> <span style="color:#e78284">表名</span>;
</span></span></code></pre></div><p>这通常会在多表进行联合查询或者 Java 程序端和 MySQL 表字段不一致时使用。</p>
<p>比如说，Java 程序端的字段名是 <code>articleTitle</code>，那我们就可以使用别名来解决这个问题。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> title <span style="color:#ca9ee6">AS</span> articleTitle <span style="color:#ca9ee6">FROM</span> article;
</span></span></code></pre></div><h4 id="查询多个字段">查询多个字段<a class="td-heading-self-link" href="#%e6%9f%a5%e8%af%a2%e5%a4%9a%e4%b8%aa%e5%ad%97%e6%ae%b5" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>有时候我们需要同时拿到多个字段</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> <span style="color:#e78284">字段</span><span style="color:#ef9f76">1</span>, <span style="color:#e78284">字段</span><span style="color:#ef9f76">2</span>, <span style="color:#e78284">字段</span><span style="color:#ef9f76">3</span> <span style="color:#ca9ee6">FROM</span> <span style="color:#e78284">表名</span>;
</span></span></code></pre></div><h4 id="查询所有字段">查询所有字段<a class="td-heading-self-link" href="#%e6%9f%a5%e8%af%a2%e6%89%80%e6%9c%89%e5%ad%97%e6%ae%b5" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p>了解
<a href="%E9%80%9A%E9%85%8D%E7%AC%A6.md">通配符</a></p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> <span style="color:#99d1db;font-weight:bold">*</span> <span style="color:#ca9ee6">FROM</span> <span style="color:#e78284">表名</span>;
</span></span></code></pre></div><h4 id="查询结果去重">查询结果去重<a class="td-heading-self-link" href="#%e6%9f%a5%e8%af%a2%e7%bb%93%e6%9e%9c%e5%8e%bb%e9%87%8d" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>有可能多个记录会有相同的字段值, 这很正常
懒得一个个分辨可以去重
使用 <code>DISTINCT</code> 关键字进行查询</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> <span style="color:#ca9ee6">DISTINCT</span> <span style="color:#e78284">字段名</span> <span style="color:#ca9ee6">FROM</span> <span style="color:#e78284">表名</span>;
</span></span></code></pre></div><h4 id="查询结果排序">查询结果排序<a class="td-heading-self-link" href="#%e6%9f%a5%e8%af%a2%e7%bb%93%e6%9e%9c%e6%8e%92%e5%ba%8f" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>当结果集中需要排序时，可以使用 <code>ORDER BY</code> 关键字进行查询，格式如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> <span style="color:#e78284">字段名</span> <span style="color:#ca9ee6">FROM</span> <span style="color:#e78284">表名</span> <span style="color:#ca9ee6">ORDER</span> <span style="color:#ca9ee6">BY</span> <span style="color:#e78284">字段名</span> [<span style="color:#ca9ee6">ASC</span><span style="color:#99d1db;font-weight:bold">|</span><span style="color:#ca9ee6">DESC</span>];
</span></span></code></pre></div><h4 id="查询结果限制条数">查询结果限制条数<a class="td-heading-self-link" href="#%e6%9f%a5%e8%af%a2%e7%bb%93%e6%9e%9c%e9%99%90%e5%88%b6%e6%9d%a1%e6%95%b0" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>我们只想要其中的1条或多条, 从哪里开始找, 查找几行结束</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> <span style="color:#e78284">字段名</span> <span style="color:#ca9ee6">FROM</span> <span style="color:#e78284">表名</span> <span style="color:#ca9ee6">LIMIT</span> <span style="color:#e78284">开始行</span>,<span style="color:#e78284">行数</span>;
</span></span></code></pre></div><blockquote>
<p>开始行也叫偏移量（OFFSET），默认是 0，可以缺省。</p></blockquote>
<blockquote>
<p>了解:
<a href="/java/basic/mysql/mysql%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/">MySQL条件查询</a></p></blockquote>
<h4 id="统计">统计<a class="td-heading-self-link" href="#%e7%bb%9f%e8%ae%a1" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>返回记录数</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> <span style="color:#ca9ee6">COUNT</span>(ProductID) <span style="color:#ca9ee6">FROM</span> Products;
</span></span></code></pre></div><blockquote>
<p>注意
此方法会忽略NULL记录!</p>
<p>COUNT(1)</p>
<p>COUNT(<code>*</code>)</p>
<p><code>count(1)</code> 是计算所有记录数，<code>1</code> 被视作一个常数值，在每一行都存在，因此与 <code>count(*)</code> 基本相同。</p></blockquote>
<h4 id="mysql的数据引擎有哪些">mysql的数据引擎有哪些?<a class="td-heading-self-link" href="#mysql%e7%9a%84%e6%95%b0%e6%8d%ae%e5%bc%95%e6%93%8e%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>区别是什么?</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8ebe80fc40bfabb67174586fde900fd3">1.7.4 - MySQL数据类型</h1>
    <div class="lead">当我们要创建表的时候，就要根据业务需求，选择合适的数据类型。</div>
	<p>表是由不同数据类型的列组成的，然后填充了一行一行的数据。当我们要创建表的时候，就要根据业务需求，选择合适的数据类型。</p>
<h4 id="整数类型">整数类型<a class="td-heading-self-link" href="#%e6%95%b4%e6%95%b0%e7%b1%bb%e5%9e%8b" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><table>
  <thead>
      <tr>
          <th>类型名称</th>
          <th>存储空间</th>
          <th>范围</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>tinyint</td>
          <td>1 字节</td>
          <td>-128 到 127 或者 0 到 255</td>
      </tr>
      <tr>
          <td>int</td>
          <td>4 字节</td>
          <td>-2147483648 到 2147483647 或者 0 到 4294967295</td>
      </tr>
      <tr>
          <td>bigint</td>
          <td>8 字节</td>
          <td>-9223372036854775808 到 9223372036854775807 或者 0 到 18446744073709551615</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>其实还有个 2 字节的 smallint 但是不常用</p></blockquote>
<p>设计表时</p>
<ul>
<li>对于状态\类型字段使用 <code>tinyint</code></li>
<li>记录id, 主键id等使用 <code>bigint</code></li>
<li>其他用<code>int</code></li>
</ul>
<h5 id="符号">符号?<a class="td-heading-self-link" href="#%e7%ac%a6%e5%8f%b7" aria-label="Heading self-link"></a></h5>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>这里注意, MySQL是存在有/无符号整型之分的, Java默认有符号</p>
<p>当涉及到负数表示时, 为了兼容, Java中必须使用<code>Long</code> 型</p>
<p>因为Java的<code>int</code>范围和MySQL不同分别是-2147483648 到 2147483647, 和 0 到 4294967295(无符号)</p>
<p>所以在设计表时, 整数的符号也要考虑</p>
<p>像自增 ID，肯定是无符号的，所以我们会在定义的时候将其设置为 <code>unsigned</code></p>
<h5 id="显示宽度">显示宽度?<a class="td-heading-self-link" href="#%e6%98%be%e7%a4%ba%e5%ae%bd%e5%ba%a6" aria-label="Heading self-link"></a></h5>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">CREATE</span> <span style="color:#ca9ee6">TABLE</span> <span style="color:#99d1db;font-weight:bold">`</span>test<span style="color:#99d1db;font-weight:bold">`</span> (
</span></span><span style="display:flex;"><span>  <span style="color:#99d1db;font-weight:bold">`</span>id<span style="color:#99d1db;font-weight:bold">`</span> <span style="color:#99d1db">int</span>(<span style="color:#ef9f76">10</span>) unsigned <span style="color:#ca9ee6">NOT</span> <span style="color:#ca9ee6">NULL</span> AUTO_INCREMENT,
</span></span><span style="display:flex;"><span>  <span style="color:#99d1db;font-weight:bold">`</span>int10<span style="color:#99d1db;font-weight:bold">`</span> <span style="color:#99d1db">int</span>(<span style="color:#ef9f76">10</span>) <span style="color:#ca9ee6">NOT</span> <span style="color:#ca9ee6">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#99d1db;font-weight:bold">`</span>int11<span style="color:#99d1db;font-weight:bold">`</span> <span style="color:#99d1db">int</span>(<span style="color:#ef9f76">11</span>) <span style="color:#ca9ee6">NOT</span> <span style="color:#ca9ee6">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#99d1db;font-weight:bold">`</span><span style="color:#99d1db">int</span><span style="color:#99d1db;font-weight:bold">`</span> <span style="color:#99d1db">int</span> <span style="color:#ca9ee6">NOT</span> <span style="color:#ca9ee6">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#ca9ee6">PRIMARY</span> <span style="color:#ca9ee6">KEY</span> (<span style="color:#99d1db;font-weight:bold">`</span>id<span style="color:#99d1db;font-weight:bold">`</span>)
</span></span><span style="display:flex;"><span>) ENGINE<span style="color:#99d1db;font-weight:bold">=</span>InnoDB <span style="color:#ca9ee6">DEFAULT</span> CHARSET<span style="color:#99d1db;font-weight:bold">=</span>utf8mb4;
</span></span></code></pre></div><p>经常设计表的同学知道, <code>int(10)</code> 和 <code>int(11)</code> 指的是显示宽度的不同, 这里不涉及精度的问题, 多余的位用0填充</p>
<p>就是视觉规定而已</p>
<blockquote>
<p>了解
<a href="https://alex.kirk.at/2007/08/24/what-does-size-in-intsize-of-mysql-mean/">ALEX</a> 的博客写的很好</p></blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ac7b3d70780cd7381ef9141dc7bcceeb">1.7.5 - MySQL条件查询</h1>
    <div class="lead">真实的业务场景中，数量会非常大，有些甚至会有几百万、几千万条数据，如果不带上查询条件，一次性把全部数据查出来是不太现实的。</div>
	<p>SELECT 查询没有查询条件。比如只返回姓名为xx的人, 年龄为xx的人等条件</p>
<p>要知道，真实的业务场景中，数量会非常大，有些甚至会有几百万、几千万条数据，如果不带上查询条件，一次性把全部数据查出来是不太现实的。</p>
<p>所以，我们通常要求在执行 SELECT 查询时，都要带上查询条件。那这一节，我们就来学习一些简单的 WHERE 条件查询。</p>
<h4 id="查询操作符">查询操作符<a class="td-heading-self-link" href="#%e6%9f%a5%e8%af%a2%e6%93%8d%e4%bd%9c%e7%ac%a6" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><table>
  <thead>
      <tr>
          <th>操作符</th>
          <th>示例</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>=</code></td>
          <td><code>user_id = 1</code></td>
          <td>等于</td>
      </tr>
      <tr>
          <td><code>!=</code> 或 <code>&lt;&gt;</code></td>
          <td><code>user_id != 1</code> 或 <code>user_id &lt;&gt; 1</code></td>
          <td>不等于</td>
      </tr>
      <tr>
          <td><code>&gt;</code></td>
          <td><code>user_id &gt; 1</code></td>
          <td>大于</td>
      </tr>
      <tr>
          <td><code>&lt;</code></td>
          <td><code>user_id &lt; 1</code></td>
          <td>小于</td>
      </tr>
      <tr>
          <td><code>&gt;=</code></td>
          <td><code>user_id &gt;= 1</code></td>
          <td>大于等于</td>
      </tr>
      <tr>
          <td><code>&lt;=</code></td>
          <td><code>user_id &lt;= 1</code></td>
          <td>小于等于</td>
      </tr>
  </tbody>
</table>
<p>示例:
查找id大于1000的文章</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> title, user_id, create_time <span style="color:#ca9ee6">FROM</span> article <span style="color:#ca9ee6">WHERE</span> user_id <span style="color:#99d1db;font-weight:bold">&gt;</span> <span style="color:#ef9f76">1000</span>;
</span></span></code></pre></div><h4 id="区间查询">区间查询<a class="td-heading-self-link" href="#%e5%8c%ba%e9%97%b4%e6%9f%a5%e8%af%a2" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>利用一个 <code>&gt;=</code> 和一个 <code>&lt;=</code>，配合 <code>AND</code> 关键字，就可以实现区间查询</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> <span style="color:#e78284">字段名</span> <span style="color:#ca9ee6">FROM</span> <span style="color:#e78284">表</span> <span style="color:#ca9ee6">WHERE</span> user_id <span style="color:#99d1db;font-weight:bold">&gt;=</span> <span style="color:#ef9f76">1000</span> <span style="color:#ca9ee6">AND</span> user_id <span style="color:#99d1db;font-weight:bold">&lt;=</span> <span style="color:#ef9f76">2000</span>;
</span></span></code></pre></div><p>查询上下界id为1000 到 2000 的文章</p>
<blockquote>
<p>其实就是规定上下界
所以可以用 <code>BETWEEN</code> 代替</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> title, user_id, create_time <span style="color:#ca9ee6">FROM</span> article <span style="color:#ca9ee6">WHERE</span> user_id <span style="color:#ca9ee6">BETWEEN</span> <span style="color:#ef9f76">1000</span> <span style="color:#ca9ee6">AND</span> <span style="color:#ef9f76">2000</span>;
</span></span></code></pre></div><p>取反也可以, 加上 <code>NOT</code> 就行</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> title, user_id, create_time <span style="color:#ca9ee6">FROM</span> article <span style="color:#ca9ee6">WHERE</span> user_id <span style="color:#ca9ee6">NOT</span> <span style="color:#ca9ee6">BETWEEN</span> <span style="color:#ef9f76">1000</span> <span style="color:#ca9ee6">AND</span> <span style="color:#ef9f76">2000</span>;
</span></span></code></pre></div><blockquote>
<p>感觉比Python简单</p></blockquote>
<h4 id="枚举查询">枚举查询<a class="td-heading-self-link" href="#%e6%9e%9a%e4%b8%be%e6%9f%a5%e8%af%a2" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>当区间为1, 其实就是枚举, 这就不需要指定上下界了
我们可以直接指定数值 用 <code>IN</code></p>
<p>查询 user_id 是 1、2、3 的文章</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> title, user_id, create_time <span style="color:#ca9ee6">FROM</span> article <span style="color:#ca9ee6">WHERE</span> user_id <span style="color:#ca9ee6">IN</span> (<span style="color:#ef9f76">1</span>, <span style="color:#ef9f76">2</span>, <span style="color:#ef9f76">3</span>); 
</span></span></code></pre></div><p>当然可以取反. 此略</p>
<h4 id="逻辑操作符">逻辑操作符<a class="td-heading-self-link" href="#%e9%80%bb%e8%be%91%e6%93%8d%e4%bd%9c%e7%ac%a6" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>除了数据操作符外还可以进行逻辑判断</p>
<p>其实上文的 <code>AND</code> 就是一个</p>
<p><code>AND</code> 操作符用于组合多个查询条件，只有当所有的条件都满足时，才会返回结果</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> title, user_id, create_time <span style="color:#ca9ee6">FROM</span> article <span style="color:#ca9ee6">WHERE</span> user_id <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">1</span> <span style="color:#ca9ee6">AND</span> title <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#39;something&#39;</span>;
</span></span></code></pre></div><p><code>OR</code>与其类似</p>
<p>可以使用<code>()</code> 指定优先级</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> title, user_id, create_time <span style="color:#ca9ee6">FROM</span> article <span style="color:#ca9ee6">WHERE</span> user_id <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">1</span> <span style="color:#ca9ee6">AND</span> (title <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#39;聊聊分库分表&#39;</span> <span style="color:#ca9ee6">OR</span> short_title <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#a6d189">&#39;&#39;</span>);
</span></span></code></pre></div><p><code>in</code></p>
<p>in查询相当于多个or条件的叠加，这个比较好理解，比如下面的查询：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">select</span> <span style="color:#99d1db;font-weight:bold">*</span> <span style="color:#ca9ee6">from</span> <span style="color:#ca9ee6">user</span> <span style="color:#ca9ee6">where</span> user_id <span style="color:#ca9ee6">in</span> (<span style="color:#ef9f76">1</span>, <span style="color:#ef9f76">2</span>, <span style="color:#ef9f76">3</span>);
</span></span></code></pre></div><p><code>exists</code></p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">select</span> <span style="color:#99d1db;font-weight:bold">*</span> <span style="color:#ca9ee6">from</span> <span style="color:#ca9ee6">user</span> <span style="color:#ca9ee6">where</span> <span style="color:#ca9ee6">exists</span> (<span style="color:#ca9ee6">select</span> <span style="color:#99d1db;font-weight:bold">*</span> <span style="color:#ca9ee6">from</span> <span style="color:#ca9ee6">user</span> <span style="color:#ca9ee6">where</span> user_id <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ef9f76">0</span>);
</span></span></code></pre></div><p>这两个都是条件嵌套</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bb859bbb6df88f0d22408f9500f306f5">1.7.6 - MySQL索引</h1>
    <div class="lead">除了对于准备面试来说非常重要之外，善用索引对 SQL 的性能提升非常明显，是一个性价比较高的 SQL 优化手段。</div>
	<h4 id="索引介绍">索引介绍<a class="td-heading-self-link" href="#%e7%b4%a2%e5%bc%95%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>我们知道一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，所以查询语句的优化显然是重中之重。</p>
<p>**索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。通过存储指向数据行的指针，可以快速定位和访问表中的特定数据。</p>
<p>开始之前, 我们直观的体会下索引</p>
<p>如果要查询 mysql 单词, 我们就需要字符匹配, 首先是 m, y 之后是 s,q l
在接近上万条的记录中我们需要把整个表过一遍, 天哪
因此索引的目的就是为了缩小搜索范围来获取想要的数据结果
很容易想到将表分段, 通过确定某个分段的方式来获取数据</p>
<blockquote>
<p>了解:
<a href="%E9%82%A3%E4%BA%9B%E7%88%B1%E8%BF%87%E7%9A%84%E6%A0%91,%E5%B7%B2%E7%BB%8F%E9%95%BF%E6%88%90%E4%BA%86%E6%A3%AE%E6%9E%97.md">数据结构-树</a></p></blockquote>
<h4 id="索引的类型">索引的类型<a class="td-heading-self-link" href="#%e7%b4%a2%e5%bc%95%e7%9a%84%e7%b1%bb%e5%9e%8b" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><h5 id="主键索引">主键索引:<a class="td-heading-self-link" href="#%e4%b8%bb%e9%94%ae%e7%b4%a2%e5%bc%95" aria-label="Heading self-link"></a></h5>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>数据表的主键列使用的就是主键索引。</p>
<p>一张数据表只能有一个主键, 并且不能重复, 不能为NULL</p>
<p>INNODB中, 引擎在没有显示指定主键的情况下, 会优先判断检查是否有唯一索引且没有NULL的字段, 如果有就选择该字段为默认的主键, 否则引擎自动创建一个自增主键</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-095d53f7f8ca5978bc69f27bf77a4e19">1.7.7 - MySQL表操作</h1>
    <div class="lead">有了数据库以后，我们就可以在数据库中对表进行增删改查了</div>
	<p>有了数据库以后，我们就可以在数据库中对表进行增删改查了</p>
<p>MySQL是关系型数据库, 这个名词通俗来说就是把世界上的一切物体都实体化, 通过属性之间的关系管理数据</p>
<p>实体化的结果叫做表, 数据库中以表为组织单位存储数据</p>
<h4 id="查表">查表<a class="td-heading-self-link" href="#%e6%9f%a5%e8%a1%a8" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>首先指定数据库</p>
<p>查看当前数据库中的所有表，可以使用 </p>
<p><code>show tables</code></p>
<p>不首先指定数据库的话</p>
<p><code>show tables from 数据库名;</code></p>
<blockquote>
<p>提示:
这是查看表名的操作, 跟表结构没关系</p></blockquote>
<h4 id="建表">建表<a class="td-heading-self-link" href="#%e5%bb%ba%e8%a1%a8" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">create</span> <span style="color:#ca9ee6">table</span> <span style="color:#e78284">表名</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">列名</span><span style="color:#ef9f76">1</span> <span style="color:#e78284">数据类型</span><span style="color:#ef9f76">1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">列名</span><span style="color:#ef9f76">2</span> <span style="color:#e78284">数据类型</span><span style="color:#ef9f76">2</span>,
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">列名</span>n <span style="color:#e78284">数据类型</span>n
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><blockquote>
<p>了解:
<a href="/java/basic/mysql/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">MySQL数据类型</a></p></blockquote>
<p>这里可能会遇到问题</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210235135096.png" alt="image.png"></p>
<p>指示表已经存在了, 这时只能删掉以前的表
为了避免这种情况，我们可以在建表的时候，先判断表是否存在，如果不存在，再创建表，语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">create</span> <span style="color:#ca9ee6">table</span> <span style="color:#ca9ee6">if</span> <span style="color:#ca9ee6">not</span> <span style="color:#ca9ee6">exists</span> <span style="color:#e78284">表名</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">列名</span><span style="color:#ef9f76">1</span> <span style="color:#e78284">数据类型</span><span style="color:#ef9f76">1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">列名</span><span style="color:#ef9f76">2</span> <span style="color:#e78284">数据类型</span><span style="color:#ef9f76">2</span>,
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">列名</span>n <span style="color:#e78284">数据类型</span>n
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><h4 id="注释">注释<a class="td-heading-self-link" href="#%e6%b3%a8%e9%87%8a" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>是的, 表也有注释, 在上百张表的情况下, 注释就很重要了</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">create</span> <span style="color:#ca9ee6">table</span> <span style="color:#e78284">表名</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">列名</span><span style="color:#ef9f76">1</span> <span style="color:#e78284">数据类型</span><span style="color:#ef9f76">1</span> <span style="color:#ca9ee6">comment</span> <span style="color:#a6d189">&#39;注释1&#39;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">列名</span><span style="color:#ef9f76">2</span> <span style="color:#e78284">数据类型</span><span style="color:#ef9f76">2</span> <span style="color:#ca9ee6">comment</span> <span style="color:#a6d189">&#39;注释2&#39;</span>,
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">列名</span>n <span style="color:#e78284">数据类型</span>n <span style="color:#ca9ee6">comment</span> <span style="color:#a6d189">&#39;注释n&#39;</span>
</span></span><span style="display:flex;"><span>) <span style="color:#ca9ee6">comment</span> <span style="color:#a6d189">&#39;表注释&#39;</span>;
</span></span></code></pre></div><h4 id="查看表结构">查看表结构<a class="td-heading-self-link" href="#%e6%9f%a5%e7%9c%8b%e8%a1%a8%e7%bb%93%e6%9e%84" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">desc</span> <span style="color:#e78284">表名</span>;
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">describe</span> <span style="color:#e78284">表名</span>;
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">explain</span> <span style="color:#e78284">表名</span>;
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">show</span> columns <span style="color:#ca9ee6">from</span> <span style="color:#e78284">表名</span>;
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">show</span> fields <span style="color:#ca9ee6">from</span> <span style="color:#e78284">表名</span>;
</span></span></code></pre></div><p>上述指令效果完全一样</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250210235526115.png" alt="image.png"></p>
<h4 id="改表">改表<a class="td-heading-self-link" href="#%e6%94%b9%e8%a1%a8" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>这需要一些数据库底层原理基础知识才能操作, 此处略过</p>
<blockquote>
<p>了解
<a href="/java/basic/mysql/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2/">MySQL数据库简单查询</a>
<a href="/java/basic/mysql/mysql%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/">MySQL字符集和比较规则</a></p></blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-04d36435c7ee74ec811b541c12267369">1.7.8 - MySQL连接</h1>
    <div class="lead">在前几章节中，我们已经学会了如何在一张表中读取数据，这是相对简单的，但是在真正的应用中经常需要从多个数据表中读取数据。</div>
	<p>在前几章节中，我们已经学会了如何在一张表中读取数据，这是相对简单的，但是在真正的应用中经常需要从多个数据表中读取数据。</p>
<p>连接分为三种 内,  左, 右</p>
<h4 id="内连接">内连接<a class="td-heading-self-link" href="#%e5%86%85%e8%bf%9e%e6%8e%a5" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>INNER JOIN 返回两个表中满足连接条件的匹配行，以下是 INNER JOIN 语句的基本语法</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> column1, column2, ...
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">FROM</span> table1
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">INNER</span> <span style="color:#ca9ee6">JOIN</span> table2 <span style="color:#ca9ee6">ON</span> table1.<span style="color:#ca9ee6">column_name</span> <span style="color:#99d1db;font-weight:bold">=</span> table2.<span style="color:#ca9ee6">column_name</span>;
</span></span></code></pre></div><ul>
<li><code>table1.column_name = table2.column_name</code> 是连接条件，指定了两个表中用于匹配的列。</li>
</ul>
<h4 id="左连接">左连接<a class="td-heading-self-link" href="#%e5%b7%a6%e8%bf%9e%e6%8e%a5" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>LEFT JOIN 返回左表的所有行，并包括右表中匹配的行，如果右表中没有匹配的行，将返回 NULL 值，以下是 LEFT JOIN 语句的基本语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ca9ee6">SELECT</span> column1, column2, ...
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">FROM</span> table1
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">LEFT</span> <span style="color:#ca9ee6">JOIN</span> table2 <span style="color:#ca9ee6">ON</span> table1.<span style="color:#ca9ee6">column_name</span> <span style="color:#99d1db;font-weight:bold">=</span> table2.<span style="color:#ca9ee6">column_name</span>;
</span></span></code></pre></div><p>返回左表的所有行, 如果右表没有匹配就为NULL</p>
<h4 id="右连接">右连接<a class="td-heading-self-link" href="#%e5%8f%b3%e8%bf%9e%e6%8e%a5" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>不常使用, 因为可以用左连接交换表顺序达到相同效果</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-0ca269ceb9541e7f1eb615a64e7ebf27">1.7.9 - 事务</h1>
    <div class="lead">在关系型数据库中，事务的重要性不言而喻，只要对数据库稍有了解的人都知道事务具有 ACID 四个基本属性</div>
	<blockquote>
<p>引用:
go语言大佬, go语言设计与原理作者
[面向信仰编程 - draveness](<a href="https://draveness.me/mysql-innodb/">https://draveness.me/mysql-innodb/</a></p></blockquote>
<p>在关系型数据库中，事务的重要性不言而喻，只要对数据库稍有了解的人都知道事务具有 ACID 四个基本属性，</p>
<p>而我们不知道的可能就是数据库是如何实现这四个属性的；在这篇文章中，我们将对事务的实现进行分析，尝试理解数据库是如何实现事务的，当然我们也会在文章中简单对 MySQL 中对 ACID 的实现进行简单的介绍。</p>
<p>原子性, 一致性, 隔离性, 持久性
ACID</p>
<h4 id="原子性">原子性<a class="td-heading-self-link" href="#%e5%8e%9f%e5%ad%90%e6%80%a7" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>事务就是一系列的操作，要么全部都执行，要都不执行，这其实就是对事务原子性的刻画</p>
<p>如果事务不具备原子性，那么就没办法保证同一个事务中的所有操作都被执行或者未被执行了，整个数据库系统就既不可用也不可信。</p>
<blockquote>
<p>数据库的事务提交也是多线程并发的, 适用并发编程</p></blockquote>
<h4 id="持久性">持久性<a class="td-heading-self-link" href="#%e6%8c%81%e4%b9%85%e6%80%a7" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250211011722492.png" alt="image.png"></p>
<p>数据被写入到数据库中，那么数据一定能够被安全存储在磁盘上, 这就是持久性</p>
<p>可能会奇怪, 除非硬盘挂掉, 为什么会存在持久性问题呢</p>
<p>其实持久性并非问题, 而是一种原则</p>
<p>一旦事务被提交，那么数据一定会被写入到数据库中并持久存储起来。
也就是当数据被写到硬盘后, 不允许撤销!</p>
<blockquote>
<p><em>当事务已经被提交之后，就无法再次回滚了，唯一能够撤回已经提交的事务的方式就是创建一个相反的事务对原操作进行『补偿』，这也是事务持久性的体现之一。</em></p></blockquote>
<h4 id="隔离性">隔离性<a class="td-heading-self-link" href="#%e9%9a%94%e7%a6%bb%e6%80%a7" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>数据库的事务之间没有隔离性, 就会发生级联回滚的问题, 造成性能上的巨大损失</p>
<p>如果所有的事务的执行顺序都是线性的，那么对于事务的管理容易得多，但是允许事务的并行执行却能能够提升吞吐量和资源利用率，并且可以减少每个事务的等待时间。</p>
<h4 id="一致性">一致性<a class="td-heading-self-link" href="#%e4%b8%80%e8%87%b4%e6%80%a7" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>分为两种一致性</p>
<p>ACID 和 CAP</p>
<p>其中ACID定义为, 如果事务原子性的一个一致的数据库中独立运行, 那么执行之后数据库的状态是一定的, 在事务的执行的前后以及过程中不会违背对数据完整性的约束, 所有对数据库写入的操作都应该是合法的，并不能产生不合法的数据状态。</p>
<p>CAP则是通常的一致性, 其实是说分布式系统中的各个节点中对于同一数据的拷贝有着相同的值, 也就是存储可见性</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-3f6264d453c28a09c23b292e07d0d7de">1.7.10 - 数据库设计规范</h1>
    <div class="lead">数据库的三大范式，它是数据库设计中最基本的三个规范</div>
	<p>数据库的三大范式，它是数据库设计中最基本的三个规范，那么，三大范式是什么？在实际开发中，我们一定要严格遵守三大范式吗？</p>
<h4 id="第一范式">第一范式<a class="td-heading-self-link" href="#%e7%ac%ac%e4%b8%80%e8%8c%83%e5%bc%8f" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>确保每列原子性
也就是字段的值是原子的, 不可再分割</p>
<h4 id="第二范式">第二范式<a class="td-heading-self-link" href="#%e7%ac%ac%e4%ba%8c%e8%8c%83%e5%bc%8f" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>确保表中的每列和主键相关</p>
<p>第二范式在第一范式的基础上, 消除表的部分依赖</p>
<p>即非主键字段必须完全依赖于主键，而不是仅依赖于主键的一部分。</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250212002938008.png" alt="image.png"></p>
<p>这里和订单id(主键) 有关的只有数量和商品ID</p>
<p>拆成两张表</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250212003059979.png" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250212003105718.png" alt="image.png"></p>
<h4 id="第三范式">第三范式<a class="td-heading-self-link" href="#%e7%ac%ac%e4%b8%89%e8%8c%83%e5%bc%8f" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>确保每列都与主键列直接相关, 而不是间接相关</p>
<p>在第二范式的基础上, 消除表的传递依赖</p>
<p>所有非主键字段必须直接依赖于主键，而不是通过其他非主键字段间接依赖。</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250212004058261.png" alt="image.png"></p>
<p>在这个表中，<code>部门名称</code>依赖于<code>部门ID</code>，而<code>部门ID</code>依赖于主键<code>员工ID</code>，形成了传递依赖，违反了3NF。</p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-4315e9814bd8608b77147cd960f728ea">1.8 - 工厂方法</h1>
    <div class="lead">定义一个用于创建对象的接口，让子类决定实例化哪一个类。</div>
	
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d9055392eb71058d8d40e7407bf4927f">1.9 - 模板方法</h1>
    <div class="lead">模板类定义了实现功能的步骤, 但是具体实现需要子类提供. 这使得一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</div>
	<blockquote>
<p><em>模板方法的核心在于定义一个“骨架”。</em></p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">abstract</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">Worker</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">protected</span> String name;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#8caaee">Worker</span>(String name)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#ca9ee6">this</span>.<span style="color:#8caaee">name</span> <span style="color:#99d1db;font-weight:bold">=</span> name;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * 记录一天的工作
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#e78284">final</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">workOneDay</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(<span style="color:#a6d189">&#34;-----------------work start ---------------&#34;</span>);
</span></span><span style="display:flex;"><span>		enterCompany();
</span></span><span style="display:flex;"><span>		computerOn();
</span></span><span style="display:flex;"><span>		work();
</span></span><span style="display:flex;"><span>		computerOff();
</span></span><span style="display:flex;"><span>		exitCompany();
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(<span style="color:#a6d189">&#34;-----------------work end ---------------&#34;</span>);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * 打代码
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#e78284">abstract</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">work</span>();
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * 关闭电脑
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">private</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">computerOff</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(name <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;关闭电脑&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * 打开电脑
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">private</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">computerOn</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(name <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;打开电脑&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * 进入公司
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">enterCompany</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(name <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;进入公司&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * 离开公司
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">exitCompany</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(name <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;离开公司&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中大部分方法都实现了(演示方便, 有返回值就行)
唯独打代码没实现, 那么这个方法延迟到子类实现, 我们看下孩子们是如何实现的
劳大:</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">ITWorker</span> <span style="color:#e78284">extends</span> Worker
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#8caaee">ITWorker</span>(String name)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#e78284">super</span>(name);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#8caaee;font-weight:bold">@Override</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">work</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(name <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;孩子们快跑, 我在finally返回了&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>皮衣黄</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">HRWorker</span> <span style="color:#e78284">extends</span> Worker
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#8caaee">HRWorker</span>(String name)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#e78284">super</span>(name);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#8caaee;font-weight:bold">@Override</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">work</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(name <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;孩子们快跑, deepseek跳过了CUDA&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>马圣</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">QAWorker</span> <span style="color:#e78284">extends</span> Worker
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#8caaee">QAWorker</span>(String name)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#e78284">super</span>(name);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#8caaee;font-weight:bold">@Override</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">work</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(name <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;孩子们快跑, DOGE要开人啦&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这样所有子类只需完成小部分逻辑即可实现功能</p>
<p>![[content/en/java/Basic/Concurrent/Pasted image 20250203230102.png]]</p>
<h4 id="钩子">钩子<a class="td-heading-self-link" href="#%e9%92%a9%e5%ad%90" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p>[!NOTE]
钩子的由来：</p>
<ul>
<li><strong>“钩子”</strong> 这个名字形象地表达了方法在模板方法模式中的角色：它就像一个钩子，可以被子类“挂”上去（重写），也可以“留空”。</li>
<li>子类重写钩子方法，就相当于“挂”上去了，它能改变或增加一些行为；如果不重写钩子方法，就相当于“没挂”——这时模板方法会使用父类提供的默认实现。</li>
<li>可以当成开关理解</li>
</ul></blockquote>
<p>父类可以留几个钩子
比如是否打印时间</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">boolean</span> <span style="color:#8caaee">isNeedPrintDate</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">false</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 * 离开公司
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">exitCompany</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#ca9ee6">if</span> (isNeedPrintDate())
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">print</span>(<span style="color:#ca9ee6">new</span> Date().<span style="color:#8caaee">toLocaleString</span>()<span style="color:#99d1db;font-weight:bold">+</span><span style="color:#a6d189">&#34;--&gt;&#34;</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(name <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;离开公司&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>子类重写钩子, 就可以选择算法分支了, 也就是是否打印时间</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>	<span style="color:#8caaee;font-weight:bold">@Override</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> <span style="color:#e78284">boolean</span> <span style="color:#8caaee">isNeedPrintDate</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">true</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span></code></pre></div><p>总结:
其实模板方法就是把一类操作提取出统一的逻辑
将不同的参数, 细节等延迟到子类实现</p>
<blockquote>
<p>[!引用]
<a href="https://blog.csdn.net/lmj623565791/article/details/26276093">https://blog.csdn.net/lmj623565791/article/details/26276093</a></p></blockquote>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a841198d5abd16a2b0310d3e513b50ad">1.10 - 通配符</h1>
    <div class="lead">In software, a wildcard character is a kind of placeholder represented by a single character, such as an asterisk (*), which can be interpreted as a number of literal characters or an empty string. It is often used in file searches so the full name need not be typed.</div>
	<blockquote>
<p>In software, a wildcard character is a kind of placeholder represented by a single character, such as an asterisk (*), which can be interpreted as a number of literal characters or an empty string. It is often used in file searches so the full name need not be typed.</p>
<p>简单来说, 使用通配符来进行模糊查询</p></blockquote>
<h4 id="-通配符"><code>%</code> 通配符<a class="td-heading-self-link" href="#-%e9%80%9a%e9%85%8d%e7%ac%a6" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p><code>%</code> 通配符用于匹配任意长度的字符串，包括零长度，在查询文章标题、用户名等此类字段时，会非常有用。</p>
<h4 id="-通配符-1"><code>*</code> 通配符<a class="td-heading-self-link" href="#-%e9%80%9a%e9%85%8d%e7%ac%a6-1" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>代表匹配所有值</p>
<h4 id="-参数占位符"><code>?</code> 参数占位符<a class="td-heading-self-link" href="#-%e5%8f%82%e6%95%b0%e5%8d%a0%e4%bd%8d%e7%ac%a6" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>插值表达式传参使用</p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-cb92de0a4259bd45f476feb25241d160">2 - Java进阶能力</h1>
    
	<p>内容来源:</p>
<ul>
<li>沉默王二 GitHub 上开源的知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">Java 进阶之路</a>》</li>
<li><a href="https://www.rabbitmq.com/tutorials">rabbitMQ</a></li>
<li><a href="https://javaguide.cn/">JavaGuide</a></li>
<li><a href="https://www.zhihu.com/question/19730582/answer/1663627873">知乎-阿里大淘宝</a></li>
</ul>
<p>Java进阶能力
Java作为一门编程语言, 需要和其他组件一起完成某个项目
一名好的程序员不仅要知道去哪里import, 更要知道import什么组件, 甚至为组件贡献代码</p>
<ul>
<li>Redis</li>
<li>WebSocket</li>
<li>FastExcel报表</li>
<li>Gateway网关(SpringCloudGateway)</li>
<li>中间件
<ul>
<li>消息队列</li>
<li>Nacos配置中心</li>
<li>Sential声明式服务</li>
</ul>
</li>
</ul>
<p>需要相关模块依赖, 如下是模块的实例</p>
<p><code>wms-sample-mq</code> 模块
<code>pom.xml</code></p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>  
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">&lt;project</span> <span style="color:#8caaee">xmlns=</span><span style="color:#a6d189">&#34;http://maven.apache.org/POM/4.0.0&#34;</span> <span style="color:#8caaee">xmlns:xsi=</span><span style="color:#a6d189">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#8caaee">xsi:schemaLocation=</span><span style="color:#a6d189">&#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&#34;</span><span style="color:#ca9ee6">&gt;</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">&lt;modelVersion&gt;</span>4.0.0<span style="color:#ca9ee6">&lt;/modelVersion&gt;</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">&lt;parent&gt;</span>        <span style="color:#ca9ee6">&lt;groupId&gt;</span>com.hamhuo.star<span style="color:#ca9ee6">&lt;/groupId&gt;</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">&lt;artifactId&gt;</span>wms-java<span style="color:#ca9ee6">&lt;/artifactId&gt;</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">&lt;version&gt;</span>${revision}<span style="color:#ca9ee6">&lt;/version&gt;</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">&lt;relativePath&gt;</span>../pom.xml<span style="color:#ca9ee6">&lt;/relativePath&gt;</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">&lt;/parent&gt;</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">&lt;artifactId&gt;</span>wms-sample<span style="color:#ca9ee6">&lt;/artifactId&gt;</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">&lt;dependencies&gt;</span>        <span style="color:#737994;font-style:italic">&lt;!-- spring mvc --&gt;</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">&lt;dependency&gt;</span>  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">&lt;groupId&gt;</span>org.springframework.boot<span style="color:#ca9ee6">&lt;/groupId&gt;</span>  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">&lt;artifactId&gt;</span>spring-boot-starter-web<span style="color:#ca9ee6">&lt;/artifactId&gt;</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">&lt;/dependency&gt;</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">&lt;!-- common --&gt;</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">&lt;dependency&gt;</span>  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">&lt;groupId&gt;</span>com.hamhuo<span style="color:#ca9ee6">&lt;/groupId&gt;</span>  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">&lt;artifactId&gt;</span>wms-common<span style="color:#ca9ee6">&lt;/artifactId&gt;</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">&lt;/dependency&gt;</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">&lt;dependency&gt;</span>            <span style="color:#ca9ee6">&lt;groupId&gt;</span>com.hamhuo.star<span style="color:#ca9ee6">&lt;/groupId&gt;</span>  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">&lt;artifactId&gt;</span>wms-domain<span style="color:#ca9ee6">&lt;/artifactId&gt;</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">&lt;/dependency&gt;</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">&lt;!-- alibaba nacos discovery --&gt;</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">&lt;dependency&gt;</span>  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">&lt;groupId&gt;</span>com.alibaba.cloud<span style="color:#ca9ee6">&lt;/groupId&gt;</span>  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span style="color:#ca9ee6">&lt;/artifactId&gt;</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">&lt;/dependency&gt;</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">&lt;!-- alibaba nacos config --&gt;</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">&lt;dependency&gt;</span>  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">&lt;groupId&gt;</span>com.alibaba.cloud<span style="color:#ca9ee6">&lt;/groupId&gt;</span>  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-nacos-config<span style="color:#ca9ee6">&lt;/artifactId&gt;</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">&lt;/dependency&gt;</span>   
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">&lt;/dependencies&gt;</span>  
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">&lt;/project&gt;</span>
</span></span></code></pre></div><p>启动类</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * &lt;p&gt; 描述：模块程序启动入口  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * &lt;/p&gt;  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#8caaee;font-weight:bold">@SpringBootApplication</span>  
</span></span><span style="display:flex;"><span><span style="color:#8caaee;font-weight:bold">@EnableDiscoveryClient</span>  
</span></span><span style="display:flex;"><span><span style="color:#8caaee;font-weight:bold">@EnableBinding</span>(Source.<span style="color:#8caaee">class</span>)  
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">MqApplication</span> {  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) {  
</span></span><span style="display:flex;"><span>        SpringApplication.<span style="color:#8caaee">run</span>(MqApplication.<span style="color:#8caaee">class</span>, args);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-aca1efb0a9ee065c0b3ad65d73e67dbe">2.1 - </h1>
    
	
</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-c5546365fa7a60719df25e8956893000">2.1.1 - FastDFS分布式存储</h1>
    <div class="lead">分布式存储中间件</div>
	<h4 id="为什么需要文件服务器">为什么需要文件服务器?<a class="td-heading-self-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e6%96%87%e4%bb%b6%e6%9c%8d%e5%8a%a1%e5%99%a8" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>浏览器请求可能会携带头像文件, 服务器处理后存储在本地磁盘</p>
<p>但是假如还有一个服务需要操作订单</p>
<p>那么就需要异步从存储头像拿头像</p>
<p>也就是说用户信息业务崩溃后, 导致订单服务器也一并崩溃</p>
<p>为了解耦合, 我们把文件存储到专门的服务器里, 保证系统稳定</p>
<p>当用户在订单管理修改信息后, 还需要同步到用户信息服务器</p>
<p>这需要传递两次, 还要保证一致性, 倒不如直接把服务器分离, 只传递文件地址
这样就可以减少服务间的传递, 而且也不需要传递大尺寸的文件, 只要传链接就可以</p>
<h4 id="使用">使用<a class="td-heading-self-link" href="#%e4%bd%bf%e7%94%a8" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>检查nacos配置
第三方服务</p>
<p>下载地址是由nginx管理的, 所以还需要nginx配置</p>
<p>注入fastdfs客户端
配置文件服务器url 也就是 nginx的IP地址</p>
<p>上传文件
传入 MultipatFile file
首先提取后缀名, 左闭右开去掉点放到新的子串
直接调客户端上传即可
用户回显, 是否上传成功, 看有没有文件信息就可以</p>
<p>下载
也就是响应文件, 创建响应实体内部放字节流
调客户端下载, 传入group组和文件id
下载完成的文件命名, 用时间就可以
定义好的名字回传道响应的响应头</p>
<p>删除文件
还是组和文件id
调客户端删除
回调是int值, 匹配定义的预设输出传回即可</p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-5480c4968cf2bd7572c3d657358f7947">2.2 - </h1>
    
	
</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-62bb39299d50fdae18e411e45b33da59">2.2.1 - RocketMQ</h1>
    <div class="lead">MQ的一种, 高并发常用</div>
	<blockquote>
<p>了解: <a href="WebSocket.md">WebSocket</a></p></blockquote>
<p>学习过 <code>websocekt</code> 后, 我们知道通过建立长连接可以实现 服务器和浏览器的双向推送
通过浏览器协调, 可以实现端对端的通信
<code>webServer</code> 初始化一个 Session 池作为核心容器, 当 <code>webServer</code> 在分布式中作为服务注入时, 其他服务也要调用消息怎么办?</p>
<p>可以让其他服务作为消费者, 让服务生产消息, 但是<code>webserver</code> 一旦负责消息通讯和消息生产职责就不再单一, 需要解耦</p>
<p>长连接传递的消息是即时的, 一旦连接断开消息就会丢失, 我们需要一个方法持久化消息</p>
<p>长连接会阻塞服务线程, 建立连接后双方不得不占用一个线程持续的监听, 需要把监听的任务解耦出去. 一旦并发消息过多, 服务器可能会崩溃</p>
<p>综上, 我们有了消息队列</p>
<ul>
<li>
<ol>
<li><strong>异步通信</strong></li>
</ol>
</li>
</ul>
<p><strong>场景描述</strong>：当系统中的应用程序需要异步通信时，可以使用消息中间件来实现。<br>
<strong>示例</strong>：在一个电商系统中，订单系统下单后需要给库存系统发送异步消息，以减少系统之间的耦合，避免同步调用导致的性能问题或响应延迟。</p>
<p><strong>优势</strong>：</p>
<ul>
<li><strong>减少耦合</strong>：系统可以在不等待响应的情况下继续进行其他操作。</li>
<li><strong>提高系统性能</strong>：减少了同步阻塞，提高了响应速度。</li>
</ul>
<hr>
<ol start="2">
<li><strong>应用解耦</strong></li>
</ol>
<p><strong>场景描述</strong>：当应用程序需要进行松耦合的通信时，可以使用消息中间件来实现。<br>
<strong>示例</strong>：在微服务架构中，不同服务之间可以通过消息中间件进行通信，避免直接调用服务导致的依赖关系过强。</p>
<p><strong>优势</strong>：</p>
<ul>
<li><strong>降低耦合度</strong>：服务之间通过消息中间件进行通信，不需要直接调用，提高系统的灵活性。</li>
<li><strong>增强可维护性</strong>：服务之间的更新和维护不影响其他服务。</li>
</ul>
<hr>
<ol start="3">
<li><strong>消息排队</strong></li>
</ol>
<p><strong>场景描述</strong>：当系统中需要处理大量的消息时，可以使用消息中间件来实现消息排队，确保消息的顺序和可靠性。<br>
<strong>示例</strong>：在金融行业中，需要处理大量的交易消息，消息中间件可以实现消息排队，确保每笔交易都得到正确处理。</p>
<p><strong>优势</strong>：</p>
<ul>
<li><strong>保证消息顺序</strong>：确保按顺序处理每条消息。</li>
<li><strong>消息可靠性</strong>：即使出现系统故障，未处理的消息仍然可以从队列中恢复。</li>
</ul>
<hr>
<ol start="4">
<li><strong>负载均衡</strong></li>
</ol>
<p><strong>场景描述</strong>：当系统需要处理大量的请求时，可以使用消息中间件来实现负载均衡。<br>
<strong>示例</strong>：在电商系统中，订单系统下单请求可以通过消息中间件发送到多个库存系统中，从而实现负载均衡。</p>
<p><strong>优势</strong>：</p>
<ul>
<li><strong>分担负载</strong>：通过将消息分发到多个消费者，实现负载均衡，避免单点压力。</li>
<li><strong>提高系统吞吐量</strong>：通过多节点并发处理提高系统处理能力。</li>
</ul>
<hr>
<ol start="5">
<li><strong>系统削峰填谷</strong></li>
</ol>
<p><strong>场景描述</strong>：当系统中出现高峰期时，可以使用消息中间件来平滑处理请求。<br>
<strong>示例</strong>：在电商系统中，双十一等促销活动可能会导致系统请求量急剧增加，消息中间件可以通过缓存请求，避免系统崩溃。</p>
<p><strong>优势</strong>：</p>
<ul>
<li><strong>平滑流量</strong>：在高峰期通过消息队列缓存请求，避免系统过载。</li>
<li><strong>提高系统稳定性</strong>：避免高并发请求导致的性能瓶颈或服务崩溃。</li>
</ul>
<h4 id="使用-rocketmq">使用 <code>RocketMQ</code><a class="td-heading-self-link" href="#%e4%bd%bf%e7%94%a8-rocketmq" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>并发环境下的消息队列用阿里提供的 <code>RocketMQ</code> 合适</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#ca9ee6">server</span>:  
</span></span><span style="display:flex;"><span>  <span style="color:#ca9ee6">port</span>: ${sp.publish}  
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">spring</span>:  
</span></span><span style="display:flex;"><span>  <span style="color:#ca9ee6">application</span>:  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">name</span>: ${sn.publish}  
</span></span><span style="display:flex;"><span>  <span style="color:#ca9ee6">cloud</span>:  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">stream</span>:  
</span></span><span style="display:flex;"><span>      <span style="color:#ca9ee6">rocketmq</span>:  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">binder</span>:  
</span></span><span style="display:flex;"><span>          <span style="color:#ca9ee6">name-server</span>: ${rocket-mq.name-server}  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">bindings</span>:  
</span></span><span style="display:flex;"><span>          <span style="color:#ca9ee6">output</span>:  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">producer</span>:  
</span></span><span style="display:flex;"><span>              <span style="color:#ca9ee6">group</span>: socketGroup  
</span></span><span style="display:flex;"><span>              <span style="color:#ca9ee6">sync</span>: <span style="color:#ef9f76">true</span>  
</span></span><span style="display:flex;"><span>      <span style="color:#ca9ee6">bindings</span>:  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">output</span>:  
</span></span><span style="display:flex;"><span>          <span style="color:#ca9ee6">destination</span>: test-topic  
</span></span><span style="display:flex;"><span>          <span style="color:#ca9ee6">content-type</span>: application/json  
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#开启MQ的日志  </span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">logging</span>:  
</span></span><span style="display:flex;"><span>  <span style="color:#ca9ee6">level</span>:  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">com</span>:  
</span></span><span style="display:flex;"><span>      <span style="color:#ca9ee6">alibaba</span>:  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">cloud</span>:  
</span></span><span style="display:flex;"><span>          <span style="color:#ca9ee6">stream</span>:  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">binder</span>:  
</span></span><span style="display:flex;"><span>              <span style="color:#ca9ee6">rocketmq</span>: DEBUG
</span></span></code></pre></div><p>项目依赖</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#ca9ee6">&lt;dependency&gt;</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">&lt;groupId&gt;</span>com.alibaba.cloud<span style="color:#ca9ee6">&lt;/groupId&gt;</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">&lt;artifactId&gt;</span>spring-cloud-starter-stream-rocketmq<span style="color:#ca9ee6">&lt;/artifactId&gt;</span>  
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>写 <code>Swagger</code> 配置, 不同于 <code>webSocket</code> mq作为异步消息组件可以用C-S模型, 也就是请求-响应模型, 我们从 swagger测试请求响应</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * &lt;p&gt; * 描述：Swagger配置  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * &lt;/p&gt;  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @author hamhuo  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @version 1.0.0  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span><span style="color:#8caaee;font-weight:bold">@Configuration</span>  
</span></span><span style="display:flex;"><span><span style="color:#8caaee;font-weight:bold">@EnableSwagger2WebMvc</span>  
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">SwaggerConfig</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#8caaee;font-weight:bold">@Bean</span>  
</span></span><span style="display:flex;"><span>    Docket <span style="color:#8caaee">rpApi</span>() {  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> SwaggerCore.<span style="color:#8caaee">defaultDocketBuilder</span>(<span style="color:#a6d189">&#34;消息推送&#34;</span>, <span style="color:#a6d189">&#34;com.zeroone.star.mq.controller&#34;</span>, <span style="color:#a6d189">&#34;publish&#34;</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>消息发布组件 <code>RmqPublish</code> , 该组件封装了发布方法</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * &lt;p&gt; * 描述：消息发布组件  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * &lt;/p&gt;  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @author hamhuo  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @version 1.0.0  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span><span style="color:#8caaee;font-weight:bold">@Component</span>  
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">RmqPublish</span> {  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#8caaee;font-weight:bold">@Resource</span>  
</span></span><span style="display:flex;"><span>    Source source;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">publish</span>(SampleNotifyDTO dto) {  
</span></span><span style="display:flex;"><span>        source.<span style="color:#8caaee">output</span>().<span style="color:#8caaee">send</span>(MessageBuilder.<span style="color:#8caaee">withPayload</span>(dto).<span style="color:#8caaee">build</span>());  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里通知DTO封装的是 <code>websocket</code> 的客户端id 和消息</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * &lt;p&gt; * 描述：示例通知数据对象  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * &lt;/p&gt;  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @author hamhuo  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @version 1.0.0  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span><span style="color:#8caaee;font-weight:bold">@Data</span>  
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">SampleNotifyDTO</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">/**  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     * 客户端编号  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     */</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> String clientId;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">/**  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     * 通知消息内容  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     */</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">private</span> String message;  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>继续之前, 我们要解释一下发布组件</p>
<ul>
<li><code>@Component</code> 是声明式注解, 要求 <code>Spring</code> 作为组件注入</li>
<li>通过 <code>@Resourse</code> 注入了一个依赖, 该注解会查找指定名称的资源/Bean, 如果不指定就通过反射拿指定类型的资源, 这里查找到了一个 <code>Source</code></li>
<li><code>Source</code> 接口返回一个 <code>MessageChannel</code> 这个可以理解为发送消息到消息队列</li>
<li>构建信息后链式调用 output 返回一个 MC, 调用MC发送信息</li>
</ul>
<p>Source 信息源接口如下</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250224211221207.png" alt="image.png"></p>
<p>其中 <code>@OutPut</code> 注解 要求 <code>Spring</code> 容器将名字为 <code>OUTPUT</code> 值的消息频道与中间件绑定</p>
<p>因此这里我们需要做一些配置</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#ca9ee6">rocketmq</span>:  
</span></span><span style="display:flex;"><span>  <span style="color:#ca9ee6">binder</span>:  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">name-server</span>: ${rocket-mq.name-server}  
</span></span><span style="display:flex;"><span>  <span style="color:#ca9ee6">bindings</span>:  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">output</span>:  
</span></span><span style="display:flex;"><span>      <span style="color:#ca9ee6">producer</span>:  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">group</span>: socketGroup  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">sync</span>: <span style="color:#ef9f76">true</span>  
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">bindings</span>:  
</span></span><span style="display:flex;"><span>  <span style="color:#ca9ee6">output</span>:  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">destination</span>: test-topic  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">content-type</span>: application/json
</span></span></code></pre></div><p>我们先看<code>mq</code>的配置</p>
<p><code>spring.cloud.rocketmq</code> 下配置名称服务器地址, 这里已经通过 <code>nacos</code> 配置好了</p>
<blockquote>
<p><strong>RocketMQ</strong> 的 <strong>NameServer</strong> 是 RocketMQ 集群中的一个核心组件，它提供了一个简单的服务注册与发现机制。具体来说，<strong>NameServer</strong> 主要用于管理 RocketMQ Broker 的信息，客户端通过访问 NameServer 来查询和获取消息队列的路由信息，从而实现消息的发送和接收。</p></blockquote>
<p>这是为了让 Spring Cloud Stream 知道如何将消息发送到 RocketMQ</p>
<p>之后再配置  <code>bindings.output</code> 下配置生产者</p>
<ul>
<li><code>producer.group</code>: 配置生产者的 <strong>消费组</strong>，用于指定该生产者的分组。</li>
<li><code>sync</code>: 如果设置为 <code>true</code>，则表示生产者将同步发送消息。即，发送消息后会等待消息发送确认，确保消息发送成功。</li>
</ul>
<blockquote>
<p>生产者就是在 RocketMQ 中生产信息的角色</p></blockquote>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250224212653226.png" alt="image.png"></p>
<p>然后是第二个 <code>bindings</code>, 这是 Spring Cloud 的配置</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#ca9ee6">bindings</span>:  
</span></span><span style="display:flex;"><span>  <span style="color:#ca9ee6">output</span>:  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">destination</span>: test-topic  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">content-type</span>: application/json
</span></span></code></pre></div><p>这里的 <code>output</code> 配置与 <code>Source.OUTPUT</code> 直接相关。通过这个配置，Spring Cloud Stream 会将 <code>Source.OUTPUT</code> 这个输出通道的 <strong>消息目标</strong>（即 <code>destination</code>）设置为 <code>test-topic</code>，并且设置消息的 <strong>内容类型</strong> 为 <code>application/json</code>。这意味着，消息将通过名为 <code>output</code> 的通道发送到 <code>test-topic</code> 主题，并且消息格式是 JSON。</p>
<p>总结下, 为了保证代码松耦合, Spring 将消息发送和驱动(也就是连接不同品牌的MQ)分离开, 将驱动交由第三方提供. spring只需要调用Source发送消息即可</p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6847462fbc45c0ec0e2539734fdfc520">2.3 - AOP面向切面编程</h1>
    <div class="lead">The key unit of modularity in OOP is the class, whereas in AOP the unit of modularity is the aspect. Aspects enable the modularization of concerns (such as transaction management) that cut across multiple types and objects.</div>
	<p>Aspect-oriented Programming (AOP) complements Object-oriented Programming (OOP) by providing another way of thinking about program structure.</p>
<p>AOP是OOP的延续, 两者互补</p>
<p>为什么要用AOP
为了不涉及过多术语, 在介绍AOP之前, 我们介绍下为什么要提出AOP这个概念</p>
<p>OOP作为Java的核心设计原则, 是存在一些缺点的.
比如日志, 我们知道可以用slf4j 提供的工厂发法返回logger,
但是这个logger的作用范围是初始化的类, 为了实现全局日志需要在所有业务类注入这个logger, 也就是@Slf4j注解
这会导致代码冗余</p>
<p>类似的还有 <a href="/java/advanced/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/">事务管理</a></p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-5ba10e92aedbfc888e0e1fc25ad92362">2.4 - FastExcel报表组件</h1>
    <div class="lead">报表组件</div>
	<p>提前封装好一些服务</p>
<h4 id="快速导入">快速导入<a class="td-heading-self-link" href="#%e5%bf%ab%e9%80%9f%e5%af%bc%e5%85%a5" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>组件扫描</p>
<p>写一个单元测试
导入excel客户端
生成excle
新建一个数组
调用导入功能</p>
<p>解析
传入文件</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2b22ec5ab6cb18f57e4a05415d0a34e2">2.5 - Gateway网关</h1>
    <div class="lead">网关是一个位于微服务架构前端的组件，它充当了所有微服务的入口</div>
	<h4 id="什么是网关">什么是网关<a class="td-heading-self-link" href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%bd%91%e5%85%b3" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>网关负责路由请求、负载均衡、安全认证、流量控制、监控和日志记录等任务。</p>
<p>我的理解是, 网关是请求真正进入服务前的过滤, 管理, 控制(重定向), 可以理解为保安大哥</p>
<p>网关的结构</p>
<ul>
<li>
<p>路由
网关的基本模块, 由断言和过滤器组成</p>
<ul>
<li>
<p>断言
匹配规则, 当请求路径匹配时允许路由到相关服务
实现一组匹配规则，让请求找到对应的 Route 进行处理</p>
</li>
<li>
<p>过滤器
响应式的过滤器链, 实现请求的过滤</p>
<ul>
<li>全局过滤器
全局过滤器作用于所有的路由，不需要单独配置</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250212093859168.png" alt="image.png"></p>
<p>客户端发起请求, 由 <code>Gateway Handler Mapping</code>
接收, 这里执行断言并路由到 <code>Gateway Web Handler</code> 这里做过滤链, 过滤请求, 最后传递给服务
过滤器可以在执行前和执行后回调</p>
<blockquote>
<p>在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等;</p>
<p>在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。</p></blockquote>
<blockquote>
<p>了解:
<a href="/java/advanced/reactor%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%BA%93/">响应式编程</a></p></blockquote>
<h4 id="过滤器">过滤器<a class="td-heading-self-link" href="#%e8%bf%87%e6%bb%a4%e5%99%a8" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>过滤器是由 <code>Servlet</code> 容器管理的, 也就是说初始化</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250217183936830.png" alt="image.png"></p>
<h4 id="实践-spring-cloud-gateway-全局过滤器">实践: Spring Cloud Gateway 全局过滤器<a class="td-heading-self-link" href="#%e5%ae%9e%e8%b7%b5-spring-cloud-gateway-%e5%85%a8%e5%b1%80%e8%bf%87%e6%bb%a4%e5%99%a8" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p>网关选型<code>SpringCloudGateway</code> 这是目前比较新的选择</p>
<p>模板工程基于 <code>pmhub</code></p></blockquote>
<p>新建自定义的全局过滤器</p>
<p>全局过滤器需要实现 <code>GlobalFilter</code>
过滤器需要确定执行顺序, 实现<code>Order</code> 接口</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#8caaee;font-weight:bold">@Component</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">AuthFilter</span> <span style="color:#e78284">implements</span> GlobalFilter, Ordered
</span></span></code></pre></div><p>该过滤器实现如下功能</p>
<ol>
<li>请求耗时记录</li>
<li>白名单过滤</li>
<li>Token鉴权</li>
<li>日志输出</li>
</ol>
<p>请求耗时记录:</p>
<p>全局过滤器的优先级较高, 因此把请求进入过滤器的时间作为起点, 业务执行完毕执行<code>post</code> 业务逻辑. 进行简单的时间相减</p>
<p>白名单过滤:</p>
<p><a href="/java/advanced/nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"><code>nacos</code></a> 配置白名单, 有些路径不需要严格的鉴权, 比如首页. 所有人发请求都能通过, 就直接跳过完事</p>
<p><code>Token</code>鉴权:</p>
<p>作为全局过滤器, 当用户请求进入应当进行身份鉴权, 过滤无效的请求
从请求头里拿 <code>Token</code> , 跟缓存做匹配即可</p>
<blockquote>
<p><code>Redis</code> 策略是到期销毁, 不做更新</p></blockquote>
<p>日志输出:
在过滤链回调后执行, 代表服务执行完成
结束时间减去开始时间就行</p>
<p>为了方便解释, 我们一项项实现</p>
<p>请求耗时:</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span> <span style="color:#8caaee;font-weight:bold">@Component</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">AuthFilter</span> <span style="color:#e78284">implements</span> GlobalFilter, Ordered{
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//常量, 记录开始访问的时间</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> String BEGIN_VISIT_TIME <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#34;begin_visit_time&#34;</span>;<span style="color:#737994;font-style:italic">//开始访问时间</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//补上日志实例</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> Logger log <span style="color:#99d1db;font-weight:bold">=</span> LoggerFactory.<span style="color:#8caaee">getLogger</span>(AuthFilter.<span style="color:#8caaee">class</span>);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//过滤器接口方法, 这个必须实现</span>
</span></span><span style="display:flex;"><span>	<span style="color:#8caaee;font-weight:bold">@Override</span>  
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> Mono<span style="color:#99d1db;font-weight:bold">&lt;</span>Void<span style="color:#99d1db;font-weight:bold">&gt;</span> <span style="color:#8caaee">filter</span>(ServerWebExchange exchange, GatewayFilterChain chain) {
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//token和白名单稍后实现</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//在上下文加上开始时间</span>
</span></span><span style="display:flex;"><span>	exchange.<span style="color:#8caaee">getAttributes</span>().<span style="color:#8caaee">put</span>(BEGIN_VISIT_TIME, System.<span style="color:#8caaee">currentTimeMillis</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//等待链执行完成回调</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ca9ee6">return</span> chain.<span style="color:#8caaee">filter</span>(exchange)
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//链式调用then, 使用Mono.fromRunnable方法顺序执行日志输出</span>
</span></span><span style="display:flex;"><span>	.<span style="color:#8caaee">then</span>(Mono.<span style="color:#8caaee">fromRunnable</span>{})
</span></span><span style="display:flex;"><span>		<span style="color:#737994;font-style:italic">//日志输出的逻辑</span>
</span></span><span style="display:flex;"><span>		<span style="color:#737994;font-style:italic">// 记录接口访问日志  </span>
</span></span><span style="display:flex;"><span>		Long beginVisitTime <span style="color:#99d1db;font-weight:bold">=</span> exchange.<span style="color:#8caaee">getAttribute</span>(BEGIN_VISIT_TIME);
</span></span><span style="display:flex;"><span>		<span style="color:#ca9ee6">if</span> (beginVisitTime <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>){
</span></span><span style="display:flex;"><span>			logData.<span style="color:#8caaee">put</span>(<span style="color:#a6d189">&#34;duration&#34;</span>, (System.<span style="color:#8caaee">currentTimeMillis</span>() <span style="color:#99d1db;font-weight:bold">-</span> beginVisitTime) <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;ms&#34;</span>);
</span></span><span style="display:flex;"><span>			log.<span style="color:#8caaee">info</span>(<span style="color:#a6d189">&#34;访问接口信息: {}&#34;</span>, logData);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>白名单过滤</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span> <span style="color:#8caaee;font-weight:bold">@Component</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">AuthFilter</span> <span style="color:#e78284">implements</span> GlobalFilter, Ordered{
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//常量, 记录开始访问的时间</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> String BEGIN_VISIT_TIME <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#34;begin_visit_time&#34;</span>;<span style="color:#737994;font-style:italic">//开始访问时间</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//补上日志</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> Logger log <span style="color:#99d1db;font-weight:bold">=</span> LoggerFactory.<span style="color:#8caaee">getLogger</span>(AuthFilter.<span style="color:#8caaee">class</span>);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//过滤器接口方法</span>
</span></span><span style="display:flex;"><span>	<span style="color:#8caaee;font-weight:bold">@Override</span>  
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> Mono<span style="color:#99d1db;font-weight:bold">&lt;</span>Void<span style="color:#99d1db;font-weight:bold">&gt;</span> <span style="color:#8caaee">filter</span>(ServerWebExchange exchange, GatewayFilterChain chain) {
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//白名单</span>
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//首先拿到请求路径</span>
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//上下文拿请求</span>
</span></span><span style="display:flex;"><span>	ServerHttpRequest request <span style="color:#99d1db;font-weight:bold">=</span> exchange.<span style="color:#8caaee">getRequest</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//请求拿请求路径, 先拿URI, 再去掉首部</span>
</span></span><span style="display:flex;"><span>	String url <span style="color:#99d1db;font-weight:bold">=</span> request.<span style="color:#8caaee">getURI</span>().<span style="color:#8caaee">getPath</span>();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">// 跳过不需要验证的路径, 直接进下一级</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ca9ee6">if</span> (StringUtils.<span style="color:#8caaee">matches</span>(url, ignoreWhite.<span style="color:#8caaee">getWhites</span>())) {  
</span></span><span style="display:flex;"><span>	    <span style="color:#ca9ee6">return</span> chain.<span style="color:#8caaee">filter</span>(exchange);  
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//在上下文加上开始时间</span>
</span></span><span style="display:flex;"><span>	exchange.<span style="color:#8caaee">getAttributes</span>().<span style="color:#8caaee">put</span>(BEGIN_VISIT_TIME, System.<span style="color:#8caaee">currentTimeMillis</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//等待链执行完成回调</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ca9ee6">return</span> chain.<span style="color:#8caaee">filter</span>(exchange)
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//链式调用then, 使用Mono.fromRunnable方法顺序执行日志输出</span>
</span></span><span style="display:flex;"><span>	.<span style="color:#8caaee">then</span>(Mono.<span style="color:#8caaee">fromRunnable</span>{})
</span></span><span style="display:flex;"><span>		<span style="color:#737994;font-style:italic">//日志输出的逻辑</span>
</span></span><span style="display:flex;"><span>		<span style="color:#737994;font-style:italic">// 记录接口访问日志  </span>
</span></span><span style="display:flex;"><span>		Long beginVisitTime <span style="color:#99d1db;font-weight:bold">=</span> exchange.<span style="color:#8caaee">getAttribute</span>(BEGIN_VISIT_TIME);
</span></span><span style="display:flex;"><span>		<span style="color:#ca9ee6">if</span> (beginVisitTime <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>){
</span></span><span style="display:flex;"><span>			logData.<span style="color:#8caaee">put</span>(<span style="color:#a6d189">&#34;duration&#34;</span>, (System.<span style="color:#8caaee">currentTimeMillis</span>() <span style="color:#99d1db;font-weight:bold">-</span> beginVisitTime) <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;ms&#34;</span>);
</span></span><span style="display:flex;"><span>			log.<span style="color:#8caaee">info</span>(<span style="color:#a6d189">&#34;访问接口信息: {}&#34;</span>, logData);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>token鉴权:
选型 <a href="/java/advanced/jwt%E4%B8%8Esession/"><code>Jwt</code></a></p>
<p>下图是流程, 我们将鉴权的业务从服务层分离移至网关进行, 优化性能</p>
<p><strong>鉴权（认证）是在网关层进行的</strong>，而 <strong>请求并没有进入到 MVC 控制器中</strong>, 也就没有触发拦截器</p>
<blockquote>
<p>了解:
<a href="/java/advanced/springmvc/">SpringMVC</a></p></blockquote>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250218002926038.png" alt="image.png"></p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span> <span style="color:#8caaee;font-weight:bold">@Component</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">AuthFilter</span> <span style="color:#e78284">implements</span> GlobalFilter, Ordered{
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//常量, 记录开始访问的时间</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> String BEGIN_VISIT_TIME <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#34;begin_visit_time&#34;</span>;<span style="color:#737994;font-style:italic">//开始访问时间</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//补上日志</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> Logger log <span style="color:#99d1db;font-weight:bold">=</span> LoggerFactory.<span style="color:#8caaee">getLogger</span>(AuthFilter.<span style="color:#8caaee">class</span>);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//补上redis</span>
</span></span><span style="display:flex;"><span>	<span style="color:#8caaee;font-weight:bold">@Autowired</span>  
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">private</span> RedisService redisService;
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//过滤器接口方法</span>
</span></span><span style="display:flex;"><span>	<span style="color:#8caaee;font-weight:bold">@Override</span>  
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">public</span> Mono<span style="color:#99d1db;font-weight:bold">&lt;</span>Void<span style="color:#99d1db;font-weight:bold">&gt;</span> <span style="color:#8caaee">filter</span>(ServerWebExchange exchange, GatewayFilterChain chain) {
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//白名单</span>
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//首先拿到请求路径</span>
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//上下文拿请求</span>
</span></span><span style="display:flex;"><span>	ServerHttpRequest request <span style="color:#99d1db;font-weight:bold">=</span> exchange.<span style="color:#8caaee">getRequest</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//请求拿请求路径, 先拿URI, 再去掉首部</span>
</span></span><span style="display:flex;"><span>	String url <span style="color:#99d1db;font-weight:bold">=</span> request.<span style="color:#8caaee">getURI</span>().<span style="color:#8caaee">getPath</span>();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">// 跳过不需要验证的路径, 直接进下一级, 返回链的执行结果</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ca9ee6">if</span> (StringUtils.<span style="color:#8caaee">matches</span>(url, ignoreWhite.<span style="color:#8caaee">getWhites</span>())) {  
</span></span><span style="display:flex;"><span>	    <span style="color:#ca9ee6">return</span> chain.<span style="color:#8caaee">filter</span>(exchange);  
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//剩下的请求过筛子</span>
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//从请求拿token</span>
</span></span><span style="display:flex;"><span>	String token <span style="color:#99d1db;font-weight:bold">=</span> getToken(request);
</span></span><span style="display:flex;"><span>	<span style="color:#ca9ee6">if</span> (StringUtils.<span style="color:#8caaee">isEmpty</span>(token)) {  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> unauthorizedResponse(exchange, <span style="color:#a6d189">&#34;令牌不能为空&#34;</span>);  
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//拿JWT的声明, 这里写了一个字符串工具拿声明, 令牌秘钥就在工具里</span>
</span></span><span style="display:flex;"><span>	Claims claims <span style="color:#99d1db;font-weight:bold">=</span> JwtUtils.<span style="color:#8caaee">parseToken</span>(token);
</span></span><span style="display:flex;"><span>	<span style="color:#ca9ee6">if</span> (claims <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span>) {  
</span></span><span style="display:flex;"><span>	    <span style="color:#ca9ee6">return</span> unauthorizedResponse(exchange, <span style="color:#a6d189">&#34;令牌已过期或验证不正确！&#34;</span>);  
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//从声明拿用户ID</span>
</span></span><span style="display:flex;"><span>	String userkey <span style="color:#99d1db;font-weight:bold">=</span> JwtUtils.<span style="color:#8caaee">getUserKey</span>(claims);  
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//从缓存匹配用户ID的token, 这里getTokenKey格式化, 就加了个前缀</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e78284">boolean</span> islogin <span style="color:#99d1db;font-weight:bold">=</span> redisService.<span style="color:#8caaee">hasKey</span>(getTokenKey(userkey));
</span></span><span style="display:flex;"><span>	<span style="color:#ca9ee6">if</span> (<span style="color:#99d1db;font-weight:bold">!</span>islogin) {  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> unauthorizedResponse(exchange, <span style="color:#a6d189">&#34;登录状态已过期&#34;</span>);  
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//最后从声明拿用户详细信息</span>
</span></span><span style="display:flex;"><span>	String userid <span style="color:#99d1db;font-weight:bold">=</span> JwtUtils.<span style="color:#8caaee">getUserId</span>(claims);  
</span></span><span style="display:flex;"><span>	String username <span style="color:#99d1db;font-weight:bold">=</span> JwtUtils.<span style="color:#8caaee">getUserName</span>(claims);  
</span></span><span style="display:flex;"><span>	<span style="color:#ca9ee6">if</span> (StringUtils.<span style="color:#8caaee">isEmpty</span>(userid) <span style="color:#99d1db;font-weight:bold">||</span> StringUtils.<span style="color:#8caaee">isEmpty</span>(username)) {  
</span></span><span style="display:flex;"><span>	    <span style="color:#ca9ee6">return</span> unauthorizedResponse(exchange, <span style="color:#a6d189">&#34;令牌验证失败&#34;</span>);  
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//重新设置请求, 鉴权完毕</span>
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//设置用户信息到请求  </span>
</span></span><span style="display:flex;"><span>	addHeader(mutate, SecurityConstants.<span style="color:#8caaee">USER_KEY</span>, userkey);  
</span></span><span style="display:flex;"><span>	addHeader(mutate, SecurityConstants.<span style="color:#8caaee">DETAILS_USER_ID</span>, userid);  
</span></span><span style="display:flex;"><span>	addHeader(mutate, SecurityConstants.<span style="color:#8caaee">DETAILS_USERNAME</span>, username);  
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">// 内部请求来源参数清除（防止网关携带内部请求标识，造成系统安全风险）  </span>
</span></span><span style="display:flex;"><span>	removeHeader(mutate, SecurityConstants.<span style="color:#8caaee">FROM_SOURCE</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//在上下文加上开始时间</span>
</span></span><span style="display:flex;"><span>	exchange.<span style="color:#8caaee">getAttributes</span>().<span style="color:#8caaee">put</span>(BEGIN_VISIT_TIME, System.<span style="color:#8caaee">currentTimeMillis</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//等待链执行完成回调</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ca9ee6">return</span> chain.<span style="color:#8caaee">filter</span>(exchange)
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//链式调用then, 使用Mono.fromRunnable方法顺序执行日志输出</span>
</span></span><span style="display:flex;"><span>	.<span style="color:#8caaee">then</span>(Mono.<span style="color:#8caaee">fromRunnable</span>{})
</span></span><span style="display:flex;"><span>		<span style="color:#737994;font-style:italic">//日志输出的逻辑</span>
</span></span><span style="display:flex;"><span>		<span style="color:#737994;font-style:italic">// 记录接口访问日志  </span>
</span></span><span style="display:flex;"><span>		Long beginVisitTime <span style="color:#99d1db;font-weight:bold">=</span> exchange.<span style="color:#8caaee">getAttribute</span>(BEGIN_VISIT_TIME);  
</span></span><span style="display:flex;"><span>		<span style="color:#ca9ee6">if</span> (beginVisitTime <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {  
</span></span><span style="display:flex;"><span>		    URI uri <span style="color:#99d1db;font-weight:bold">=</span> exchange.<span style="color:#8caaee">getRequest</span>().<span style="color:#8caaee">getURI</span>();  
</span></span><span style="display:flex;"><span>		    Map<span style="color:#99d1db;font-weight:bold">&lt;</span>String, Object<span style="color:#99d1db;font-weight:bold">&gt;</span> logData <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> HashMap<span style="color:#99d1db;font-weight:bold">&lt;&gt;</span>();  
</span></span><span style="display:flex;"><span>		    logData.<span style="color:#8caaee">put</span>(<span style="color:#a6d189">&#34;host&#34;</span>, uri.<span style="color:#8caaee">getHost</span>());  
</span></span><span style="display:flex;"><span>		    logData.<span style="color:#8caaee">put</span>(<span style="color:#a6d189">&#34;port&#34;</span>, uri.<span style="color:#8caaee">getPort</span>());  
</span></span><span style="display:flex;"><span>		    logData.<span style="color:#8caaee">put</span>(<span style="color:#a6d189">&#34;path&#34;</span>, uri.<span style="color:#8caaee">getPath</span>());  
</span></span><span style="display:flex;"><span>		    logData.<span style="color:#8caaee">put</span>(<span style="color:#a6d189">&#34;query&#34;</span>, uri.<span style="color:#8caaee">getRawQuery</span>());  
</span></span><span style="display:flex;"><span>		    logData.<span style="color:#8caaee">put</span>(<span style="color:#a6d189">&#34;duration&#34;</span>, (System.<span style="color:#8caaee">currentTimeMillis</span>() <span style="color:#99d1db;font-weight:bold">-</span> beginVisitTime) <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;ms&#34;</span>);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>		    log.<span style="color:#8caaee">info</span>(<span style="color:#a6d189">&#34;访问接口信息: {}&#34;</span>, logData);  
</span></span><span style="display:flex;"><span>		    log.<span style="color:#8caaee">info</span>(<span style="color:#a6d189">&#34;我是美丽分割线: ###################################################&#34;</span>);  
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>addHeader</code> 和 <code>removeHeader</code> 其实没什么说的, 就是重新构造了个请求, 方便后续服务直接拿信息</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">private</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">addHeader</span>(ServerHttpRequest.<span style="color:#8caaee">Builder</span> mutate, String name, Object value) {  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (value <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span>;  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>    String valueStr <span style="color:#99d1db;font-weight:bold">=</span> value.<span style="color:#8caaee">toString</span>();  
</span></span><span style="display:flex;"><span>    String valueEncode <span style="color:#99d1db;font-weight:bold">=</span> ServletUtils.<span style="color:#8caaee">urlEncode</span>(valueStr);  
</span></span><span style="display:flex;"><span>    mutate.<span style="color:#8caaee">header</span>(name, valueEncode);  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#e78284">private</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">removeHeader</span>(ServerHttpRequest.<span style="color:#8caaee">Builder</span> mutate, String name) {  
</span></span><span style="display:flex;"><span>    mutate.<span style="color:#8caaee">headers</span>(httpHeaders <span style="color:#99d1db;font-weight:bold">-&gt;</span> httpHeaders.<span style="color:#8caaee">remove</span>(name)).<span style="color:#8caaee">build</span>();  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a10ef0a98cd31d88eed3637bec2fff46">2.6 - Intercepter拦截器</h1>
    <div class="lead">拦截器 Interceptor 在 Spring MVC 中的地位等同于 Servlet 规范中的过滤器 Filter，拦截的是处理器的执行，由于是全局行为，因此常用于做一些通用的功能，如请求日志打印、权限控制等。</div>
	
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ed66f29438332c88139caba654f9e301">2.7 - JWT与Session</h1>
    <div class="lead">一种令牌格式, 改进了 Session 需要状态管理的缺点, 通过用户提供token来实现令牌发放</div>
	<p>作为令牌格式, JWT 和 session 在用户认证上时常用到</p>
<h4 id="session">Session<a class="td-heading-self-link" href="#session" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>经典的 <code>Session</code> 登录流程如下</p>
<ul>
<li>
<p>用户向服务器发送用户名和密码。</p>
</li>
<li>
<p>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p>
</li>
<li>
<p>服务器向用户返回一个 session_id，写入用户的 Cookie。</p>
</li>
<li>
<p>用户随后的每一次请求，都会通过 Cookie，将 <code>session_id</code> 传回服务器。</p>
</li>
<li>
<p>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p>
</li>
</ul>
<p>单机环境下, session 实现简单, 方便快速, 服务器维护与用户的连接(下称 <code>Sesssion</code>), 用户传入 id 来更新session</p>
<p>但是分布式集群下, 各个服务需要不断的请求并写入session, 这使得session服务器成为了登录中心服务器, 一旦中心服务器挂了, 整个分布应用宕机</p>
<p>既然服务器维护session成本这么高, 干脆不维护了, 让用户维护</p>
<p>于是诞生了 JWT</p>
<h4 id="jwt">JWT<a class="td-heading-self-link" href="#jwt" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-JSON" data-lang="JSON"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#ca9ee6">&#34;姓名&#34;</span>: <span style="color:#a6d189">&#34;张三&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#ca9ee6">&#34;角色&#34;</span>: <span style="color:#a6d189">&#34;管理员&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#ca9ee6">&#34;到期时间&#34;</span>: <span style="color:#a6d189">&#34;2018年7月1日0点0分&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-14466de61718f3e7e4e0634fcd427c5f">2.8 - Nacos配置中心</h1>
    <div class="lead">动态决策中心, 当然可以理解为分布式的配置中心</div>
	
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bfce5c28aec1143b74ff0aa46a5285a4">2.9 - OAuth2认证</h1>
    <div class="lead">OAuth 2.0, which stands for “Open Authorization”, is a standard designed to allow a website or application to access resources hosted by other web apps on behalf of a user.</div>
	<p><a href="https://en.wikipedia.org/wiki/OAuth">OAuth</a>是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是2.0版。</p>
<h4 id="为什么需要-oauth">为什么需要 <code>OAuth</code><a class="td-heading-self-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81-oauth" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>以网易云音乐云村账号登录为例</p>
<p>传统的用户授权方式是</p>
<ul>
<li>用户输入用户名密码</li>
<li>服务器验证密码, 这里需要存储用户密码到本地</li>
<li>返回session/token</li>
</ul>
<p>这对于单一服务没什么问题, 因为用户敏感信息和服务都是由网易云存储并提供的</p>
<p>但是网易云也支持qq登录</p>
<p>按照常识, 用户不会把qq密码提供给网易, 没别的意思, 就是不合逻辑
那么上述流程就存在问题了</p>
<ul>
<li>网易云为了实现qq登录, 不得不保存qq用户信息并部署qq密码登录</li>
<li>网易获得了登录用户qq的权限</li>
<li>qq密码权限范围被意外扩大了, 现在不止腾讯, 网易也可以获取密码了, 被破解的几率增加</li>
</ul>
<p>所以我们需要在网易和腾讯之间设置一个转换层, 密码在腾讯处理, 通过转换层把令牌交给网易</p>
<h4 id="角色介绍">角色介绍<a class="td-heading-self-link" href="#%e8%a7%92%e8%89%b2%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>OAuth 就是这样的一种协议</p>
<p>此协议定义了四种角色</p>
<ul>
<li>客户端/客户, 一个应用程序发出 API 请求对受保护资源执行一些行为，而这些行为是经过资源拥有授权的</li>
<li>资源拥有者Resource owner)：通常是一个应用的用户，也是资源拥有者，它拥有授予访问在资源 服务器上的资源</li>
<li>授权服务器Authorization server)：当前授权服务器从资源拥有者达成共识时，它会发放访问令牌 给客户以允许访问在资源服务器上的受保护的资源 。比较小的 API 提供商可能会使用相同的应用和 URL空间作为授权服务器和资源服务器</li>
<li>资源服务器Resource server)：该服务器是用户拥有资源的服务器，它是受 一般我们叫做 OAuth 保护的服务器。 API 提供商，因为它拥有受保护的数据，比如图片、视频、日历或者合同等。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250302235946977.png" alt="image.png"></p>
<p>OAuth  的优点包括简化了用户授权流程，提高了安全性，允许用户选择性地授权资源访问，并支持多 种授权方式（如授权码模式、密码模式、客户端模式等）。它广泛应用于各种互联网应用程序中，例如第 三方登录、 API 访问授权等场景。</p>
<h4 id="实践--spring-cloud-gateway--密码模式的-oauth2-授权模型">实践:  Spring Cloud GateWay + 密码模式的 OAuth2 授权模型<a class="td-heading-self-link" href="#%e5%ae%9e%e8%b7%b5--spring-cloud-gateway--%e5%af%86%e7%a0%81%e6%a8%a1%e5%bc%8f%e7%9a%84-oauth2-%e6%8e%88%e6%9d%83%e6%a8%a1%e5%9e%8b" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><blockquote>
<p><a href="/java/advanced/gateway%E7%BD%91%E5%85%B3/">网关</a>, <a href="/java/advanced/jwt%E4%B8%8Esession/">JWT与Session</a></p></blockquote>
<blockquote>
<p>警告: 最新的 OAuth 废弃了密码模式鉴权, 此种方法会将密码暴露给客户端</p></blockquote>
<p>搭建认证服务模块 <code>OAuth2</code></p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"></code></pre></div><p>配置文件</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"></code></pre></div><p>OAuth2 要求使用 JWT 作为令牌格式, 这里需要 RSA 证书</p>
<pre tabindex="0"><code class="language-key" data-lang="key"></code></pre><p>提取公/私钥</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmd" data-lang="cmd"></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-7784bca3c26210aa2f38f471a8a3c1c4">2.10 - SpringMVC</h1>
    <div class="lead">MVC 也就是 Model-View-Controller, 这种模式用于应用程序的分层开发</div>
	
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c5be60b3ee2566487eb164b032000197">2.11 - TTL</h1>
    <div class="lead">基于 TransmittableThreadLocal (TTL) 自定义请求头拦截器，将Header 数据封装到线程变量中方便获取，减少用户信息数据库查询次数，同时验证当前用户有效期自动刷新有效期。</div>
	<p><code>TransmittableThreadLocal</code> (TTL) 是增强版的 <code>ThreadLocal</code></p>
<blockquote>
<p>前置:
<a href="ThreadLocal.md"><code>ThreadLocal</code></a>, <a href="/java/advanced/intercepter%E6%8B%A6%E6%88%AA%E5%99%A8/">拦截器</a></p></blockquote>
<h4 id="实现ttl">实现<code>TTL</code><a class="td-heading-self-link" href="#%e5%ae%9e%e7%8e%b0ttl" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>流程图如下</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250216213034195.png" alt="image.png"></p>
<blockquote>
<p>前置:
<a href="/java/advanced/gateway%E7%BD%91%E5%85%B3/">Gateway网关</a></p></blockquote>
<p>上半部分业务为用户请求登录并返回<code>Token</code> 该业务从MVC剥离, 设置在网关进行</p>
<p>我们主要关注下半部分, 用户携带 <code>Token</code> 后如何在服务层获取用户信息</p>
<p>整体流程为:</p>
<ul>
<li>
<p><strong>用户登录请求</strong>：</p>
<ul>
<li>用户通过提交用户名和密码进行登录，经过网关的认证，认证服务（如 <code>Auth</code>）验证用户身份并生成 <code>token</code>。</li>
<li>登录请求返回 <code>token</code> 给用户，用户保存 <code>token</code>。</li>
</ul>
</li>
<li>
<p><strong>后续请求携带 Token 登录</strong>：</p>
<ul>
<li>用户在后续请求中携带该 <code>token</code>，这个 <code>token</code> 用于证明用户的身份。</li>
</ul>
</li>
<li>
<p><strong>Nginx 负载均衡</strong>：</p>
<ul>
<li>请求首先被发送到 <code>Nginx</code>，Nginx 会根据负载均衡策略将请求转发到具体的 <strong>网关</strong>（<code>Gateway</code>）。</li>
</ul>
</li>
<li>
<p><strong>网关鉴权</strong>：</p>
<ul>
<li>网关负责根据请求中的 <code>token</code> 进行 <strong>鉴权</strong>，验证该 <code>token</code> 是否有效。如果验证通过，网关会继续转发请求；如果验证失败，则拒绝请求或重定向至登录页面。</li>
</ul>
</li>
<li>
<p><strong>拦截器将用户信息放入 TTL</strong>：</p>
<ul>
<li>在请求经过网关后，网关会调用拦截器（如 <code>HeaderInterceptor</code>）。拦截器会提取请求中的用户信息（如 <code>token</code> 解密后的用户信息），然后将这些信息存放到 <strong>TTL</strong>（Thread-Local）中。</li>
<li>TTL 是一种线程局部存储机制，用于在当前线程内传递数据，确保在同一请求的生命周期内，后续的服务（如 <code>ProjectService</code> 等）能够访问到这些用户信息。</li>
</ul>
</li>
<li>
<p><strong>后续服务从 TTL 获取用户信息</strong>：</p>
<ul>
<li>后续的服务（如 <code>ProjectService</code>）可以通过访问当前线程的 <strong>TTL</strong> 中的数据来获取用户信息，而无需每次都从请求中提取或解析 <code>token</code>。</li>
</ul>
</li>
</ul>
<p>我们所关注的 TTL 在拦截器里实现</p>
<p>新建 <code>HeaderInterceptor.java</code></p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">HeaderInterceptor</span> <span style="color:#e78284">implements</span> AsyncHandlerInterceptor
</span></span></code></pre></div><p>该拦截器实现了拦截器接口, 该业务在请求执行之前执行拦截业务逻辑, 所以重写 <code>preHandle</code> 在请求执行完毕后需要删除用户信息, 所以重写 <code>afterCompletion</code></p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">HeaderInterceptor</span> <span style="color:#e78284">implements</span> AsyncHandlerInterceptor {  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#8caaee;font-weight:bold">@Override</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">boolean</span> <span style="color:#8caaee">preHandle</span>(HttpServletRequest request, HttpServletResponse response, Object handler) <span style="color:#e78284">throws</span> Exception {  }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#8caaee;font-weight:bold">@Override</span>  
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">afterCompletion</span>(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)  
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">throws</span> Exception {  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>    
</span></span></code></pre></div><p>首先是 <code>preHandle</code></p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">boolean</span> <span style="color:#8caaee">preHandle</span>(HttpServletRequest request, HttpServletResponse response, Object handler) <span style="color:#e78284">throws</span> Exception {  
</span></span><span style="display:flex;"><span>	  <span style="color:#737994;font-style:italic">//不是控制器方法不拦截</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (<span style="color:#99d1db;font-weight:bold">!</span>(handler <span style="color:#ca9ee6">instanceof</span> HandlerMethod)) {  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">true</span>;  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>	<span style="color:#737994;font-style:italic">//自定义holder 用来设置信息  </span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>SecurityContextHolder.<span style="color:#8caaee">setUserId</span>(ServletUtils.<span style="color:#8caaee">getHeader</span>(request, SecurityConstants.<span style="color:#8caaee">DETAILS_USER_ID</span>));  
</span></span><span style="display:flex;"><span>    SecurityContextHolder.<span style="color:#8caaee">setUserName</span>(ServletUtils.<span style="color:#8caaee">getHeader</span>(request, SecurityConstants.<span style="color:#8caaee">DETAILS_USERNAME</span>));  
</span></span><span style="display:flex;"><span>    SecurityContextHolder.<span style="color:#8caaee">setUserKey</span>(ServletUtils.<span style="color:#8caaee">getHeader</span>(request, SecurityConstants.<span style="color:#8caaee">USER_KEY</span>));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">//根据Token创建用户</span>
</span></span><span style="display:flex;"><span>    String token <span style="color:#99d1db;font-weight:bold">=</span> SecurityUtils.<span style="color:#8caaee">getToken</span>();  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (StringUtils.<span style="color:#8caaee">isNotEmpty</span>(token)) {  
</span></span><span style="display:flex;"><span>        LoginUser loginUser <span style="color:#99d1db;font-weight:bold">=</span> AuthUtil.<span style="color:#8caaee">getLoginUser</span>(token);  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (StringUtils.<span style="color:#8caaee">isNotNull</span>(loginUser)) {  
</span></span><span style="display:flex;"><span>            AuthUtil.<span style="color:#8caaee">verifyLoginUserExpire</span>(loginUser);  
</span></span><span style="display:flex;"><span>            SecurityContextHolder.<span style="color:#8caaee">set</span>(SecurityConstants.<span style="color:#8caaee">LOGIN_USER</span>, loginUser);  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    } <span style="color:#ca9ee6">else</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 首页免登场景展示  </span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 检查请求路径是否匹配特定路径  </span>
</span></span><span style="display:flex;"><span>        String requestURI <span style="color:#99d1db;font-weight:bold">=</span> request.<span style="color:#8caaee">getRequestURI</span>();  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (isExemptedPath(requestURI)) {  
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">// 创建一个默认的 LoginUser 对象  </span>
</span></span><span style="display:flex;"><span>            LoginUser defaultLoginUser <span style="color:#99d1db;font-weight:bold">=</span> createDefaultLoginUser();  
</span></span><span style="display:flex;"><span>            SecurityContextHolder.<span style="color:#8caaee">set</span>(SecurityConstants.<span style="color:#8caaee">LOGIN_USER</span>, defaultLoginUser);  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">true</span>;  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里使用 TTL的就是 设置信息的工具类</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">SecurityContextHolder</span>{
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//TTL</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> TransmittableThreadLocal<span style="color:#99d1db;font-weight:bold">&lt;</span>Map<span style="color:#99d1db;font-weight:bold">&lt;</span>String, Object<span style="color:#99d1db;font-weight:bold">&gt;&gt;</span> THREAD_LOCAL <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> TransmittableThreadLocal<span style="color:#99d1db;font-weight:bold">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//设置方法, 在线程Map中存储私有信息</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">set</span>(String key, Object value)  
</span></span><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>    Map<span style="color:#99d1db;font-weight:bold">&lt;</span>String, Object<span style="color:#99d1db;font-weight:bold">&gt;</span> map <span style="color:#99d1db;font-weight:bold">=</span> getLocalMap();  
</span></span><span style="display:flex;"><span>    map.<span style="color:#8caaee">put</span>(key, value <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">null</span> <span style="color:#99d1db;font-weight:bold">?</span> StringUtils.<span style="color:#8caaee">EMPTY</span> : value);  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//这里只就一个例子, 存储固定的用户名前缀和用户名的方法</span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">setUserName</span>(String username)  
</span></span><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>    set(SecurityConstants.<span style="color:#8caaee">DETAILS_USERNAME</span>, username);  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>最后添加其他方法</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e78284">static</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 在这里添加所有需要免登录默认展示首页的的路径  </span>
</span></span><span style="display:flex;"><span>    EXEMPTED_PATHS.<span style="color:#8caaee">add</span>(<span style="color:#a6d189">&#34;/system/user/getInfo&#34;</span>);  
</span></span><span style="display:flex;"><span>    EXEMPTED_PATHS.<span style="color:#8caaee">add</span>(<span style="color:#a6d189">&#34;/project/statistics&#34;</span>);  
</span></span><span style="display:flex;"><span>    EXEMPTED_PATHS.<span style="color:#8caaee">add</span>(<span style="color:#a6d189">&#34;/project/doing&#34;</span>);  
</span></span><span style="display:flex;"><span>    EXEMPTED_PATHS.<span style="color:#8caaee">add</span>(<span style="color:#a6d189">&#34;/project/queryMyTaskList&#34;</span>);  
</span></span><span style="display:flex;"><span>    EXEMPTED_PATHS.<span style="color:#8caaee">add</span>(<span style="color:#a6d189">&#34;/project/select&#34;</span>);  
</span></span><span style="display:flex;"><span>    EXEMPTED_PATHS.<span style="color:#8caaee">add</span>(<span style="color:#a6d189">&#34;/system/menu/getRouters&#34;</span>);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// 需要免登录的路径集合  </span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> Set<span style="color:#99d1db;font-weight:bold">&lt;</span>String<span style="color:#99d1db;font-weight:bold">&gt;</span> EXEMPTED_PATHS <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> HashSet<span style="color:#99d1db;font-weight:bold">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// 判断请求路径是否匹配特定路径, 也就是免密白名单  </span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">private</span> <span style="color:#e78284">boolean</span> <span style="color:#8caaee">isExemptedPath</span>(String requestURI) {  
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 你可以根据需要调整特定路径的匹配逻辑  </span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> EXEMPTED_PATHS.<span style="color:#8caaee">stream</span>().<span style="color:#8caaee">anyMatch</span>(requestURI::startsWith);  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// 创建一个默认的 LoginUser 对象  </span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">private</span> LoginUser <span style="color:#8caaee">createDefaultLoginUser</span>() {  
</span></span><span style="display:flex;"><span>    LoginUser defaultLoginUser <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> LoginUser();  
</span></span><span style="display:flex;"><span>    defaultLoginUser.<span style="color:#8caaee">setUserId</span>(173L);  <span style="color:#737994;font-style:italic">// 设置默认的用户ID  </span>
</span></span><span style="display:flex;"><span>    defaultLoginUser.<span style="color:#8caaee">setUsername</span>(Constants.<span style="color:#8caaee">DEMO_ACCOUNT</span>);  <span style="color:#737994;font-style:italic">// 设置默认的用户名  </span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    SysUser demoSysUser <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> SysUser();  
</span></span><span style="display:flex;"><span>    demoSysUser.<span style="color:#8caaee">setUserId</span>(173L);  
</span></span><span style="display:flex;"><span>    demoSysUser.<span style="color:#8caaee">setUserName</span>(Constants.<span style="color:#8caaee">DEMO_ACCOUNT</span>);  
</span></span><span style="display:flex;"><span>    demoSysUser.<span style="color:#8caaee">setDeptId</span>(100L);  
</span></span><span style="display:flex;"><span>    demoSysUser.<span style="color:#8caaee">setStatus</span>(<span style="color:#a6d189">&#34;0&#34;</span>);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    defaultLoginUser.<span style="color:#8caaee">setUser</span>(demoSysUser);  
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 设置其他必要的默认属性  </span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> defaultLoginUser;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">//结束后清理用户信息, 防止线程复用导致内存泄露</span>
</span></span><span style="display:flex;"><span><span style="color:#8caaee;font-weight:bold">@Override</span>  
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">afterCompletion</span>(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)  
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">throws</span> Exception {  
</span></span><span style="display:flex;"><span>    SecurityContextHolder.<span style="color:#8caaee">remove</span>();  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f91a61b39377d9ea9caf33190d589187">2.12 - WebSocket</h1>
    <div class="lead">HTTP只能单向向服务器请求, 如果要实现服务器通知, 就必须由客户端轮询, 压力非常大. 并且HTTP会携带无效信息, 延迟很高
因此出现了WebSocket</div>
	<p>如果需要定期给浏览器推送数据，例如股票行情，或者不定期给浏览器推送数据，例如在线聊天，基于HTTP协议实现这类需求，只能依靠浏览器的JavaScript定时轮询，效率很低且实时性不高。</p>
<p>2009年出现的新技术<code>Websocket</code> 允许建立浏览器客户端和服务端之间的双向连接, 并且发送轻量级的数据模型, 服务端可以在需要时直接向客户端推送消息</p>
<p>不同于传统的<code>Http</code> ,<code>Websocket</code>  允许建立通路, 可以直接发送信息而不需像HTTP一样创建连接上下文, 原理如下</p>
<p>在建立TCP连接后, 附带几个请求头</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-http" data-lang="http"><span style="display:flex;"><span><span style="color:#8caaee">GET</span> <span style="color:#ef9f76">/chat</span> <span style="color:#ca9ee6">HTTP</span><span style="color:#99d1db;font-weight:bold">/</span><span style="color:#ef9f76">1.1</span>
</span></span><span style="display:flex;"><span>Host<span style="color:#99d1db;font-weight:bold">:</span> www.example.com
</span></span><span style="display:flex;"><span>Upgrade<span style="color:#99d1db;font-weight:bold">:</span> websocket
</span></span><span style="display:flex;"><span>Connection<span style="color:#99d1db;font-weight:bold">:</span> Upgrade
</span></span></code></pre></div><p>此后连接升级为长连接</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>HTTP/1.1 101 Switching Protocols
</span></span><span style="display:flex;"><span>Upgrade: websocket
</span></span><span style="display:flex;"><span>Connection: Upgrade
</span></span></code></pre></div><p>收到成功响应后表示WebSocket“握手”成功，这样，代表WebSocket的这个TCP连接将不会被服务器关闭，而是一直保持，服务器可随时向浏览器推送消息，浏览器也可随时向服务器推送消息。双方推送的消息既可以是文本消息，也可以是二进制消息，一般来说，绝大部分应用程序会推送基于JSON的文本消息。</p>
<h4 id="使用-websocket">使用 Websocket<a class="td-heading-self-link" href="#%e4%bd%bf%e7%94%a8-websocket" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>开始前阅读 <a href="content/en/java/Advanced/_index.md">架构说明</a></p>
<p>建立新模块 <code>sample-ws</code></p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">&lt;!-- ws --&gt;</span>  
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">&lt;dependency&gt;</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">&lt;groupId&gt;</span>org.springframework.boot<span style="color:#ca9ee6">&lt;/groupId&gt;</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">&lt;artifactId&gt;</span>spring-boot-starter-websocket<span style="color:#ca9ee6">&lt;/artifactId&gt;</span>  
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>启动类</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * 描述：程序启动入口  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> *  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @author hamhuo  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @version 1.0.0  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span><span style="color:#8caaee;font-weight:bold">@SpringBootApplication</span>  
</span></span><span style="display:flex;"><span><span style="color:#8caaee;font-weight:bold">@EnableBinding</span>(Sink.<span style="color:#8caaee">class</span>)  
</span></span><span style="display:flex;"><span><span style="color:#8caaee;font-weight:bold">@EnableDiscoveryClient</span>  
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">WsApplication</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> <span style="color:#e78284">static</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">main</span>(String<span style="color:#99d1db;font-weight:bold">[]</span> args) {  
</span></span><span style="display:flex;"><span>        SpringApplication.<span style="color:#8caaee">run</span>(WsApplication.<span style="color:#8caaee">class</span>, args);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实现服务端和浏览器的双向通信, 我们要写一个服务器</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#8caaee;font-weight:bold">@Component</span>  
</span></span><span style="display:flex;"><span><span style="color:#8caaee;font-weight:bold">@ServerEndpoint</span>(<span style="color:#a6d189">&#34;/chat&#34;</span>)  
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">ChatServer</span> {
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * 保存连接对象, 连接池, 放用户session和key
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> */</span>  
</span></span><span style="display:flex;"><span><span style="color:#e78284">private</span> <span style="color:#e78284">static</span> <span style="color:#e78284">final</span> ConcurrentHashMap<span style="color:#99d1db;font-weight:bold">&lt;</span>String, Session<span style="color:#99d1db;font-weight:bold">&gt;</span> SESSION_POOL <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> ConcurrentHashMap<span style="color:#99d1db;font-weight:bold">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8caaee;font-weight:bold">@OnOpen</span>  
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">onOpen</span>(Session session) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8caaee;font-weight:bold">@OnMessage</span>  
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> String <span style="color:#8caaee">onMessage</span>(String text, Session session) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8caaee;font-weight:bold">@OnClose</span>  
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">onClose</span>(Session session)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8caaee;font-weight:bold">@OnError</span>  
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">onError</span>(Session session, Throwable throwable)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>解释一下</p>
<ol>
<li>
<p>首先组件注解加上, Spring 会自动装载为组件</p>
</li>
<li>
<p>关于 <code>@ServerEndpoint</code>
WebSocket 是一种基于 TCP 的协议，它是持久化连接，通信过程中不会像 HTTP 请求那样每次都经过请求-响应的流程，因此不能直接通过传统的 Spring MVC 控制器方法来处理。</p>
<p><code>@ServerEndpoint</code> 是 WebSocket 规范中的一种标注方式，用来标识一个 WebSocket 服务器端点。当客户端连接到这个端点时，会自动调用这个类中的相应方法。</p>
<p>我们只需要知道服务器与 /server 绑定即可</p>
</li>
<li>
<p>我们在server中定义了四个方法, 启动时调用, 消息时调用, 关闭时调用, 错误时调用</p>
</li>
<li>
<p>我们创建一个链接池, 存放浏览器和服务器的长连接</p>
</li>
</ol>
<p>这个端点注解依赖一个配置类</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250223215044977.png" alt="image.png"></p>
<p>我们在 <code>ws.config</code> 下新建一个配置类 ,这是写死的, 不用理解</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">/**  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @program: demo  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @description: 服务端点配置  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> * @author: hamhuo  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"> **/</span>  
</span></span><span style="display:flex;"><span><span style="color:#8caaee;font-weight:bold">@Configuration</span>  
</span></span><span style="display:flex;"><span><span style="color:#8caaee;font-weight:bold">@EnableWebSocket</span>  
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">class</span> <span style="color:#e5c890">WebSocketConfig</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#8caaee;font-weight:bold">@Bean</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">public</span> ServerEndpointExporter <span style="color:#8caaee">serverEndpoint</span>() {  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> <span style="color:#ca9ee6">new</span> ServerEndpointExporter();  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当浏览器首先试图建立与服务器的连接, 这里调用 <code>@OnOpen</code> 注解方法</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#8caaee;font-weight:bold">@OnOpen</span>  
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">onOpen</span>(Session session) <span style="color:#e78284">throws</span> IOException {  
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">//判断客户端对象是否存在  </span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">//排除重复的连接对象  </span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (SESSION_POOL.<span style="color:#8caaee">containsKey</span>(session.<span style="color:#8caaee">getQueryString</span>())) {  
</span></span><span style="display:flex;"><span>        CloseReason reason <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> CloseReason(CloseReason.<span style="color:#8caaee">CloseCodes</span>.<span style="color:#8caaee">CANNOT_ACCEPT</span>, <span style="color:#a6d189">&#34;ID冲突，连接拒绝&#34;</span>);  
</span></span><span style="display:flex;"><span>        session.<span style="color:#8caaee">getUserProperties</span>().<span style="color:#8caaee">put</span>(<span style="color:#a6d189">&#34;reason&#34;</span>, reason);  
</span></span><span style="display:flex;"><span>        session.<span style="color:#8caaee">close</span>();  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span>;  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">//将客户端记录到Map中  </span>
</span></span><span style="display:flex;"><span>    SESSION_POOL.<span style="color:#8caaee">put</span>(session.<span style="color:#8caaee">getQueryString</span>(), session);  
</span></span><span style="display:flex;"><span>    System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(<span style="color:#a6d189">&#34;客户端（&#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> session.<span style="color:#8caaee">getQueryString</span>() <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;）：开启连接&#34;</span>);  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>解释一下, 浏览器会传入一个客户端ID, 服务器根据ID来提供服务</p>
<p>每个ID标识了长连接, 服务器根据ID提供服务</p>
<ol>
<li>传入连接后判断是否重复, 从连接池拿session里的key, 如果重复就拒绝连接</li>
<li>没有重复, 将Session保存到连接池(Map)里</li>
<li>控制套打印日志, 这里可以用slf4j</li>
</ol>
<blockquote>
<p>注意:
这里的<code>Session</code> 指的是长连接, 和 <code>HTTP Session</code> 不是一个东西</p></blockquote>
<p>之后长连接建立, 可以双向监听信息, 一旦服务器或者浏览器有信息了就调用 <code>@OnMessage</code></p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#8caaee;font-weight:bold">@OnMessage</span>  
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> String <span style="color:#8caaee">onMessage</span>(String text, Session session) <span style="color:#e78284">throws</span> IOException {  
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">//解析消息 =&gt; ID::消息内容  </span>
</span></span><span style="display:flex;"><span>    String<span style="color:#99d1db;font-weight:bold">[]</span> msgArr <span style="color:#99d1db;font-weight:bold">=</span> text.<span style="color:#8caaee">split</span>(<span style="color:#a6d189">&#34;::&#34;</span>, 2);  
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">//群发消息 ID=all表示群发  </span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (<span style="color:#a6d189">&#34;all&#34;</span>.<span style="color:#8caaee">equalsIgnoreCase</span>(msgArr<span style="color:#99d1db;font-weight:bold">[</span>0<span style="color:#99d1db;font-weight:bold">]</span>)) {  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">for</span> (Session one : SESSION_POOL.<span style="color:#8caaee">values</span>()) {  
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">//排除自己  </span>
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (session <span style="color:#99d1db;font-weight:bold">==</span> one) {  
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">continue</span>;  
</span></span><span style="display:flex;"><span>            }  
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">//发送消息  </span>
</span></span><span style="display:flex;"><span>            one.<span style="color:#8caaee">getBasicRemote</span>().<span style="color:#8caaee">sendText</span>(msgArr<span style="color:#99d1db;font-weight:bold">[</span>1<span style="color:#99d1db;font-weight:bold">]</span>);  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">//指定发送人, 不是all的情况  </span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">else</span> {  
</span></span><span style="display:flex;"><span>        Session target <span style="color:#99d1db;font-weight:bold">=</span> SESSION_POOL.<span style="color:#8caaee">get</span>(msgArr<span style="color:#99d1db;font-weight:bold">[</span>0<span style="color:#99d1db;font-weight:bold">]</span>);  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (target <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ef9f76">null</span>) {  
</span></span><span style="display:flex;"><span>            target.<span style="color:#8caaee">getBasicRemote</span>().<span style="color:#8caaee">sendText</span>(msgArr<span style="color:#99d1db;font-weight:bold">[</span>1<span style="color:#99d1db;font-weight:bold">]</span>);  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> session.<span style="color:#8caaee">getQueryString</span>() <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;:消息发送成功&#34;</span>;  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>消息发送的方式有两种, 点对点和群发</p>
<p>点对点就找出目标Session, 服务器向Session写信息发送就行
群发就需要遍历连接池的每一个Session, 全部写信息</p>
<p>当然, 前提是排除发送者的Session</p>
<p>关闭连接, 也就是浏览器离线需要执行线程池移除线程的操作, 调用 <code>@OnClose</code> 方法
这里注意, webSocket并没有强制关闭连接的能力, 这是通知远程连接自主关闭, 服务器只负责监视是否关闭</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#8caaee;font-weight:bold">@OnClose</span>  
</span></span><span style="display:flex;"><span><span style="color:#e78284">public</span> <span style="color:#e78284">void</span> <span style="color:#8caaee">onClose</span>(Session session) {  
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">//处理拒绝连接session关闭对象, 不从池子里移除  </span>
</span></span><span style="display:flex;"><span>    Object obj <span style="color:#99d1db;font-weight:bold">=</span> session.<span style="color:#8caaee">getUserProperties</span>().<span style="color:#8caaee">get</span>(<span style="color:#a6d189">&#34;reason&#34;</span>);  
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">if</span> (obj <span style="color:#ca9ee6">instanceof</span> CloseReason) {  
</span></span><span style="display:flex;"><span>        CloseReason reason <span style="color:#99d1db;font-weight:bold">=</span> (CloseReason) obj;  
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (reason.<span style="color:#8caaee">getCloseCode</span>() <span style="color:#99d1db;font-weight:bold">==</span> CloseReason.<span style="color:#8caaee">CloseCodes</span>.<span style="color:#8caaee">CANNOT_ACCEPT</span>) {  
</span></span><span style="display:flex;"><span>            System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(<span style="color:#a6d189">&#34;拒绝客户端（&#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> session.<span style="color:#8caaee">getQueryString</span>() <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;）：关闭连接&#34;</span>);  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">return</span>;  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">//将session对象从map中移除,正常关闭  </span>
</span></span><span style="display:flex;"><span>    SESSION_POOL.<span style="color:#8caaee">remove</span>(session.<span style="color:#8caaee">getQueryString</span>());  
</span></span><span style="display:flex;"><span>    System.<span style="color:#8caaee">out</span>.<span style="color:#8caaee">println</span>(<span style="color:#a6d189">&#34;客户端（&#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> session.<span style="color:#8caaee">getQueryString</span>() <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;）：关闭连接&#34;</span>);  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>这是比较简单的应用不再考虑连接复用的问题</p></blockquote>
<p>接下来写浏览器页面</p>
<p>这里我们略过了~</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">&lt;!DOCTYPE html&gt;</span>  
</span></span><span style="display:flex;"><span>&lt;<span style="color:#ca9ee6">html</span> <span style="color:#8caaee">lang</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;en&#34;</span>&gt;  
</span></span><span style="display:flex;"><span>&lt;<span style="color:#ca9ee6">head</span>&gt;  
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#ca9ee6">meta</span> <span style="color:#8caaee">charset</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;UTF-8&#34;</span>&gt;  
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#ca9ee6">title</span>&gt;聊天室客户端&lt;/<span style="color:#ca9ee6">title</span>&gt;  
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#ca9ee6">head</span>&gt;  
</span></span><span style="display:flex;"><span>&lt;<span style="color:#ca9ee6">body</span>&gt;  
</span></span><span style="display:flex;"><span>&lt;<span style="color:#ca9ee6">h1</span>&gt;Chat Client&lt;/<span style="color:#ca9ee6">h1</span>&gt;  
</span></span><span style="display:flex;"><span>&lt;<span style="color:#ca9ee6">div</span>&gt;  
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#ca9ee6">input</span> <span style="color:#8caaee">id</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;clientId&#34;</span> <span style="color:#8caaee">placeholder</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;输入ID&#34;</span> <span style="color:#8caaee">value</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;1&#34;</span>&gt;  
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#ca9ee6">input</span> <span style="color:#8caaee">onclick</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;init()&#34;</span> <span style="color:#8caaee">value</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;连接服务器&#34;</span> <span style="color:#8caaee">type</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;button&#34;</span>&gt;&lt;<span style="color:#ca9ee6">br</span>&gt;&lt;<span style="color:#ca9ee6">br</span>&gt;  
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#ca9ee6">input</span> <span style="color:#8caaee">id</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;receiverId&#34;</span> <span style="color:#8caaee">placeholder</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;输入接收人ID&#34;</span> <span style="color:#8caaee">value</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;all&#34;</span>&gt;&lt;<span style="color:#ca9ee6">br</span>&gt;&lt;<span style="color:#ca9ee6">br</span>&gt;  
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#ca9ee6">textarea</span> <span style="color:#8caaee">id</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;message&#34;</span> <span style="color:#8caaee">style</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;margin: 0; height: 197px; width: 362px;&#34;</span>  
</span></span><span style="display:flex;"><span>              <span style="color:#8caaee">placeholder</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;发送消息内容&#34;</span>&gt;&lt;/<span style="color:#ca9ee6">textarea</span>&gt;&lt;<span style="color:#ca9ee6">br</span>&gt;  
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#ca9ee6">input</span> <span style="color:#8caaee">onclick</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;send()&#34;</span> <span style="color:#8caaee">value</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;发送消息&#34;</span> <span style="color:#8caaee">type</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;button&#34;</span>&gt;  
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#ca9ee6">input</span> <span style="color:#8caaee">onclick</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;closeConnect()&#34;</span> <span style="color:#8caaee">value</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;关闭连接&#34;</span> <span style="color:#8caaee">type</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;button&#34;</span>&gt;  
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#ca9ee6">div</span>&gt;  
</span></span><span style="display:flex;"><span>&lt;<span style="color:#ca9ee6">div</span> <span style="color:#8caaee">id</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;output&#34;</span>&gt;&lt;/<span style="color:#ca9ee6">div</span>&gt;  
</span></span><span style="display:flex;"><span>&lt;<span style="color:#ca9ee6">script</span> <span style="color:#8caaee">type</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;text/javascript&#34;</span> <span style="color:#8caaee">language</span><span style="color:#99d1db;font-weight:bold">=</span><span style="color:#a6d189">&#34;JavaScript&#34;</span>&gt;  
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">//屏幕回显输出方法  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    <span style="color:#e78284">function</span> writeToScreen(message) {  
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">let</span> pre <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#99d1db">document</span>.createElement(<span style="color:#a6d189">&#34;p&#34;</span>);  
</span></span><span style="display:flex;"><span>        pre.style.wordWrap <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#34;break-word&#34;</span>;  
</span></span><span style="display:flex;"><span>        pre.innerHTML <span style="color:#99d1db;font-weight:bold">=</span> message;  
</span></span><span style="display:flex;"><span>        <span style="color:#99d1db">document</span>.getElementById(<span style="color:#a6d189">&#34;output&#34;</span>).appendChild(pre);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">//初始化websocket  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    <span style="color:#e78284">let</span> echo_websocket;  
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">function</span> init() {  
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">let</span> clientId <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#99d1db">document</span>.getElementById(<span style="color:#a6d189">&#34;clientId&#34;</span>).value;  
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">/* 这里端口是写死的 */</span>        <span style="color:#e78284">let</span> wsUri <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#a6d189">&#34;ws://localhost:10800/chat?&#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> clientId;  
</span></span><span style="display:flex;"><span>        writeToScreen(<span style="color:#a6d189">&#34;连接到&#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> wsUri);  
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//1.创建WebSocket客户端对象  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>        echo_websocket <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> WebSocket(wsUri);  
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//2.开门握手完成回调  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>        echo_websocket.onopen <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#e78284">function</span> (evt) {  
</span></span><span style="display:flex;"><span>            console.log(evt);  
</span></span><span style="display:flex;"><span>            writeToScreen(<span style="color:#a6d189">&#34;连接打开成功 !&#34;</span>);  
</span></span><span style="display:flex;"><span>        };  
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//3.监听服务端的消息  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>        echo_websocket.onmessage <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#e78284">function</span> (evt) {  
</span></span><span style="display:flex;"><span>            writeToScreen(<span style="color:#a6d189">&#34;接收服务端消息:&lt;br&gt; &#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> evt.data);  
</span></span><span style="display:flex;"><span>        };  
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//4.如果连接中断  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>        echo_websocket.onerror <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#e78284">function</span> (evt) {  
</span></span><span style="display:flex;"><span>            writeToScreen(<span style="color:#a6d189">&#39;&lt;span style=&#34;color: red;&#34;&gt;ERROR:&#39;</span><span style="color:#99d1db;font-weight:bold">+</span>evt.data<span style="color:#99d1db;font-weight:bold">+</span><span style="color:#a6d189">&#39;&lt;/span&gt;&#39;</span>);  
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">//关闭连接  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>            closeConnect();  
</span></span><span style="display:flex;"><span>        };  
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">//5.注册close事件  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>        echo_websocket.onclose <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#e78284">function</span>(evt){  
</span></span><span style="display:flex;"><span>            writeToScreen(<span style="color:#a6d189">&#39;&lt;span style=&#34;color: green;&#34;&gt;INFO：关闭连接&lt;/span&gt; &#39;</span>);  
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span>(evt.reason){  
</span></span><span style="display:flex;"><span>                writeToScreen  
</span></span><span style="display:flex;"><span>                (<span style="color:#a6d189">`&lt;span style=&#34;color: red;&#34;&gt;错误信息：</span><span style="color:#a6d189">${</span>evt.reason<span style="color:#a6d189">}</span><span style="color:#a6d189">&lt;/span&gt; `</span>);  
</span></span><span style="display:flex;"><span>            }  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">//6.向服务发送消息  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    <span style="color:#e78284">function</span> send() {  
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">let</span> message <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#99d1db">document</span>.getElementById(<span style="color:#a6d189">&#34;message&#34;</span>).value;  
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">let</span> receiver <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#99d1db">document</span>.getElementById(<span style="color:#a6d189">&#34;receiverId&#34;</span>).value;  
</span></span><span style="display:flex;"><span>        echo_websocket.send(receiver <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#a6d189">&#34;::&#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> message);  
</span></span><span style="display:flex;"><span>        writeToScreen(<span style="color:#a6d189">&#34;发送消息: &#34;</span> <span style="color:#99d1db;font-weight:bold">+</span> message);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">//7.如果不需要通讯，那么关闭连接  
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    <span style="color:#e78284">function</span> closeConnect() {  
</span></span><span style="display:flex;"><span>        echo_websocket.close();  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#ca9ee6">script</span>&gt;  
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#ca9ee6">body</span>&gt;  
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#ca9ee6">html</span>&gt;
</span></span></code></pre></div><p>我们需要解释下构建/发送信息的代码</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>//6.向服务发送消息  
</span></span><span style="display:flex;"><span>    function send() {  
</span></span><span style="display:flex;"><span>        let message = document.getElementById(&#34;message&#34;).value;  
</span></span><span style="display:flex;"><span>        let receiver = document.getElementById(&#34;receiverId&#34;).value;  
</span></span><span style="display:flex;"><span>        echo_websocket.send(receiver + &#34;::&#34; + message);  
</span></span><span style="display:flex;"><span>        writeToScreen(&#34;发送消息: &#34; + message);  
</span></span><span style="display:flex;"><span>    } 
</span></span></code></pre></div><p>这里拿到表单组件, 取值后通过 <code>::</code> 拼接为消息, 链接符之前为id, 之后为消息</p>
<p>其中初始化的 <code>echo_websocket</code> 组件是dom库提供的 <code>echo_websocket = new WebSocket(wsUri);</code> , 除了IE其他浏览器都支持</p>
<p>在前端打开三个浏览器页面, 作为三个客户端</p>
<p><img src="https://raw.githubusercontent.com/hamhuo-hub/HamPic/img/img/20250223215339746.png" alt="image.png"></p>
<p>注意id要不同</p>
<p>后台运行服务器, 就可以开始监听了</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-7a2c40656558a17fe41d7952d03dfa64">2.13 - 事务管理</h1>
    
	<h4 id="事务是什么">事务是什么?<a class="td-heading-self-link" href="#%e4%ba%8b%e5%8a%a1%e6%98%af%e4%bb%80%e4%b9%88" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>一组操作, 要么全部执行, 要么全部失败, 把非原子操作封装为原子操作的概念</p>
<p>还是老生长谈的原子性问题</p>
<blockquote>
<p><a href="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.md#%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98">原子性问题</a></p></blockquote>
<h4 id="事务的特性">事务的特性<a class="td-heading-self-link" href="#%e4%ba%8b%e5%8a%a1%e7%9a%84%e7%89%b9%e6%80%a7" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>ACID</p>
<p>原子性: 事务是最小的执行单位, 不允许分割. 事务的原子性确保动作要么全部完成, 要么不起作用</p>
<p>隔离性: 一个用户的事务不能被其他用户干扰, 并发事务之间的数据库独立</p>
<p>持久性: 事务提交后, 数据库改变时持久的, 即使发生故障也不能有任何影响</p>
<p>最终目的: 一致性: 事务前的数据一致, 事务后的数据一致</p>
<p>原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性</p>
<h4 id="mysql如何保证事务的原子性的">MySQL如何保证事务的原子性的?<a class="td-heading-self-link" href="#mysql%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e4%ba%8b%e5%8a%a1%e7%9a%84%e5%8e%9f%e5%ad%90%e6%80%a7%e7%9a%84" aria-label="Heading self-link"></a></h4>
<meta name="baidu-site-verification" content="codeva-23xblvQ4Jb" /><p>所有事务操作都会记录到回滚操作日志, 一旦异常发生就会根据日志进行数据回滚
回滚日志的优先级高于数据持久化, 也就是说数据库宕机导致数据没能完整写到磁盘上, 再次开机可以根据回滚日志回滚未完成的事务</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ca8521f6a11893682100c677a8e28283">2.14 - 响应式编程Reactor库</h1>
    
	
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-7f81b67460689b745ab9bb3e9564c653">2.15 - 声明式服务</h1>
    
	
</div>



    
	
  

    
	
  



          </main>
        </div>
      </div>
      <footer class="td-footer row d-print-none">
  <div class="container-fluid">
    <div class="row mx-md-2">
      <div class="td-footer__left col-6 col-sm-4 order-sm-1">
        <ul class="td-footer__links-list">
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="User mailing list" aria-label="User mailing list">
    <a target="_blank" rel="noopener" href="https://example.org/mail" aria-label="User mailing list">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="Twitter" aria-label="Twitter">
    <a target="_blank" rel="noopener" href="https://example.org/twitter" aria-label="Twitter">
      <i class="fab fa-twitter"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="Stack Overflow" aria-label="Stack Overflow">
    <a target="_blank" rel="noopener" href="https://example.org/stack" aria-label="Stack Overflow">
      <i class="fab fa-stack-overflow"></i>
    </a>
  </li>
  
</ul>

      </div><div class="td-footer__right col-6 col-sm-4 order-sm-3">
        <ul class="td-footer__links-list">
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="GitHub" aria-label="GitHub">
    <a target="_blank" rel="noopener" href="https://github.com/hamhuo-hub/seaku" aria-label="GitHub">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="Slack" aria-label="Slack">
    <a target="_blank" rel="noopener" href="https://example.org/slack" aria-label="Slack">
      <i class="fab fa-slack"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="Developer mailing list" aria-label="Developer mailing list">
    <a target="_blank" rel="noopener" href="https://example.org/mail" aria-label="Developer mailing list">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
</ul>

      </div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2">
        <span class="td-footer__copyright">&copy;
    2025&ndash;2025
    <span class="td-footer__authors">海阔知识库 | <a href="https://creativecommons.org/licenses/by/4.0">CC BY 4.0</a> |</span></span><span class="td-footer__all_rights_reserved">All Rights Reserved</span><span class="ms-2"><a href="https://policies.google.com/privacy" target="_blank" rel="noopener">Privacy Policy</a></span>
      </div>
    </div>
  </div>
</footer>

    </div>
    <script src="/js/main.min.90902a026ed2aee7ed45d85797f4c790b240ba148ac6f8a6f194cb1981ffecf5.js" integrity="sha256-kJAqAm7SruftRdhXl/THkLJAuhSKxvim8ZTLGYH/7PU=" crossorigin="anonymous"></script>
<script defer src="/js/click-to-copy.min.73478a7d4807698aed7e355eb23f9890ca18fea3158604c8471746d046702bad.js" integrity="sha256-c0eKfUgHaYrtfjVesj&#43;YkMoY/qMVhgTIRxdG0EZwK60=" crossorigin="anonymous"></script>
<script src='/js/tabpane-persist.js'></script>

  </body>
</html>
